"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[968],{9584:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));t(6340);const l={},o="Day 12: Hot Springs",s={unversionedId:"2023/puzzles/day12",id:"2023/puzzles/day12",title:"Day 12: Hot Springs",description:"by @mbovel",source:"@site/target/mdoc/2023/puzzles/day12.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day12",permalink:"/scala-advent-of-code/2023/puzzles/day12",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day12.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 11: Cosmic Expansion",permalink:"/scala-advent-of-code/2023/puzzles/day11"},next:{title:"Day 13: Point of Incidence",permalink:"/scala-advent-of-code/2023/puzzles/day13"}},r={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Scaffold",id:"scaffold",level:2},{value:"Tests",id:"tests",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Implementation of <code>countAll</code> and <code>countRow</code>",id:"implementation-of-countall-and-countrow",level:3},{value:"Character-level implementation of <code>count</code>",id:"character-level-implementation-of-count",level:3},{value:"Counting calls",id:"counting-calls",level:3},{value:"Memoization",id:"memoization",level:3},{value:"Part 2",id:"part-2",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Group-level implementation of <code>count</code>",id:"group-level-implementation-of-count",level:3},{value:"Local cache",id:"local-cache",level:3},{value:"Simplify cache keys",id:"simplify-cache-keys",level:3},{value:"Simplify the cache structure",id:"simplify-the-cache-structure",level:3},{value:"Inline helper functions",id:"inline-helper-functions",level:3},{value:"Further optimizations",id:"further-optimizations",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:p};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-12-hot-springs"},"Day 12: Hot Springs"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mbovel"},"@mbovel")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/12"},"https://adventofcode.com/2023/day/12")),(0,i.kt)("h2",{id:"scaffold"},"Scaffold"),(0,i.kt)("p",null,"Let's create a folder with a file ",(0,i.kt)("inlineCode",{parentName:"p"},"day12.scala")," to hold the core of our code."),(0,i.kt)("p",null,"We start by writing two examples and defining three functions ",(0,i.kt)("inlineCode",{parentName:"p"},"countAll"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"countRow"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," that we will implement later:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'//> using scala 3.3.1\n\nimport scala.io.Source\n\n/** The example puzzle from the problem description. */\nval examplePuzzle = IArray(\n  "???.### 1,1,3",\n  ".??..??...?##. 1,1,3",\n  "?#?#?#?#?#?#?#? 1,3,1,6",\n  "????.#...#... 4,1,1",\n  "????.######..#####. 1,6,5",\n  "###???????? 3,2,1"\n)\n\n/** Our personal puzzle input. */\nval personalPuzzle = Source.fromFile("input.txt").mkString.trim()\n\n/** Entry point for part 1. */\n@main def part1(): Unit = println(countAll(personalPuzzle))\n\n/** Sums `countRow` over all rows in `input`. */\ndef countAll(input: String): Long = ???\n\n/** Counts all of the different valid arrangements of\n  * operational and broken springs in the given row.\n  */\ndef countRow(input: String): Long = ???\n\n/** Helper recursive function for `countRow` that does\n  * the actual work.\n  *\n  * @param input\n  *   the remaining input to process\n  * @param ds\n  *   a list of the numbers of damaged springs remaining to be placed\n  */\ndef count(input: List[Char], ds: List[Int]): Long = ???\n')),(0,i.kt)("p",null,"Thanks to ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org"},"scala-cli")," we can run this file with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ scala-cli -M part1 .\n")),(0,i.kt)("h2",{id:"tests"},"Tests"),(0,i.kt)("p",null,"In the same folder, we create a file ",(0,i.kt)("inlineCode",{parentName:"p"},"day12.test.scala")," to hold our tests. We write one test for each individual row of the example from the instructions, a test for the whole example, and a test for our personal puzzle input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'//> using scala 3.3.1\n//> using test.dep org.scalameta::munit::1.0.0-M10\n\nclass Day12Test extends munit.FunSuite:\n  test("example row 1"):\n    assertEquals(countRow(examplePuzzle(0)), 1L)\n\n  test("example row 2"):\n    assertEquals(countRow(examplePuzzle(1)), 4L)\n\n  test("example row 3"):\n    assertEquals(countRow(examplePuzzle(2)), 1L)\n\n  test("example row 4"):\n    assertEquals(countRow(examplePuzzle(3)), 1L)\n\n  test("example row 5"):\n    assertEquals(countRow(examplePuzzle(4)), 4L)\n\n  test("example row 6"):\n    assertEquals(countRow(examplePuzzle(5)), 10L)\n\n  test("example"):\n    assertEquals(countAll(examplePuzzle.mkString("\\n")), 21L)\n\n  test("puzzle input"):\n    assertEquals(countAll(personalPuzzle), 7118L)\n')),(0,i.kt)("p",null,"We can run the tests with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ scala-cli test .\n")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("h3",{id:"implementation-of-countall-and-countrow"},"Implementation of ",(0,i.kt)("inlineCode",{parentName:"h3"},"countAll")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"countRow")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"countAll")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"countRow")," can be implemented concisely using ",(0,i.kt)("inlineCode",{parentName:"p"},"split")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def countAll(input: String): Long = input.split("\\n").map(countRow).sum\n\ndef countRow(input: String): Long =\n  val Array(conditions, damagedCounts) = input.split(" ")\n  count(\n    conditions.toList,\n    damagedCounts.split(",").map(_.toInt).toList\n  )\n')),(0,i.kt)("h3",{id:"character-level-implementation-of-count"},"Character-level implementation of ",(0,i.kt)("inlineCode",{parentName:"h3"},"count")),(0,i.kt)("p",null,"For our first implementation, we'll iterate through the input string character by character, and we'll use an additional parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," to keep track of the number of consecutive damaged springs seen so far:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"/** Helper recursive function for `countRow` that does the actual work.\n  *\n  * @param input\n  *   the remaining input to process\n  * @param ds\n  *   a list of the numbers of damaged springs remaining to be placed\n  * @param d\n  *   the number of consecutive damaged springs seen so far\n  */\ndef count(input: List[Char], ds: List[Int], d: Int = 0): Long =\n  // We've reached the end of the input.\n  if input.isEmpty then\n    // This is a valid arrangement if there are no sequences of\n    // damaged springs left to place (ds.isEmpty) and  we're\n    // not currently in a sequence of damaged springs (d == 0).\n    if ds.isEmpty && d == 0 then 1L\n    // This is also a valid arrangement if there is one sequence\n    // of damaged springs left to place (ds.length == 1) and its\n    // size is d (ds.head == d).\n    else if ds.length == 1 && ds.head == d then 1L\n    // Otherwise, this is not a valid arrangement.\n    else 0\n  else\n    def operationalCase() =\n      // If we're not currently in a sequence of damaged springs,\n      // then we can consume an operational spring.\n      if d == 0 then count(input.tail, ds, 0)\n      // We are currently in a sequence of damaged springs,\n      // which this operational spring ends. If the length\n      // of the damaged sequence is the expected one, the we can\n      // continue with the next damaged sequence.\n      else if !ds.isEmpty && ds.head == d then\n        count(input.tail, ds.tail, 0)\n      // Otherwise, this is not a valid arrangement.\n      else 0L\n    def damagedCase() =\n      // If no damaged springs are expected, then this is not a valid\n      // arrangement.\n      if ds.isEmpty then 0L\n      // Optimization: no need to recurse if d becomes greater than the\n      // expected damaged sequence length.\n      else if d == ds.head then 0L\n      // Otherwise, we can consume a damaged spring.\n      else count(input.tail, ds, d + 1)\n    input.head match\n      // If we encounter a question mark, this position can have\n      // either an operational or a damaged spring.\n      case '?' => operationalCase() + damagedCase()\n      // If we encounter a dot, this position has an operational\n      // spring.\n      case '.' => operationalCase()\n      // If we encounter a hash, this position has damaged spring.\n      case '#' => damagedCase()\n")),(0,i.kt)("h3",{id:"counting-calls"},"Counting calls"),(0,i.kt)("p",null,"The implementation above is correct, but it has an exponential run time complexity: it calls itself up to two times at each step, so the number of calls grows exponentially with the length of the input."),(0,i.kt)("p",null,"To demonstrate this, we will add a counter ",(0,i.kt)("inlineCode",{parentName:"p"},"ops")," that counts the number of calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"count"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"var ops = 0\nprivate def count(input: List[Char], d: Long, ds: List[Long]): Long =\n  ops += 1\n  // ... same as before ...\n")),(0,i.kt)("p",null,"And consider the following example puzzle in addition to our two existing examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val slowPuzzleSize = 16\nval slowPuzzle =\n  ("??." * slowPuzzleSize) + " " + ("1," * (slowPuzzleSize - 1)) + "1"\n')),(0,i.kt)("p",null,"To see how many times ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," is called for our example puzzles, we add the following function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'@main def countOps =\n  val puzzles =\n    IArray(\n      ("example", examplePuzzle.mkString("\\n")),\n      ("personal", personalPuzzle),\n      ("slow", slowPuzzle)\n    )\n  for (name, input) <- puzzles do\n    ops = 0\n    val start = System.nanoTime()\n    val result = countAll(input)\n    val end = System.nanoTime()\n    val elapsed = (end - start) / 1_000_000\n    println(f"$name%8s: $result%5d ($ops%9d calls, $elapsed%4d ms)")\n')),(0,i.kt)("p",null,"Running this code gives us the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"}," example:    21 (      305 calls,   24 ms)\npersonal:  7118 (   149712 calls,   37 ms)\n    slow: 65536 (172186881 calls, 1415 ms)\n")),(0,i.kt)("h3",{id:"memoization"},"Memoization"),(0,i.kt)("p",null,"Many of the calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," are redundant: they are made with the same arguments as previous calls. A quick way to improve algorithmic complexity and the performance of this function is to ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Memoization"},(0,i.kt)("em",{parentName:"a"},"memoize"))," it: we can cache the results of previous calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," and reuse them when the same arguments are passed again."),(0,i.kt)("p",null,"We can use a ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/mutable/Map.html"},(0,i.kt)("inlineCode",{parentName:"a"},"mutable.Map"))," to store the results of previous calls. We use tuples containing the arguments ",(0,i.kt)("inlineCode",{parentName:"p"},"(input, ds, d)")," as keys, and we use the ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/mutable/Map.html#getOrElseUpdate-fffff230"},(0,i.kt)("inlineCode",{parentName:"a"},"getOrElseUpdate"))," method to either retrieve the cached result or compute it and store it in the map."),(0,i.kt)("p",null,"Here is the memoized version of ",(0,i.kt)("inlineCode",{parentName:"p"},"count"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable\n\nval cache = mutable.Map.empty[(List[Char], List[Int], Long), Long]\nprivate def count(input: List[Char], ds: List[Int], d: Int = 0): Long =\n  cache.getOrElseUpdate((input, ds, d), countUncached(input, ds, d))\n\nvar ops = 0\ndef countUncached(input: List[Char], ds: List[Int], d: Int = 0): Long =\n  ops += 1\n  // ... same as before ...\n")),(0,i.kt)("p",null,"Running ",(0,i.kt)("inlineCode",{parentName:"p"},"countOps")," again, we now get the following output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"}," example:    21 (      169 calls,   32 ms)\npersonal:  7118 (    38382 calls,   74 ms)\n    slow: 65536 (      679 calls,    1 ms)\n")),(0,i.kt)("p",null,"That's much better! The number of operations is lower, and the running time is faster in the pathological ",(0,i.kt)("inlineCode",{parentName:"p"},"slow")," puzzle case."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The number of operations is a good primary metric here, because it is completely deterministic, stable across runs and is a good proxy for the complexity of the algorithm."),(0,i.kt)("p",{parentName:"admonition"},"We also measure the actual running time of the function as an indicator, but a naive measurement like this is not accurate and can vary a lot between runs. For a more accurate measurement, one could use a benchmarking library such as ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openjdk/jmh"},"JMH")," (for example with the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sbt/sbt-jmh"},"JMH SBT plugin"),") or ",(0,i.kt)("a",{parentName:"p",href:"https://scalameter.github.io/"},"ScalaMeter"),".")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Oh, there is a second part to this puzzle!"),(0,i.kt)("h3",{id:"implementation"},"Implementation"),(0,i.kt)("p",null,"The only change needed to implement the second part is to unfold the input rows before counting them. We add the ",(0,i.kt)("inlineCode",{parentName:"p"},"unfoldRow")," function to do that, and call it from ",(0,i.kt)("inlineCode",{parentName:"p"},"countAllUnfolded"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'/** Entry point for part 2 */\n@main def part2(): Unit =\n  println(countAllUnfolded(personalPuzzle))\n\ndef countAllUnfolded(input: String): Long =\n  input.split("\\n").map(unfoldRow).map(countRow).sum\n\ndef unfoldRow(input: String): String =\n  val Array(conditions, damagedCounts) =\n    input.split(" ")\n  val conditionsUnfolded =\n    (0 until 5).map(_ => conditions).mkString("?")\n  val damagedCountUnfolded =\n    (0 until 5).map(_ => damagedCounts).mkString(",")\n  f"$conditionsUnfolded $damagedCountUnfolded"\n')),(0,i.kt)("p",null,"Executing ",(0,i.kt)("inlineCode",{parentName:"p"},"part2")," with my personal input puzzle runs in ~800 ms on my machine, and ",(0,i.kt)("inlineCode",{parentName:"p"},"countUncached")," is called 681'185:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"          example:            21 (   169 calls,  31 ms)\n         personal:          7118 ( 38382 calls,  74 ms)\n             slow:         65536 (   679 calls,   1 ms)\npersonal unfolded: 7030194981795 (681185 calls, 815 ms)\n")),(0,i.kt)("p",null,"Can we do better?"),(0,i.kt)("h3",{id:"group-level-implementation-of-count"},"Group-level implementation of ",(0,i.kt)("inlineCode",{parentName:"h3"},"count")),(0,i.kt)("p",null,"Our first implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," works. Recursing character by character through the input string looks like a natural way to solve this problem. But we can simplify the implementation and improve its performance by considering groups instead of individual characters."),(0,i.kt)("p",null,"To know if a group of damaged springs of length ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," can be at a given position, we can consume the next ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," characters of the input and check if they can all be damaged springs (i.e. none of them is a ",(0,i.kt)("inlineCode",{parentName:"p"},"."),"), and if the following character can be an operational spring (i.e. it is not a ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable\n\nextension (b: Boolean) private inline def toLong: Long =\n  if b then 1L else 0L\n\nval cache2 = mutable.Map.empty[(List[Char], List[Int]), Long]\n\nprivate def count2(input: List[Char], ds: List[Int]): Long =\n  cache2.getOrElseUpdate((input, ds), count2Uncached(input, ds))\n\ndef count2Uncached(input: List[Char], ds: List[Int]): Long =\n  ops += 1\n  // We've  seen all expected damaged sequences. The arrangement\n  // is therefore valid only if the input does not contain\n  // damaged springs.\n  if ds.isEmpty then input.forall(_ != '#').toLong\n  // The input is empty but we expected some damaged springs,\n  // so this is not a valid arrangement.\n  else if input.isEmpty then 0L\n  else\n    def operationalCase(): Long =\n      // We can consume all following operational springs.\n      count2(input.tail.dropWhile(_ == '.'), ds)\n    def damagedCase(): Long =\n      // If the length of the input is less than the expected\n      // length of the damaged sequence, then this is not a\n      // valid arrangement.\n      if input.length < ds.head then 0L\n      else\n        // Split the input into a group of length ds.head and\n        // the rest.\n        val (group, rest) = input.splitAt(ds.head)\n        // If the group contains any operational springs, then\n        // this is not a a group of damaged springs, so this\n        // is not a valid arrangement.\n        if !group.forall(_ != '.') then 0L\n        // If the rest of the input is empty, then this is a\n        // valid arrangement only if the damaged sequence is\n        // the last one expected.\n        else if rest.isEmpty then ds.tail.isEmpty.toLong\n        // If we now have a damaged spring, then this is not\n        // the end of a damaged sequence as expected, and\n        // therefore not a valid arrangement.\n        else if rest.head == '#' then 0L\n        // Otherwise, we can continue with the rest of the\n        // input and the next expected damaged sequence.\n        else count2(rest.tail, ds.tail)\n    input.head match\n      case '?' => operationalCase() + damagedCase()\n      case '.' => operationalCase()\n      case '#' => damagedCase()\n")),(0,i.kt)("p",null,"I find this implementation simpler and easier to understand than the previous one. Do you agree?"),(0,i.kt)("p",null,"It naturally results in less calls, and the running time is improved:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"          example:            21 (    69 calls,   36 ms)\n         personal:          7118 ( 12356 calls,   74 ms)\n             slow:         65536 (   404 calls,    1 ms)\npersonal unfolded: 7030194981795 (235829 calls,  497 ms)\n")),(0,i.kt)("h3",{id:"local-cache"},"Local cache"),(0,i.kt)("p",null,"We implemented memoization by using a global mutable map. What happens if we use a local, distinct one for each call to ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," instead?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable\n\ndef count2(input: List[Char], ds: List[Int]): Long =\n  val cache2 = mutable.Map.empty[(List[Char], List[Int]), Long]\n\n  def count2Cached(input: List[Char], ds: List[Int]): Long =\n    cache2.getOrElseUpdate((input, ds), count2Uncached(input, ds))\n\n  def count2Uncached(input: List[Char], ds: List[Int]): Long =\n    // ... same as before ...\n    // (but calling count2Cached instead of count2)\n")),(0,i.kt)("p",null,"Even though this results to more calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"count2Uncached"),", this actually improves the performance of the unfolded version, down to ~400 ms on my machine:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"          example:            21 (       71 calls,   32 ms)\n         personal:          7118 (    18990 calls,   67 ms)\n             slow:         65536 (      425 calls,    3 ms)\npersonal unfolded: 7030194981795 (   260272 calls,  407 ms)\n")),(0,i.kt)("h3",{id:"simplify-cache-keys"},"Simplify cache keys"),(0,i.kt)("p",null,"Because we will always consider the same sublists of ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ds")," for the lifetime of the cache, we can just use the lengths of these lists as keys:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable\n\ndef count2(input: List[Char], ds: List[Int]): Long =\n  val cache2 = mutable.Map.empty[(Int, Int), Long]\n\n  def count2Cached(input: List[Char], ds: List[Int]): Long =\n    val key = (input.length, ds.length)\n    cache2.getOrElseUpdate(key, count2Uncached(input, ds))\n\n  // ... def count2Uncached as before\n")),(0,i.kt)("p",null,"Which further reduces the running time of the unfolded version to ~320 ms on my machine:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"          example:            21 (       71 calls,   33 ms)\n         personal:          7118 (    18990 calls,   66 ms)\n             slow:         65536 (      425 calls,    0 ms)\npersonal unfolded: 7030194981795 (   260272 calls,  320 ms)\n")),(0,i.kt)("h3",{id:"simplify-the-cache-structure"},"Simplify the cache structure"),(0,i.kt)("p",null,"Our cache key is now just a pair of integers, so we don't need a ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),"; an ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," can do the job just as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def count2(input: List[Char], ds: List[Int]): Long =\n  val dim1 = input.length + 1\n  val dim2 = ds.length + 1\n  val cache = Array.fill(dim1 * dim2)(-1L)\n\n  def count2Cached(input: List[Char], ds: List[Int]): Long =\n    val key = input.length * dim2 + ds.length\n    val result = cache(key)\n    if result == -1L then\n      val result = count2Uncached(input, ds)\n      cache(key) = result\n      result\n    else result\n\n  // ... def count2Uncached as before\n")),(0,i.kt)("p",null,"This reduces the running time of the unfolded version down to ~200 ms on my machine:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"          example:            21 (       71 calls,   27 ms)\n         personal:          7118 (    18990 calls,   47 ms)\n             slow:         65536 (      425 calls,    0 ms)\npersonal unfolded: 7030194981795 (   260272 calls,  201 ms)\n")),(0,i.kt)("h3",{id:"inline-helper-functions"},"Inline helper functions"),(0,i.kt)("p",null,"We have used helper functions to structure the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"count2"),". To avoid the calls overhead, we can use Scala 3's ",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/guides/macros/inline.html"},(0,i.kt)("inlineCode",{parentName:"a"},"inline")," keyword"),"."),(0,i.kt)("p",null,"After adding the ",(0,i.kt)("inlineCode",{parentName:"p"},"inline")," modifier to ",(0,i.kt)("inlineCode",{parentName:"p"},"count2Cached"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"operationalCase")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"damagedCase"),", the running time of the unfolded version is reduced to ~140 ms on my machine:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"          example:            21 (       71 calls,   28 ms)\n         personal:          7118 (    18990 calls,   50 ms)\n             slow:         65536 (      425 calls,    0 ms)\npersonal unfolded: 7030194981795 (   260272 calls,  137 ms)\n")),(0,i.kt)("h3",{id:"further-optimizations"},"Further optimizations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Using a different data structure for the input and the damaged sequence, for example an ",(0,i.kt)("inlineCode",{parentName:"li"},"IArray")," instead of a ",(0,i.kt)("inlineCode",{parentName:"li"},"List"),", and indexing into it instead of using ",(0,i.kt)("inlineCode",{parentName:"li"},"splitAt"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"tail")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"head")," methods would probably improve the performance further, but would be more verbose and less idiomatic."),(0,i.kt)("li",{parentName:"ul"},"Parallelizing ",(0,i.kt)("inlineCode",{parentName:"li"},"countAllUnfolded")," did not result in any performance improvement on my machine. It might on larger inputs.")),(0,i.kt)("p",null,"Can you think of other optimizations that could improve the performance of this code without sacrificing readability?"),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'/** Entry point for part 1. */\ndef part1(input: String): Unit =\n  println(countAll(input))\n\n/** Sums `countRow` over all rows in `input`. */\ndef countAll(input: String): Long =\n  input.split("\\n").map(countRow).sum\n\n/** Counts all of the different valid arrangements\n *  of operational and broken springs in the given row.\n */\ndef countRow(input: String): Long =\n  val Array(conditions, damagedCounts) = input.split(" ")\n  count2(\n    conditions.toList,\n    damagedCounts.split(",").map(_.toInt).toList\n  )\n\nextension (b: Boolean) private inline def toLong: Long =\n  if b then 1L else 0L\n\ndef count2(input: List[Char], ds: List[Int]): Long =\n  val dim1 = input.length + 1\n  val dim2 = ds.length + 1\n  val cache = Array.fill(dim1 * dim2)(-1L)\n\n  inline def count2Cached(input: List[Char], ds: List[Int]): Long =\n    val key = input.length * dim2 + ds.length\n    val result = cache(key)\n    if result == -1L then\n      val result = count2Uncached(input, ds)\n      cache(key) = result\n      result\n    else result\n\n  def count2Uncached(input: List[Char], ds: List[Int]): Long =\n    // We\'ve  seen all expected damaged sequences.\n    // The arrangement is therefore valid only if the\n    // input does not contain damaged springs.\n    if ds.isEmpty then input.forall(_ != \'#\').toLong\n    // The input is empty but we expected some damaged springs,\n    // so this is not a valid arrangement.\n    else if input.isEmpty then 0L\n    else\n      inline def operationalCase(): Long =\n        // Operational case: we can consume all operational\n        // springs to get to the next choice.\n        count2Cached(input.tail.dropWhile(_ == \'.\'), ds)\n      inline def damagedCase(): Long =\n        // If the length of the input is less than the expected\n        // length of the damaged sequence, then this is not a\n        // valid arrangement.\n        if input.length < ds.head then 0L\n        else\n          // Split the input into a group of length ds.head and\n          // the rest.\n          val (group, rest) = input.splitAt(ds.head)\n          // If the group contains any operational springs, then\n          // this is not a a group of damaged springs, so this\n          // is not a valid arrangement.\n          if !group.forall(_ != \'.\') then 0L\n          // If the rest of the input is empty, then this is a\n          // valid arrangement only if the damaged sequence\n          // is the last one expected.\n          else if rest.isEmpty then ds.tail.isEmpty.toLong\n          // If we now have a damaged spring, then this is not the\n          // end of a damaged sequence as expected, and therefore\n          // not a valid arrangement.\n          else if rest.head == \'#\' then 0L\n          // Otherwise, we can continue with the rest of the input\n          // and the next expected damaged sequence.\n          else count2Cached(rest.tail, ds.tail)\n      input.head match\n        case \'?\' => operationalCase() + damagedCase()\n        case \'.\' => operationalCase()\n        case \'#\' => damagedCase()\n\n  count2Cached(input, ds)\nend count2\n\n/** Entry point for part 2 */\ndef part2(input: String): Unit =\n  println(countAllUnfolded(input))\n\ndef countAllUnfolded(input: String): Long =\n  input.split("\\n").map(unfoldRow).map(countRow).sum\n\ndef unfoldRow(input: String): String =\n  val Array(conditions, damagedCounts) =\n    input.split(" ")\n  val conditionsUnfolded =\n    (0 until 5).map(_ => conditions).mkString("?")\n  val damagedCountUnfolded =\n    (0 until 5).map(_ => damagedCounts).mkString(",")\n  f"$conditionsUnfolded $damagedCountUnfolded"\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://git.dtth.ch/nki/aoc2023/src/branch/master/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/natsukagami/"},"@natsukagami")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/marconilanna/advent-of-code/blob/master/2023/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/marconilanna"},"Marconi Lanna")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/12.worksheet.sc#L154"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh/aoc-2023/blob/main/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh"},"Thanh Le")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2023/src/test/scala/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/master/task12/src/main/scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);