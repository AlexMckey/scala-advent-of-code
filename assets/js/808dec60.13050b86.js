"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9465],{940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));n(6340);const o={},r="Day 11: Cosmic Expansion",l={unversionedId:"2023/puzzles/day11",id:"2023/puzzles/day11",title:"Day 11: Cosmic Expansion",description:"by @natsukagami",source:"@site/target/mdoc/2023/puzzles/day11.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day11",permalink:"/scala-advent-of-code/2023/puzzles/day11",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day11.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 10: Pipe Maze",permalink:"/scala-advent-of-code/2023/puzzles/day10"},next:{title:"Day 12: Hot Springs",permalink:"/scala-advent-of-code/2023/puzzles/day12"}},s={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Puzzle Summary",id:"puzzle-summary",level:3},{value:"Solution Summary",id:"solution-summary",level:2},{value:"When calculating row distance, columns don&#39;t matter",id:"when-calculating-row-distance-columns-dont-matter",level:3},{value:"A cubic solution: calculate for each pair of rows!",id:"a-cubic-solution-calculate-for-each-pair-of-rows",level:3},{value:"Reduce to quadratic: Memoize the calculations with prefix sums!",id:"reduce-to-quadratic-memoize-the-calculations-with-prefix-sums",level:3},{value:"Approaching the linear summit: more prefix sums",id:"approaching-the-linear-summit-more-prefix-sums",level:3},{value:"Linear time with Recursions, or &quot;Sweep Line&quot;",id:"linear-time-with-recursions-or-sweep-line",level:3},{value:"Where to expand on the problem?",id:"where-to-expand-on-the-problem",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-11-cosmic-expansion"},"Day 11: Cosmic Expansion"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/natsukagami"},"@natsukagami")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/11"},"https://adventofcode.com/2023/day/11")),(0,i.kt)("h3",{id:"puzzle-summary"},"Puzzle Summary"),(0,i.kt)("p",null,"We are given a grid of ",(0,i.kt)("inlineCode",{parentName:"p"},".")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),". We would like to find the sum of distances between all ",(0,i.kt)("em",{parentName:"p"},"pairs")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," in the grid.\nThe distance between two ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," is defined as the number of vertical and horizontal steps to go from one to the other.\nOne caveat: each row and each column that has no ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," actually represents ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," empty rows/columns respectively."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In part 1, ",(0,i.kt)("inlineCode",{parentName:"li"},"k = 2"),"."),(0,i.kt)("li",{parentName:"ul"},"In part 2, ",(0,i.kt)("inlineCode",{parentName:"li"},"k = 1_000_000"),".")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/natsukagami"},"@natsukagami")),(0,i.kt)("p",null,"We start by parsing the input into a board structure (a ",(0,i.kt)("inlineCode",{parentName:"p"},"Seq[String]"),", with each string ",(0,i.kt)("em",{parentName:"p"},"representing a row"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val board = readInput().linesIterator.toSeq\n")),(0,i.kt)("p",null,"First, it is clear to us that the distance we are looking for is the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Taxicab_geometry"},"Manhattan Distance")," between\ntwo ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," in the grid.\nWe can simplify the distance formula by, given two coordinates of the ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"s, as"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Coord(row: Int, col: Int)\n\ndef distance(a: Coord, b: Coord) = (a.row - b.row).abs + (a.col - b.col).abs\n")),(0,i.kt)("p",null,"Note that the distance in the row and column coordinates are ",(0,i.kt)("em",{parentName:"p"},"independent"),", we can calculate them separately and add them back together at the end.\nFurthermore, since the calculation for rows and columns are ",(0,i.kt)("em",{parentName:"p"},"exactly the same"),", we can simply write code that deals with one coordinate and use\n",(0,i.kt)("inlineCode",{parentName:"p"},".transpose")," on the board to flip the row/column coordinates of all points, to calculate the other coordinate."),(0,i.kt)("p",null,"With this fact, from now on we can only talk about calculating the distances in the row coordinate!"),(0,i.kt)("h3",{id:"when-calculating-row-distance-columns-dont-matter"},"When calculating row distance, columns don't matter"),(0,i.kt)("p",null,"Let's look at the formula for the row distance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def rowDistance(a: Coord, b: Coord) = (a.row - b.row).abs\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"col")," is never mentioned! This means, we can simply treat all ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"s with the same ",(0,i.kt)("inlineCode",{parentName:"p"},"row")," coordinate ",(0,i.kt)("em",{parentName:"p"},"exactly the same"),"!\nIf we have ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," points with ",(0,i.kt)("inlineCode",{parentName:"p"},"row = x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," points with ",(0,i.kt)("inlineCode",{parentName:"p"},"row = y"),", the ",(0,i.kt)("em",{parentName:"p"},"total")," row distance of all these points can simply be\ncalculated as ",(0,i.kt)("inlineCode",{parentName:"p"},"n * m * (x - y).abs"),"."),(0,i.kt)("p",null,"Since it is no longer important to keep the board as-is, we can collapse it to just the ",(0,i.kt)("em",{parentName:"p"},"count")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"s for each row."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val countByRow = board\n    .map(row => row.count('#'))\n    .toArray // get O(1) indexing\n")),(0,i.kt)("h3",{id:"a-cubic-solution-calculate-for-each-pair-of-rows"},"A cubic solution: calculate for each pair of rows!"),(0,i.kt)("p",null,"Now, since the empty rows are expanded, we cannot use the old row distance formula ",(0,i.kt)("inlineCode",{parentName:"p"},"(a.row - b.row).abs"),".\nInstead, we have to ",(0,i.kt)("em",{parentName:"p"},"count")," the number of empty rows in between:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def rowDistance(xRow: Int, yRow: Int) =\n    // assuming xRow < yRow.\n    val distanceForOnePair = (xRow + 1 to yRow - 1)\n        .map(row =>\n            if countByRow(row) == 0\n            then k  /* expanded */\n            else 1L /* not expanded */\n        )\n        .sum\n   // the total distance is counted for every pair\n   distanceForOnePair * countByRow(xRow) * countByRow(yRow)\n")),(0,i.kt)("p",null,"We can simply go through every pair of rows to perform this calculation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val result = {\n    for i <- 0 until countByRow.length\n        j <- 0 until i\n    yield rowDistance(j, i)\n}.sum\n")),(0,i.kt)("p",null,"This has running time complexity ",(0,i.kt)("inlineCode",{parentName:"p"},"O(rows^3)"),", however it should suffice for the input in AoC (which gives you a grid of <150 rows and columns).\nHowever, we can do better! Read on to see how we optimize away the redundant calculations."),(0,i.kt)("h3",{id:"reduce-to-quadratic-memoize-the-calculations-with-prefix-sums"},"Reduce to quadratic: Memoize the calculations with prefix sums!"),(0,i.kt)("p",null,"Let's look at the formula for ",(0,i.kt)("inlineCode",{parentName:"p"},"distanceForOnePair")," again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val distanceForOnePair = (xRow + 1 to yRow - 1)\n    .map(row =>\n        if countByRow(row) == 0\n        then k  /* expanded */\n        else 1L /* not expanded */\n    )\n    .sum\n")),(0,i.kt)("p",null,"Note that the map function actually is a ",(0,i.kt)("em",{parentName:"p"},"pure")," function based on the row index, and therefore we can just pre-calculate it. Not yet a\nreduction in running time, but our code is clearer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"// outside of `rowDistance`...\nval expandedSize: Array[Long] = countByRow.map(if _ == 0 then k else 1L)\n// inside of `rowDistance`...\nval distanceForOnePair = (xRow + 1 to yRow - 1).map(expandedSize(_)).sum\n")),(0,i.kt)("p",null,"At this point we can leverage ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Prefix_sum"},"prefix sums")," to make getting a sum of a range of elements a constant operation..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"// outside of `rowDistance`...\nval expandedSize: Array[Long] =\n  countByRow.map(if _ == 0 then k else 1L)\n// expandedSizePrefix(i) = expandedSize(0) + ... + expandedSize(i-1)\nval expandedSizePrefix = expandedSize.scan(0L)(_ + _)\n\n// inside of `rowDistance`...\nval distanceForOnePair =\n  expandedSizePrefix(yRow) - expandedSizePrefix(xRow)\n")),(0,i.kt)("p",null,"And we have just lowered the running time of the solution to ",(0,i.kt)("inlineCode",{parentName:"p"},"O(rows^2)"),", by making ",(0,i.kt)("inlineCode",{parentName:"p"},"rowDistance")," constant-time!"),(0,i.kt)("p",null,"Here is the full code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def solve(input: String, expand: Int) =\n  val board = input.linesIterator.toSeq\n\n  val countByRow = board\n    .map(row => row.count(_ == '#'))\n    .toArray // get O(1) indexing\n  val countByCol = board.transpose // rotate the board!\n    .map(col => col.count(_ == '#'))\n    .toArray\n\n  allRowDistances(expand, countByRow)\n  + allRowDistances(expand, countByCol)\nend solve\n\ndef part1(input: String) = solve(input, expand = 2)\ndef part2(input: String) = solve(input, expand = 1_000_000)\n\ndef allRowDistances(k: Int, counts: Array[Int]): Long =\n  val expandedSize: Array[Long] = counts.map(v => if v == 0 then k else 1L)\n  // expandedSizePrefix(i) = expandedSize(0) + ... + expandedSize(i-1)\n  val expandedSizePrefix = expandedSize.scan(0L)(_ + _)\n  def rowDistance(xRow: Int, yRow: Int): Long =\n    val distanceForOnePair = expandedSizePrefix(yRow) - expandedSizePrefix(xRow)\n    distanceForOnePair * counts(xRow) * counts(yRow)\n\n  (for i <- 0 until counts.length\n    j <- 0 until i\n  yield rowDistance(j, i)).sum\n")),(0,i.kt)("p",null,"Now, this is enough for the puzzle, as reading the input itself is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(rows * col)"),". But ignoring that, can we do better? Hint: yes.\nLet's go on the optimization train."),(0,i.kt)("h3",{id:"approaching-the-linear-summit-more-prefix-sums"},"Approaching the linear summit: more prefix sums"),(0,i.kt)("p",null,"Going further requires us to inline the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"rowDistance"),".\nLet us apply some mathematical transformations and do some equational reasoning!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val result = {\n  for i <- 0 until counts.length\n    j <- 0 until i\n  yield\n    counts(i) * counts(j) * (expandedSizePrefix(i) - expandedSizePrefix(j))\n}.sum\n")),(0,i.kt)("p",null,"Let's regroup the ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop a bit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val result = {\n  for i <- 0 until counts.length\n  yield counts(i) * {\n    (for j <- 0 until i yield counts(j) * expandedSizePrefix(i) - counts(j) * expandedSizePrefix(j)).sum\n/* = */ expandedSizePrefix(i) * (for j <- 0 until i yield counts(j)).sum - (for j <- 0 until i yield counts(j) * expandedSizePrefix(j)).sum\n  }.sum\n}.sum\n")),(0,i.kt)("p",null,"We can see the ",(0,i.kt)("inlineCode",{parentName:"p"},"for j <- 0 until i")," pattern here, which means a prefix sum can be utilized again!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val countsSum = counts.scan(0L)(_ + _)\nval countsTimeExpandedSizePSum = counts\n  .lazyZip(expandedSizePrefix)\n  .map(_.toLong * _) // multiplied together\n  .scan(0L)(_ + _)   // create a prefix sum\n\n// and now we have\nval result = {\n  for i <- 0 until counts.length\n  yield counts(i) * {\n    expandedSizePrefix(i) * countsSum(i) - countsTimeExpandedSizePSum(i)\n  }\n}\n")),(0,i.kt)("p",null,"Voila, linear time complexity!"),(0,i.kt)("h3",{id:"linear-time-with-recursions-or-sweep-line"},'Linear time with Recursions, or "Sweep Line"'),(0,i.kt)("p",null,"Now, the previous approach requires some math and a lot of arrays. Can we do it in a more Scala-like way, with some (tail)\nrecursion? Enter ",(0,i.kt)("em",{parentName:"p"},"sweep line algorithm"),"."),(0,i.kt)("p",null,"Same idea as before: we calculate the row distance and column distance separately.\nLet us rewrite the row ",(0,i.kt)("em",{parentName:"p"},"distance")," from a point in row ",(0,i.kt)("inlineCode",{parentName:"p"},"j")," to reach the (end of the expanded) row ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," as a recursive formula:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def distance(j, i) =\n    if j == i              then 0                    // same row\n    else if counts(i) == 0 then distance(j, i-1) + k // i was expanded\n    else                        distance(j, i-1) + 1 // i was not expanded\n")),(0,i.kt)("p",null,"From a ",(0,i.kt)("em",{parentName:"p"},"single")," point in row ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", the distance to ",(0,i.kt)("em",{parentName:"p"},"all")," points in rows ",(0,i.kt)("em",{parentName:"p"},"before")," ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," would be"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def totalDistance(i) =\n    (for j <- 0 until i yield counts(j) * distance(j, i)).sum\n")),(0,i.kt)("p",null,"Let's write this in terms of recursion on ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),"!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def totalDistance(i) =\n    if i == 0 then 0\n    else\n        (for j <- 0 to i yield counts(j) * distance(j, i)).sum\n/* = */ (for j <- 0 to i-1 yield counts(j) * distance(j, i)).sum + counts(i) * distance(i, i) /* this part is always 0! */\n/* = */ (for j <- 0 to i-1\n         yield count(j) *\n            if j == i then 0 /* never happens */\n            else if counts(i) == 0 then distance(j, i-1) + k // i was expanded\n            else                        distance(j, i-1) + 1 // i was not expanded\n         ).sum\n/* = */ (for j <- 0 to i-1\n         yield count(j) * distance(j, i-1) + count(j) * {\n            if counts(i) == 0 then k // i was expanded\n            else                   1 // i was not expanded\n         }).sum\n/* = */ (for j <- 0 to i-1\n         yield count(j) * distance(j, i-1)\n         ).sum + // this is just totalDistance(i-1)!\n        (for j <- 0 to i-1\n         yield count(j) * {\n            // this is independent of j!\n            if counts(i) == 0 then k // i was expanded\n            else                   1 // i was not expanded\n         }).sum\n/* = */ totalDistance(i-1) + (for j <- 0 to i-1 yield count(j)).sum * (if counts(i) == 0 then k else 1)\n")),(0,i.kt)("p",null,"Which is ",(0,i.kt)("em",{parentName:"p"},"almost")," a fully linear recursive formula, except we also need to track the ",(0,i.kt)("strong",{parentName:"p"},"total number of points")," coming ",(0,i.kt)("em",{parentName:"p"},"before")," ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),"!\nThis is fine, we shall do it in our recursive function..."),(0,i.kt)("p",null,"To calculate the row distance, we ",(0,i.kt)("em",{parentName:"p"},"sweep")," through the points top-down.\nSimulating ",(0,i.kt)("inlineCode",{parentName:"p"},"totalDistance"),", we track ",(0,i.kt)("inlineCode",{parentName:"p"},"totalDistance(i)")," and the sum ",(0,i.kt)("inlineCode",{parentName:"p"},"counts(0) + ... + counts(i-1)")," as we go through the ",(0,i.kt)("inlineCode",{parentName:"p"},"counts")," sequence (now a list!)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"@scala.annotation.tailrec\ndef loop(\n    countsSum: Long, // counts(0) + ... + counts(i-1)\n    totalDistance: Long, // totalDistance(i-1)\n    accum: Long, // the accumulated answer\n)(\n    counts: List[Int], // our count-by-row list\n): Long = counts match\n    case Nil => accum // done!\n    case head :: tail => // head is counts(i), tail is counts(i+1 .. end)\n        val newCountsSum = countsSum + head // counts(0) + ... + counts(i)\n        val newTotalDist = totalDistance + countsSum * (if head == 0 then k else 1) // follow the formula!\n        val distanceToPointsHere = head * newTotalDist\n        loop(newCountsSum, newTotalDist, accum + distanceToPointsHere)(tail)\n")),(0,i.kt)("p",null,"... and this is the solution presented in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"our repo"),"!"),(0,i.kt)("h3",{id:"where-to-expand-on-the-problem"},"Where to expand on the problem?"),(0,i.kt)("p",null,"Here are some ideas that I think would be interesting to look into:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Bigger inputs: what if the space is an incredibly large grid, but the number of ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),"s are sparse (for example, about 100000 points in a 10^9-sized grid)?\nCan we leverage the same technique to achieve an efficient counting algorithm?"),(0,i.kt)("li",{parentName:"ul"},"Non-linear ",(0,i.kt)("em",{parentName:"li"},"k"),": What if instead of expanding empty rows/columns by a constant ",(0,i.kt)("em",{parentName:"li"},"k"),", we expand the topmost empty row by 1, the second empty row by 2 and so on...\nSame with columns. Can we still keep the counting linear?"),(0,i.kt)("li",{parentName:"ul"},"(Squared) Euclidean distance: what if our distance is the square of the ",(0,i.kt)("em",{parentName:"li"},"actual")," distance between the ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),"s (i.e. ",(0,i.kt)("inlineCode",{parentName:"li"},"(a.x - b.x)^2 + (a.y - b.y)^2"),")?\nWe ",(0,i.kt)("em",{parentName:"li"},"should")," be able to ",(0,i.kt)("em",{parentName:"li"},"still")," keep the counting algorithm linear with some math!")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/11.worksheet.sc#L138"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/advent-of-code/blob/main/2023/11/day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/"},"Raymond Dodge")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh/aoc-2023/blob/main/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh"},"Thanh Le")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2023/src/test/scala/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/solution_11/task11/src/main/scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);