"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[459],{8698:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return d},toc:function(){return p},default:function(){return c}});var a=n(7462),l=n(3366),o=(n(7294),n(3905)),r=["components"],s={},i="Day 5: Hydrothermal Venture",d={unversionedId:"puzzles/day5",id:"puzzles/day5",isDocsHomePage:!1,title:"Day 5: Hydrothermal Venture",description:"by @tgodzik",source:"@site/target/mdoc/puzzles/day5.md",sourceDirName:"puzzles",slug:"/puzzles/day5",permalink:"/scala-advent-of-code/puzzles/day5",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day5.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 4: Giant Squid",permalink:"/scala-advent-of-code/puzzles/day4"},next:{title:"Day 6: Lanternfish",permalink:"/scala-advent-of-code/puzzles/day6"}},p=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution of Part 1",id:"solution-of-part-1",children:[{value:"Parsing the file",id:"parsing-the-file",children:[],level:3},{value:"Hydrothermal Venture: The Orthogonal Pleasures.",id:"hydrothermal-venture-the-orthogonal-pleasures",children:[],level:3},{value:"Hydrothermal Venture 2: The Diagonal Menace",id:"hydrothermal-venture-2-the-diagonal-menace",children:[],level:3},{value:"Full solution",id:"full-solution",children:[],level:3}],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],u={toc:p};function c(e){var t=e.components,n=(0,l.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-5-hydrothermal-venture"},"Day 5: Hydrothermal Venture"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tgodzik"},"@tgodzik")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/5"},"https://adventofcode.com/2021/day/5")),(0,o.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,o.kt)("h3",{id:"parsing-the-file"},"Parsing the file"),(0,o.kt)("p",null,"The first step as usual is to model the problem and to parse the input file."),(0,o.kt)("p",null,"In this puzzle we are dealing with cartesian coordinates, so it would be good to\nadd a ",(0,o.kt)("inlineCode",{parentName:"p"},"Point")," class for convenience."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Point(x: Int, y: Int)\n")),(0,o.kt)("p",null,"Beside that we will also want to model a Vent which can have starting point and\nending one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Vent(start: Point, end: Point)\n")),(0,o.kt)("p",null,"Let's try to convert the input to our domain and let's start by reading it. I\nwill use an extension method on a string so that I can easily just write\n",(0,o.kt)("inlineCode",{parentName:"p"},'"input1".input')," to recive a list of Vents to analyse."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"extension (s: String)\n  def input: Seq[Vent] =\n    val uri = getClass().getClassLoader().getResource(s).toURI()\n    val path = Paths.get(uri)\n    for line <- Files.readAllLines(path).asScala.toSeq\n    yield Vent(line)\n")),(0,o.kt)("p",null,"As you can see above I actually decide to put the parsing of the lines into the\napply method of Vent, which we can implement as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'object Vent:\n  def apply(str: String) =\n    str.split("->") match\n      case Array(start, end) =>\n        new Vent(Point(start), Point(end))\n      case _ =>\n        throw new java.lang.IllegalArgumentException(s"Wrong vent input $str")\n')),(0,o.kt)("p",null,"In the above code we split the line into the part before ",(0,o.kt)("inlineCode",{parentName:"p"},"->")," and after it,\nwhich are the start and end of the vent. I delegate the parsing of positions\nfurther into the apply metohd of Position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'object Point:\n  def apply(str: String) =\n    str.split(",") match\n      case Array(start, end) => Point(start.trim.toInt, end.trim.toInt)\n      case _ =>\n        throw new java.lang.IllegalArgumentException(s"Wrong point input $str")\n')),(0,o.kt)("p",null,"With all the above code we now have a really nicely modeled input."),(0,o.kt)("h3",{id:"hydrothermal-venture-the-orthogonal-pleasures"},"Hydrothermal Venture: The Orthogonal Pleasures."),(0,o.kt)("p",null,"Let's use the input to find all the dangerous spots on the map in the first part\nof the puzzle. We can use a mutable map with default values for that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val map = mutable.Map[Point, Int]().withDefaultValue(0)\n")),(0,o.kt)("p",null,"This way we can easily update all the points that have a vent defined with as\nimple method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"  def update(p: Point) =\n    val current = map(p)\n    map.update(p, current + 1)\n")),(0,o.kt)("p",null,"Last thing to consider is how to actually add those points. For that we need to\ndefine proper ranges:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def rangex =\n  val stepx = if vent.end.x > vent.start.x then 1 else -1\n  vent.start.x.to(vent.end.x, stepx)\ndef rangey =\n  val stepy = if vent.end.y > vent.start.y then 1 else -1\n  vent.start.y.to(vent.end.y, stepy)\n")),(0,o.kt)("p",null,"We need to make sure that those range are increasing or decreasing based on the\nfact that the start might be located before the end."),(0,o.kt)("p",null,"With those ranges defined we can just iterate and add all the points:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// vent is horizontal\nif vent.start.x == vent.end.x then\n  for py <- rangey do update(Point(vent.start.x, py))\n// vent is vertical\nelse if vent.start.y == vent.end.y then\n  for px <- rangex do update(Point(px, vent.start.y))\n")),(0,o.kt)("p",null,"and add the end just count them all up:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"map.count { case (_, v) => v > 1 }\n")),(0,o.kt)("p",null,"Altogether the solution looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def findDangerousPoints(vents: Seq[Vent]) =\n  val map = mutable.Map[Point, Int]().withDefaultValue(0)\n  def update(p: Point) =\n    val current = map(p)\n    map.update(p, current + 1)\n\n  for vent <- vents do\n    def rangex =\n      val stepx = if vent.end.x > vent.start.x then 1 else -1\n      vent.start.x.to(vent.end.x, stepx)\n    def rangey =\n      val stepy = if vent.end.y > vent.start.y then 1 else -1\n      vent.start.y.to(vent.end.y, stepy)\n    // vent is horizontal\n    if vent.start.x == vent.end.x then\n      for py <- rangey do update(Point(vent.start.x, py))\n    // vent is vertical\n    else if vent.start.y == vent.end.y\n      for px <- rangex do update(Point(px, vent.start.y))\n  end for\n\n  map.count { case (_, v) => v > 1 }\nend findDangerousPoints\n")),(0,o.kt)("h3",{id:"hydrothermal-venture-2-the-diagonal-menace"},"Hydrothermal Venture 2: The Diagonal Menace"),(0,o.kt)("p",null,"For the second part of the puzzle we need to take into account also the diagonal\nvents. Fortunately, they can only have an angle of 45 degrees, which means that\nboth x and y positions increment by 1 at each step of the range. So we can add\nadditional condition to our solution:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"else for (px, py) <- rangex.zip(rangey) do update(Point(px, py))\n")),(0,o.kt)("p",null,"We can just use the 2 previously defined ranges for this. So the full method\nwill look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def findDangerousPoints(vents: Seq[Vent]) =\n  val map = mutable.Map[Point, Int]().withDefaultValue(0)\n  def update(p: Point) =\n    val current = map(p)\n    map.update(p, current + 1)\n\n  for vent <- vents do\n    def rangex =\n      val stepx = if vent.end.x > vent.start.x then 1 else -1\n      vent.start.x.to(vent.end.x, stepx)\n    def rangey =\n      val stepy = if vent.end.y > vent.start.y then 1 else -1\n      vent.start.y.to(vent.end.y, stepy)\n    // vent is horizontal\n    if vent.start.x == vent.end.x then\n      for py <- rangey do update(Point(vent.start.x, py))\n    // vent is vertical\n    else if vent.start.y == vent.end.y then\n      for px <- rangex do update(Point(px, vent.start.y))\n    // vent is diagonal\n    else for (px, py) <- rangex.zip(rangey) do update(Point(px, py))\n  end for\n\n  map.count { case (_, v) => v > 1 }\nend findDangerousPoints\n\n")),(0,o.kt)("h3",{id:"full-solution"},"Full solution"),(0,o.kt)("p",null,"Full solution can be found\n",(0,o.kt)("a",{parentName:"p",href:"https://gist.github.com/tgodzik/48b300f6719d0235f902e0d2c4853d64"},"here")," and can\nbe run using latest ",(0,o.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"> scala-cli https://gist.github.com/tgodzik/48b300f6719d0235f902e0d2c4853d64\n")),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page."))}c.isMDXComponent=!0}}]);