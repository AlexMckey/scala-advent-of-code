"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[546],{5249:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(7462),o=(a(7294),a(3905)),l=a(6340);const i={},r="Day 13: Transparent Origami",s={unversionedId:"puzzles/day13",id:"puzzles/day13",title:"Day 13: Transparent Origami",description:"by @adpi2",source:"@site/target/mdoc/puzzles/day13.md",sourceDirName:"puzzles",slug:"/puzzles/day13",permalink:"/scala-advent-of-code/puzzles/day13",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day13.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 12: Passage Pathing",permalink:"/scala-advent-of-code/puzzles/day12"},next:{title:"Day 14: Extended Polymerization",permalink:"/scala-advent-of-code/puzzles/day14"}},d={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Modeling the objects",id:"modeling-the-objects",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Folding",id:"folding",level:2},{value:"Solution of part 1",id:"solution-of-part-1",level:2},{value:"Solution of part 2",id:"solution-of-part-2",level:2},{value:"Run it locally",id:"run-it-locally",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function m(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-13-transparent-origami"},"Day 13: Transparent Origami"),(0,o.kt)("p",null,"by @adpi2"),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/13"},"https://adventofcode.com/2021/day/13")),(0,o.kt)("h2",{id:"modeling-the-objects"},"Modeling the objects"),(0,o.kt)("p",null,"The instructions of the manual are composed of dots and folds.\nWe can model those two objects in Scala 3 with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Dot(x: Int, y: Int)\n\nenum Fold:\n  case Vertical(x: Int)\n  case Horizontal(y: Int)\n")),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"Dot")," is made of two integers: ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),".\nA ",(0,o.kt)("inlineCode",{parentName:"p"},"Fold")," is either ",(0,o.kt)("inlineCode",{parentName:"p"},"Vertical")," if it has an ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," coordinate or ",(0,o.kt)("inlineCode",{parentName:"p"},"Horizontal")," if it has a ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," coordinate."),(0,o.kt)("h2",{id:"parsing"},"Parsing"),(0,o.kt)("p",null,"In order to parse dots and folds, we create two ",(0,o.kt)("inlineCode",{parentName:"p"},"parse")," functions in the companion objects of ",(0,o.kt)("inlineCode",{parentName:"p"},"Dot")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Fold"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'object Dot:\n  def parse(line: String): Dot =\n    line match\n      case s"$x,$y" => Dot(x.toInt, y.toInt)\n      case _ => throw new Exception(s"Cannot parse \'$line\' to Dot")\n\nobject Fold:\n  def parse(line: String): Fold =\n    line match\n      case s"fold along x=$x" => Vertical(x.toInt)\n      case s"fold along y=$y" => Horizontal(y.toInt)\n      case _ => throw new Exception(s"Cannot parse \'$line\' to Fold")\n')),(0,o.kt)("p",null,"Now, all the instructions can be parsed as follow:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def parseInstructions(input: String): (Set[Dot], List[Fold]) =\n  val sections = input.split("\\n\\n")\n  val dots = sections(0).linesIterator.map(Dot.parse).toSet\n  val folds = sections(1).linesIterator.map(Fold.parse).toList\n  (dots, folds)\n')),(0,o.kt)("p",null,"Notice that we return a set of ",(0,o.kt)("inlineCode",{parentName:"p"},"Dot")," and a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"Fold"),"."),(0,o.kt)("p",null,"A set is different from a list because it cannot contain the same element twice.\nIndeed, inserting an element in a set that already contains it does not alter the set.\nIt returns the same set in which the element is stored only once."),(0,o.kt)("p",null,"For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"$ Set(1, 2, 3, 3) == Set(1, 2, 3)\ntrue\n\n$ List(1, 2, 3, 3) == List(1, 2, 3)\nfalse\n")),(0,o.kt)("p",null,"It is convenient to choose a ",(0,o.kt)("inlineCode",{parentName:"p"},"Set")," to store the ",(0,o.kt)("inlineCode",{parentName:"p"},"Dot"),"s because it will merge all duplicates automatically.\nThis choice will make our program shorter and more efficient."),(0,o.kt)("h2",{id:"folding"},"Folding"),(0,o.kt)("p",null,"We want to compute the folds of all the dots.\nTo do so we can add a method ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," in the enum ",(0,o.kt)("inlineCode",{parentName:"p"},"Fold"),".\nIt takes an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Dot")," as parameter and returns the folded ",(0,o.kt)("inlineCode",{parentName:"p"},"Dot"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def apply(dot: Dot): Dot =\n  this match\n    case Vertical(x: Int) => Dot(fold(along = x)(dot.x), dot.y)\n    case Horizontal(y : Int) => Dot(dot.x, fold(along = y)(dot.y))\n")),(0,o.kt)("p",null,"In this method we call a function ",(0,o.kt)("inlineCode",{parentName:"p"},"fold")," that is not yet defined.\n",(0,o.kt)("inlineCode",{parentName:"p"},"fold")," is the mathematical formula that computes the folded value of an integer (",(0,o.kt)("inlineCode",{parentName:"p"},"value"),") around another integer (",(0,o.kt)("inlineCode",{parentName:"p"},"along"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def fold(along: Int)(value: Int): Int =\n  if value < along then value\n  else along - (value - along)\n")),(0,o.kt)("p",null,"We can check this formula with some examples:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Folding a dot at 2 along 7 does not move the dot because ",(0,o.kt)("inlineCode",{parentName:"li"},"2 < 7"),"."),(0,o.kt)("li",{parentName:"ul"},"Folding a dot at 9 along 7 (",(0,o.kt)("inlineCode",{parentName:"li"},"......|.#"),") moves the dot to ",(0,o.kt)("inlineCode",{parentName:"li"},"7 - 2 = 5")," (",(0,o.kt)("inlineCode",{parentName:"li"},"....#.|.."),").")),(0,o.kt)("h2",{id:"solution-of-part-1"},"Solution of part 1"),(0,o.kt)("p",null,"We are now ready to solve part 1:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val (dots, folds) = parseInstructions(input)\n  dots.map(folds.head.apply).size\n")),(0,o.kt)(l.Z,{puzzle:"day13-part1",year:"2021",mdxType:"Solver"}),(0,o.kt)("h2",{id:"solution-of-part-2"},"Solution of part 2"),(0,o.kt)("p",null,"To compute the solution of part 2 we apply all ",(0,o.kt)("inlineCode",{parentName:"p"},"folds")," sequentially, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft")," method."),(0,o.kt)("p",null,"To format the answer as if it was made of dots on a paper, we create a double array ",(0,o.kt)("inlineCode",{parentName:"p"},"Array[Array[Char]]")," of size ",(0,o.kt)("inlineCode",{parentName:"p"},"(height, width)")," initialized with ",(0,o.kt)("inlineCode",{parentName:"p"},"."),". Then we iterate over all dots to put a ",(0,o.kt)("inlineCode",{parentName:"p"},"#")," at their position in the double array.\nFinally we convert this double array to a ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," with ",(0,o.kt)("inlineCode",{parentName:"p"},".map(_.mkString).mkString('\\n')"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): String =\n  val (dots, folds) = parseInstructions(input)\n  val foldedDots = folds.foldLeft(dots)((dots, fold) => dots.map(fold.apply))\n\n  val (width, height) = (foldedDots.map(_.x).max + 1, foldedDots.map(_.y).max + 1)\n  val paper = Array.fill(height, width)('.')\n  for dot <- foldedDots do paper(dot.y)(dot.x) = '#'\n\n  paper.map(_.mkString).mkString(\"\\n\")\n")),(0,o.kt)(l.Z,{puzzle:"day13-part2",year:"2021",mdxType:"Solver"}),(0,o.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,o.kt)("p",null,"You can get this solution locally by cloning the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,o.kt)("p",null,"You can run it with ",(0,o.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ scala-cli 2021 -M day13.part1\nThe answer is: 788\n\n$ scala-cli 2021 -M day10.part2\nThe answer is:\n#..#...##.###..#..#.####.#..#.###...##.\n#.#.....#.#..#.#.#..#....#..#.#..#.#..#\n##......#.###..##...###..#..#.###..#...\n#.#.....#.#..#.#.#..#....#..#.#..#.#.##\n#.#..#..#.#..#.#.#..#....#..#.#..#.#..#\n#..#..##..###..#..#.####..##..###...###\n")),(0,o.kt)("p",null,"You can replace the content of the ",(0,o.kt)("inlineCode",{parentName:"p"},"input/day13")," file with your own input from\n",(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/13"},"adventofcode.com")," to get your own\nsolution."),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day13/Day13.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day13.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),".")),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page."))}m.isMDXComponent=!0}}]);