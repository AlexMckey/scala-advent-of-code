"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[511],{8773:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),l=n(5623),r=["components"],s={},p="Day 6: Lanternfish",u={unversionedId:"puzzles/day6",id:"puzzles/day6",isDocsHomePage:!1,title:"Day 6: Lanternfish",description:"by @julienrf",source:"@site/target/mdoc/puzzles/day6.md",sourceDirName:"puzzles",slug:"/puzzles/day6",permalink:"/scala-advent-of-code/puzzles/day6",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day6.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 5: Hydrothermal Venture",permalink:"/scala-advent-of-code/puzzles/day5"},next:{title:"Day 7: The Treachery of Whales",permalink:"/scala-advent-of-code/puzzles/day7"}},c=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution of Part 1",id:"solution-of-part-1",children:[{value:"Final code for Part 1",id:"final-code-for-part-1",children:[],level:3}],level:2},{value:"First attempt for Part 2",id:"first-attempt-for-part-2",children:[],level:2},{value:"Final code for part 2",id:"final-code-for-part-2",children:[],level:2},{value:"Run it locally",id:"run-it-locally",children:[],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],h={toc:c};function d(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-6-lanternfish"},"Day 6: Lanternfish"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/julienrf"},"@julienrf")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/6"},"https://adventofcode.com/2021/day/6")),(0,o.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,o.kt)("p",null,'For part 1, I implemented a "naive" solution by essentially translating the\nproblem statement into Scala.'),(0,o.kt)("p",null,"For instance, the problem statement contains:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can model each fish as a single number that represents the number of days\nuntil it creates a new lanternfish.")),(0,o.kt)("p",null,"So, my fish model is a case class with exactly one field containing\nthe number of days until that fish creates a new fish:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Fish(timer: Int)\n")),(0,o.kt)("p",null,"Then, we were asked to compute how a population of fish evolves after one\nday passes:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Each day, a 0 becomes a 6 and adds a new 8 to the end of the list, while each\nother number decreases by 1")),(0,o.kt)("p",null,"So, I wrote a method ",(0,o.kt)("inlineCode",{parentName:"p"},"tick"),", which takes as a parameter a population of fish,\nand returns the state of the population the next day:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def tick(population: Seq[Fish]): Seq[Fish] =\n  population.flatMap { fish =>\n    // "Each day, a `0` becomes a `6` and adds a new `8` to the end of the list"\n    if fish.timer == 0 then\n      Seq(Fish(6), Fish(8))\n    // "while each other number decreases by 1"\n    else\n      Seq(Fish(fish.timer - 1))\n  }\n')),(0,o.kt)("p",null,"We look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"timer")," value of every fish, and we apply the rule given in the\nproblem statement to compute how many fish (one or two) will result from that\nfish, the next day."),(0,o.kt)("p",null,"Finally, we were given an initial population of fish, and we had to compute the\nnumber of fish after 80 days. I wrote a method ",(0,o.kt)("inlineCode",{parentName:"p"},"simulate")," to achieve this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def simulate(days: Int, initialPopulation: Seq[Fish]): Int =\n  (1 to days)\n    .foldLeft(initialPopulation)((population, _) => tick(population))\n    .size\n")),(0,o.kt)("p",null,"First, we create a collection of iteration indices (",(0,o.kt)("inlineCode",{parentName:"p"},"1 to days"),"). Then, we\niterate over the indices by applying the method ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft"),". The iteration\nfunction discards the index value and calls the method ",(0,o.kt)("inlineCode",{parentName:"p"},"tick")," to compute the\nnext population based on the current population (starting with the\n",(0,o.kt)("inlineCode",{parentName:"p"},"initialPopulation"),", which is provided in the challenge)."),(0,o.kt)("h3",{id:"final-code-for-part-1"},"Final code for Part 1"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'// "Find a way to simulate lanternfish. How many lanternfish would there be after 80\n// days?"\ndef part1(input: String): Int =\n  simulate(\n    days = 80,\n    initialPopulation = Fish.parseSeveral(input)\n  )\n\n// "You can model each fish as a single number that represents the number of days\n// until it creates a new lanternfish."\ncase class Fish(timer: Int)\n\nobject Fish:\n  // "Suppose you were given the following list:\n  //\n  // 3,4,3,1,2\n  //\n  // This list means that the first fish has an internal timer of 3, the second fish\n  // has an internal timer of 4, and so on until the fifth fish, which has an\n  // internal timer of 2."\n  def parseSeveral(input: String): Seq[Fish] =\n    for timerString <- input.trim.split(",").toIndexedSeq\n    yield Fish(timerString.toInt.ensuring(_ >= 0))\n\n/**\n * Simulate the evolution of the population and return the number\n * of fishes at the end of the simulation.\n * @param days Number of days to simulate\n * @param initialPopulation Initial population\n */\ndef simulate(days: Int, initialPopulation: Seq[Fish]): Int =\n  (1 to days)\n    .foldLeft(initialPopulation)((population, _) => tick(population))\n    .size\n\n/**\n * Compute a new population after one day passes.\n * @param population Current population\n * @return New population\n */\ndef tick(population: Seq[Fish]): Seq[Fish] =\n  population.flatMap { fish =>\n    // "Each day, a `0` becomes a `6` and adds a new `8` to the end of the list"\n    if fish.timer == 0 then\n      Seq(Fish(6), Fish(8))\n    // "while each other number decreases by 1"\n    else\n      Seq(Fish(fish.timer - 1))\n  }\n')),(0,o.kt)(l.Z,{puzzle:"day6-part1",mdxType:"Solver"}),(0,o.kt)("h2",{id:"first-attempt-for-part-2"},"First attempt for Part 2"),(0,o.kt)("p",null,"The challenge for the part 2 does not seem complex at the first sight:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"How many lanternfish would there be after 256 days?")),(0,o.kt)("p",null,"Let\u2019s just run our simulation for 256 days instead of 80 days, and we are good!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int =\n  simulate(\n    days = 256,\n    initialPopulation = Fish.parseSeveral(input)\n  )\n")),(0,o.kt)("p",null,"Unfortunately, after running for a few minutes, it crashed with the\nfollowing error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'Exception in thread "main" java.lang.OutOfMemoryError: Java heap space\n        at scala.reflect.ManifestFactory$AnyManifest.newArray(Manifest.scala:328)\n        at scala.reflect.ManifestFactory$AnyManifest.newArray(Manifest.scala:327)\n        at scala.collection.IterableOnceOps.toArray(IterableOnce.scala:1278)\n        at scala.collection.IterableOnceOps.toArray$(IterableOnce.scala:1276)\n        at scala.collection.AbstractIterable.toArray(Iterable.scala:919)\n        at scala.collection.immutable.ArraySeq$.$anonfun$newBuilder$1(ArraySeq.scala:278)\n        at scala.collection.immutable.ArraySeq$$$Lambda$28/0x000000084010c040.apply(Unknown Source)\n        at scala.collection.mutable.Builder$$anon$1.result(Builder.scala:83)\n        at scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:119)\n        at scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:104)\n        at scala.collection.immutable.ArraySeq.flatMap(ArraySeq.scala:35)\n        at day6$package$.tick(day6.scala:39)\n        at day6$package$.simulate$$anonfun$1(day6.scala:29)\n        at day6$package$.simulate$$anonfun$adapted$1(day6.scala:29)\n')),(0,o.kt)("p",null,"Oops."),(0,o.kt)("p",null,"What happens is that there are too many fish, and computing the collection\nof timer values for every one of them eats all the memory of my computer!"),(0,o.kt)("p",null,"In such a situation, we need to come up with a different model. We need to\nfind a model that can compute the same result, but by using less information."),(0,o.kt)("p",null,"If we look at the computation, there are lots of redundant parts. For every\nfish whose timer value is initially the same, the sequence of computations\nwill also be the same to find out how many fish will be created by it and its\ndescendants, within 256 days."),(0,o.kt)("p",null,"So, instead of modeling the problem with a collection of fish, what we can do\nis to model it as a ",(0,o.kt)("inlineCode",{parentName:"p"},"Map")," that associates every possible timer value\n(between 0 and 8) to the number of fish with this timer value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val population: Map[Int, BigInt] = ???\n")),(0,o.kt)("p",null,"We associate every timer value (possible values are between ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"8"),",\nwhich we model with an ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),") to a number of fish with this timer value.\nSince our previous attempt caused a memory issue, I anticipated that the\nnumber of fish can grow very large, and may exceed the capacity of the type\n",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," (about 2 billions). We could use the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Long")," instead, which\nsupports even larger numbers, but I preferred to fix the issue once and for\nall by using the type ",(0,o.kt)("inlineCode",{parentName:"p"},"BigInt"),", which models numbers of arbitrary size."),(0,o.kt)("p",null,"Let\u2019s look at an example of population of fish with this model. In the\nproblem statement, the following population is used as an example. It is\ndescribed by the \u201ctimer\u201d value of every fish:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"3,4,3,1,2")),(0,o.kt)("p",null,"This population has 5 fish. Two of them have a timer value of ",(0,o.kt)("inlineCode",{parentName:"p"},"3"),", and the\nothers have timer values of ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"4"),", respectively. Here is how we\nmodel it with our ",(0,o.kt)("inlineCode",{parentName:"p"},"Map"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val population: Map[Int, BigInt] = Map(\n  1 -> 1,\n  2 -> 1,\n  3 -> 2,\n  4 -> 1\n)\n")),(0,o.kt)("p",null,'The input data is provided in the "comma-separated timer values"\nformat. How do we compute a ',(0,o.kt)("inlineCode",{parentName:"p"},"Map")," from that?"),(0,o.kt)("p",null,"What I did is to parse the timer values from the input data, and then\ncompute a ",(0,o.kt)("inlineCode",{parentName:"p"},"Map")," associating each timer value to its number of fish\n(basically, a map of occurrences) by using the method ",(0,o.kt)("inlineCode",{parentName:"p"},"groupMapReduce"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val initialPopulation: Map[Int, BigInt] =\n  input.split(",").groupMapReduce(_.toInt)(_ => BigInt(1))(_ + _)\n')),(0,o.kt)("p",null,"The first argument of ",(0,o.kt)("inlineCode",{parentName:"p"},"groupMapReduce"),' is the "partition function". It defines\nhow the fish should be grouped together. Here, they are grouped by using\ntheir timer value.'),(0,o.kt)("p",null,"The second argument defines how we want to model a fish, within each group.\nHere, we want to count them, so I used the constant value ",(0,o.kt)("inlineCode",{parentName:"p"},"BigInt(1)")," for\nevery fish."),(0,o.kt)("p",null,"Last, the third argument defines how to combine the fish within a group.\nHere, we just add the occurrences together."),(0,o.kt)("p",null,"Next, how do we compute the map of occurrences of the next day, given a current\nmap of occurrences? We create a new map of occurrences where we associate to\nthe timer value ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," the number of current occurrences for the timer value ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),",\nwe associate to the timer value ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," the number of current occurrences for\nthe timer value ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", and so on, to model time passing. However, there are\ntwo special cases due to the fact that every seven days a fish creates\nanother fish. The number of fish whose timer value is ",(0,o.kt)("inlineCode",{parentName:"p"},"6")," is the current\nnumber of fish whose timer value is ",(0,o.kt)("inlineCode",{parentName:"p"},"7")," ",(0,o.kt)("em",{parentName:"p"},"plus")," the number of fish whose\ntimer value is ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," (those fish created a new fish, and they will create\nanother fish in ",(0,o.kt)("inlineCode",{parentName:"p"},"6")," days). Also, the number of fish whose timer value is ",(0,o.kt)("inlineCode",{parentName:"p"},"8"),"\nis the number of fish that have been created during this turn, that is the\ncurrent number of fish whose timer value is ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),". This leaves us with the\nfollowing implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def tick(population: Map[Int, BigInt]): Map[Int, BigInt] =\n  def countPopulation(daysLeft: Int): BigInt = population.getOrElse(daysLeft, BigInt(0))\n  Map(\n    0 -> countPopulation(1),\n    1 -> countPopulation(2),\n    2 -> countPopulation(3),\n    3 -> countPopulation(4),\n    4 -> countPopulation(5),\n    5 -> countPopulation(6),\n    6 -> (countPopulation(7) + countPopulation(0)),\n    7 -> countPopulation(8),\n    8 -> countPopulation(0)\n  )\n")),(0,o.kt)("p",null,"The last missing piece to answer the challenge is to run the simulation for\na given number of days, and to compute the number of fish at the end of the\nsimulation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def simulate(days: Int, initialPopulation: Map[Int, BigInt]): BigInt =\n  (1 to days)\n    .foldLeft(initialPopulation)((population, _) => tick(population))\n    .values\n    .sum\n")),(0,o.kt)("p",null,"The method ",(0,o.kt)("inlineCode",{parentName:"p"},"simulate")," is very similar to the one I wrote for part 1. The\nonly difference is how it computes the number of fish from the model. It\nachieves this by summing the groups of fish: the method ",(0,o.kt)("inlineCode",{parentName:"p"},"values")," returns a\ncollection of groups of fish (each containing the number of fish in that\ngroup), finally the method ",(0,o.kt)("inlineCode",{parentName:"p"},"sum")," sums up the groups."),(0,o.kt)("h2",{id:"final-code-for-part-2"},"Final code for part 2"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'// "How many lanternfish would there be after 256 days?"\ndef part2(input: String): BigInt =\n  simulate(\n    days = 256,\n    Fish.parseSeveral(input).groupMapReduce(_.timer)(_ => BigInt(1))(_ + _)\n  )\n\ndef simulate(days: Int, initialPopulation: Map[Int, BigInt]): BigInt =\n  (1 to days)\n    .foldLeft(initialPopulation)((population, _) => tick(population))\n    .values\n    .sum\n\ndef tick(population: Map[Int, BigInt]): Map[Int, BigInt] =\n  def countPopulation(daysLeft: Int): BigInt = population.getOrElse(daysLeft, BigInt(0))\n  Map(\n    0 -> countPopulation(1),\n    1 -> countPopulation(2),\n    2 -> countPopulation(3),\n    3 -> countPopulation(4),\n    4 -> countPopulation(5),\n    5 -> countPopulation(6),\n    6 -> (countPopulation(7) + countPopulation(0)),\n    7 -> countPopulation(8),\n    8 -> countPopulation(0)\n  )\n')),(0,o.kt)(l.Z,{puzzle:"day6-part2",mdxType:"Solver"}),(0,o.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,o.kt)("p",null,"You can get this solution locally by cloning the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd advent-of-code\n")),(0,o.kt)("p",null,"You can run it with ",(0,o.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ scala-cli src -M day6.part1\nThe solution is 345793\n\n$ scala-cli src -M day6.part2\nThe solution is 1572643095893\n")),(0,o.kt)("p",null,"You can replace the content of the ",(0,o.kt)("inlineCode",{parentName:"p"},"input/day6")," file with your own input from ",(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/6"},"adventofcode.com")," to get your own solution."),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/tOverney/AdventOfCode2021/blob/main/src/main/scala/ch/overney/aoc/day6/"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/tOverney"},"@tOverney"),".")),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page."))}d.isMDXComponent=!0}}]);