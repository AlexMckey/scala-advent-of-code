"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4480],{7672:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var i=n(7462),o=(n(7294),n(3905)),a=n(6340);const s={},l="Day 23: Amphipod",p={unversionedId:"puzzles/day23",id:"puzzles/day23",title:"Day 23: Amphipod",description:"by @adpi2",source:"@site/target/mdoc/puzzles/day23.md",sourceDirName:"puzzles",slug:"/puzzles/day23",permalink:"/scala-advent-of-code/puzzles/day23",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day23.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 22: Reactor Reboot",permalink:"/scala-advent-of-code/puzzles/day22"},next:{title:"Day 24: Arithmetic Logic Unit",permalink:"/scala-advent-of-code/puzzles/day24"}},r={},d=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Modeling and parsing the input",id:"modeling-and-parsing-the-input",level:2},{value:"Using Dijkstra&#39;s algorithm to solve the puzzle",id:"using-dijkstras-algorithm-to-solve-the-puzzle",level:2},{value:"A graph of situations",id:"a-graph-of-situations",level:3},{value:"Implementing the Dijkstra&#39;s solver",id:"implementing-the-dijkstras-solver",level:3},{value:"Final solution",id:"final-solution",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Run it locally",id:"run-it-locally",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],u={toc:d};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-23-amphipod"},"Day 23: Amphipod"),(0,o.kt)("p",null,"by @adpi2"),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/23"},"https://adventofcode.com/2021/day/23")),(0,o.kt)("h2",{id:"modeling-and-parsing-the-input"},"Modeling and parsing the input"),(0,o.kt)("p",null,"We model ",(0,o.kt)("inlineCode",{parentName:"p"},"Position")," as a case class containing two integer fields: ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Room")," is a enumeration of 4 cases from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," and it is parameterized by the coordinate ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," of the room in the diagram."),(0,o.kt)("p",null,"Likewise, ",(0,o.kt)("inlineCode",{parentName:"p"},"Amphipod")," is an enumeration of 4 cases from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," and it is parameterized by its energy cost and destination room."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Position(x: Int, y: Int)\n\nenum Room(val x: Int):\n  case A extends Room(3)\n  case B extends Room(5)\n  case C extends Room(7)\n  case D extends Room(9)\n\ntype Energy = Int\n\nenum Amphipod(val energy: Energy, val destination: Room):\n  case A extends Amphipod(1, Room.A)\n  case B extends Amphipod(10, Room.B)\n  case C extends Amphipod(100, Room.C)\n  case D extends Amphipod(1000, Room.D)\n")),(0,o.kt)("p",null,"We model a situation as a case class of all the occupied positions and the size of the room (this will be needed for part 2)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Situation(positions: Map[Position, Amphipod], roomSize: Int)\n")),(0,o.kt)("p",null,"We can parse the input file into the initial ",(0,o.kt)("inlineCode",{parentName:"p"},"Situation")," with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object Situation:\n  def parse(input: String, roomSize: Int): Situation =\n    val positions =\n      for\n        (line, y) <- input.linesIterator.zipWithIndex\n        (char, x) <- line.zipWithIndex\n        amphipod <- Amphipod.tryParse(char)\n      yield Position(x, y) -> amphipod\n    Situation(positions.toMap, roomSize)\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"Amphipod.tryParse")," is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object Amphipod:\n  def tryParse(input: Char): Option[Amphipod] =\n    input match\n      case 'A' => Some(Amphipod.A)\n      case 'B' => Some(Amphipod.B)\n      case 'C' => Some(Amphipod.C)\n      case 'D' => Some(Amphipod.D)\n      case _ => None\n")),(0,o.kt)("h2",{id:"using-dijkstras-algorithm-to-solve-the-puzzle"},"Using Dijkstra's algorithm to solve the puzzle"),(0,o.kt)("p",null,"Dijkstra's algorithm is used for finding the shortest path between two nodes in a graph.\nOur intuition here is that the puzzle can be modeled as a graph and solved using Dijkstra's algorithm."),(0,o.kt)("h3",{id:"a-graph-of-situations"},"A graph of situations"),(0,o.kt)("p",null,"We can think of the puzzle as a graph of situations, where a node is an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Situation")," and an edge is an amphipod's move whose weight is the energy cost of the move."),(0,o.kt)("p",null,"In such a graph, two situations are connected if there is an amphipod move that transform the first situation into the second."),(0,o.kt)("h3",{id:"implementing-the-dijkstras-solver"},"Implementing the Dijkstra's solver"),(0,o.kt)("p",null,"We want to find the minimal energy cost to go from the initial situation to the final situation, where all amphipods are located in their destination room.\nThis is the energy cost of the shortest path between the two situations in the graph described above.\nWe can use Dijkstra's algorithm to find it."),(0,o.kt)("p",null,"Here is our implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"class DijkstraSolver(initialSituation: Situation):\n  private val bestSituations = mutable.Map(initialSituation -> 0)\n  private val situationsToExplore =\n    mutable.PriorityQueue((initialSituation, 0))(Ordering.by((_, energy) => -energy))\n\n  @tailrec\n  final def solve(): Energy =\n    val (situation, energy) = situationsToExplore.dequeue\n    if situation.isFinal then energy\n    else if bestSituations(situation) < energy then solve()\n    else\n      for\n        (nextSituation, consumedEnergy) <- situation.moveAllAmphipodsOnce\n        nextEnergy = energy + consumedEnergy\n        knownEnergy = bestSituations.getOrElse(nextSituation, Int.MaxValue)\n        if nextEnergy < knownEnergy\n      do\n        bestSituations.update(nextSituation, nextEnergy)\n        situationsToExplore.enqueue((nextSituation, nextEnergy))\n      solve()\n")),(0,o.kt)("p",null,"At the beginning we only know the cost of the initial situation which is 0."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"solve")," method is recursive:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"First we dequeue the best known situation in the ",(0,o.kt)("inlineCode",{parentName:"li"},"situationToExplore")," queue."),(0,o.kt)("li",{parentName:"ol"},"If it is the final situation, we return the associated energy cost."),(0,o.kt)("li",{parentName:"ol"},"If it is not:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We compute all the situations connected to it by moving all amphipods once."),(0,o.kt)("li",{parentName:"ul"},"For each of these new situations, we check if the energy cost is better than before and if so we add it into the queue."),(0,o.kt)("li",{parentName:"ul"},"We recurse by calling ",(0,o.kt)("inlineCode",{parentName:"li"},"solve")," again.")),(0,o.kt)("h2",{id:"final-solution"},"Final solution"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'// using scala 3.1.0\n\npackage day23\n\nimport scala.util.Using\nimport scala.io.Source\nimport scala.annotation.tailrec\nimport scala.collection.mutable\n\n\n@main def part1(): Unit =\n  val answer = part1(readInput())\n  println(s"The answer is: $answer")\n\n@main def part2(): Unit =\n  val answer = part2(readInput())\n  println(s"The answer is: $answer")\n\ndef readInput(): String =\n  Using.resource(Source.fromFile("input/day23"))(_.mkString)\n\ncase class Position(x: Int, y: Int)\n\nenum Room(val x: Int):\n  case A extends Room(3)\n  case B extends Room(5)\n  case C extends Room(7)\n  case D extends Room(9)\n\ntype Energy = Int\n\nenum Amphipod(val energy: Energy, val destination: Room):\n  case A extends Amphipod(1, Room.A)\n  case B extends Amphipod(10, Room.B)\n  case C extends Amphipod(100, Room.C)\n  case D extends Amphipod(1000, Room.D)\n\nobject Amphipod:\n  def tryParse(input: Char): Option[Amphipod] =\n    input match\n      case \'A\' => Some(Amphipod.A)\n      case \'B\' => Some(Amphipod.B)\n      case \'C\' => Some(Amphipod.C)\n      case \'D\' => Some(Amphipod.D)\n      case _ => None\n\nval hallwayStops: Seq[Position] = Seq(\n  Position(1, 1),\n  Position(2, 1),\n  Position(4, 1),\n  Position(6, 1),\n  Position(8, 1),\n  Position(10, 1),\n  Position(11, 1)\n)\n\ncase class Situation(positions: Map[Position, Amphipod], roomSize: Int):\n  def moveAllAmphipodsOnce: Seq[(Situation, Energy)] =\n    for\n      (start, amphipod) <- positions.toSeq\n      stop <- nextStops(amphipod, start)\n      path = getPath(start, stop)\n      if path.forall(isEmpty)\n    yield\n      val newPositions = positions - start + (stop -> amphipod)\n      val energy = path.size * amphipod.energy\n      (copy(positions = newPositions), energy)\n\n  def isFinal =\n    positions.forall((position, amphipod) => position.x == amphipod.destination.x)\n\n  /**\n   * Return a list of positions to which an amphipod at position `from` can go:\n   * - If the amphipod is in its destination room and the room is free it must not go anywhere.\n   * - If the amphipod is in its destination room and the room is not free it can go to the hallway.\n   * - If the amphipod is in the hallway it can only go to its destination.\n   * - Otherwise it can go to the hallway.\n   */\n  private def nextStops(amphipod: Amphipod, from: Position): Seq[Position] =\n    from match\n      case Position(x, y) if x == amphipod.destination.x =>\n        if isDestinationFree(amphipod) then Seq.empty\n        else hallwayStops\n      case Position(_, 1) =>\n        if isDestinationFree(amphipod) then\n          (roomSize + 1).to(2, step = -1)\n            .map(y => Position(amphipod.destination.x, y))\n            .find(isEmpty)\n            .toSeq\n        else Seq.empty\n      case _ => hallwayStops\n\n\n  private def isDestinationFree(amphipod: Amphipod): Boolean =\n    2.to(roomSize + 1)\n      .flatMap(y => positions.get(Position(amphipod.destination.x, y)))\n      .forall(_ == amphipod)\n\n  // Build the path to go from `start` to `stop`\n  private def getPath(start: Position, stop: Position): Seq[Position] =\n    val hallway =\n      if start.x < stop.x\n      then (start.x + 1).to(stop.x).map(Position(_, 1))\n      else (start.x - 1).to(stop.x, step = -1).map(Position(_, 1))\n    val startRoom = (start.y - 1).to(1, step = -1).map(Position(start.x, _))\n    val stopRoom = 2.to(stop.y).map(Position(stop.x, _))\n    startRoom ++ hallway ++ stopRoom\n\n  private def isEmpty(position: Position) =\n    !positions.contains(position)\n\nobject Situation:\n  def parse(input: String, roomSize: Int): Situation =\n    val positions =\n      for\n        (line, y) <- input.linesIterator.zipWithIndex\n        (char, x) <- line.zipWithIndex\n        amphipod <- Amphipod.tryParse(char)\n      yield Position(x, y) -> amphipod\n    Situation(positions.toMap, roomSize)\n\nclass DijkstraSolver(initialSituation: Situation):\n  private val bestSituations = mutable.Map(initialSituation -> 0)\n  private val situationsToExplore =\n    mutable.PriorityQueue((initialSituation, 0))(Ordering.by((_, energy) => -energy))\n\n  @tailrec\n  final def solve(): Energy =\n    val (situation, energy) = situationsToExplore.dequeue\n    if situation.isFinal then energy\n    else if bestSituations(situation) < energy then solve()\n    else\n      for\n        (nextSituation, consumedEnergy) <- situation.moveAllAmphipodsOnce\n        nextEnergy = energy + consumedEnergy\n        knownEnergy = bestSituations.getOrElse(nextSituation, Int.MaxValue)\n        if nextEnergy < knownEnergy\n      do\n        bestSituations.update(nextSituation, nextEnergy)\n        situationsToExplore.enqueue((nextSituation, nextEnergy))\n      solve()\n\ndef part1(input: String): Energy =\n  val initialSituation = Situation.parse(input, roomSize = 2)\n  DijkstraSolver(initialSituation).solve()\n\ndef part2(input: String): Energy =\n  val lines = input.linesIterator\n  val unfoldedInput = (lines.take(3) ++ Seq("  #D#C#B#A#", "  #D#B#A#C#") ++ lines.take(2)).mkString("\\n")\n  val initialSituation = Situation.parse(unfoldedInput, roomSize = 4)\n  DijkstraSolver(initialSituation).solve()\n')),(0,o.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,o.kt)("h3",{id:"part-1"},"Part 1"),(0,o.kt)(a.Z,{puzzle:"day23-part1",year:"2021",mdxType:"Solver"}),(0,o.kt)("h3",{id:"part-2"},"Part 2"),(0,o.kt)(a.Z,{puzzle:"day23-part2",year:"2021",mdxType:"Solver"}),(0,o.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,o.kt)("p",null,"You can get this solution locally by cloning the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,o.kt)("p",null,"You can run it with ",(0,o.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ scala-cli 2021 -M day21.part1\nThe answer is: 855624\n\n$ scala-cli 2021 -M day21.part2\nThe answer is: 187451244607486\n")),(0,o.kt)("p",null,"You can replace the content of the ",(0,o.kt)("inlineCode",{parentName:"p"},"input/day21")," file with your own input from ",(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/21"},"adventofcode.com")," to get your own solution."),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day23.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),".")),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}m.isMDXComponent=!0}}]);