"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6279],{5531:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>u});var a=n(7462),i=(n(7294),n(3905)),o=n(6340);const s={},l="Day 22: Reactor Reboot",r={unversionedId:"puzzles/day22",id:"puzzles/day22",title:"Day 22: Reactor Reboot",description:"by @bishabosha",source:"@site/target/mdoc/puzzles/day22.md",sourceDirName:"puzzles",slug:"/puzzles/day22",permalink:"/scala-advent-of-code/puzzles/day22",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day22.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 21: Dirac Dice",permalink:"/scala-advent-of-code/puzzles/day21"},next:{title:"Day 23: Amphipod",permalink:"/scala-advent-of-code/puzzles/day23"}},d={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Final Problem",id:"final-problem",level:2},{value:"Modelling The Domain",id:"modelling-the-domain",level:3},{value:"Basic Data Types",id:"basic-data-types",level:4},{value:"Syntax Sugar for Dimensions",id:"syntax-sugar-for-dimensions",level:4},{value:"Does a Dimension Fit in Some Boundary? (<code>isSubset</code>)",id:"does-a-dimension-fit-in-some-boundary-issubset",level:4},{value:"Does one Dimension <code>intersect</code> with Another?",id:"does-one-dimension-intersect-with-another",level:4},{value:"What <code>size</code> is a Dimension?",id:"what-size-is-a-dimension",level:4},{value:"Does one Cuboid <code>intersect</code> with Another?",id:"does-one-cuboid-intersect-with-another",level:4},{value:"What is the <code>volume</code> of a Cuboid?",id:"what-is-the-volume-of-a-cuboid",level:4},{value:"Solving the Problem",id:"solving-the-problem",level:3},{value:"Method Summary",id:"method-summary",level:4},{value:"Removing Cubes that are Turned Off",id:"removing-cubes-that-are-turned-off",level:4},{value:"Running the Steps",id:"running-the-steps",level:4},{value:"Calculate the Total Cubes Lit",id:"calculate-the-total-cubes-lit",level:4},{value:"Parsing The Input",id:"parsing-the-input",level:3},{value:"<code>Parser</code> Type",id:"parser-type",level:4},{value:"Parsing a <code>Command</code>",id:"parsing-a-command",level:4},{value:"Parsing a <code>Cuboid</code>",id:"parsing-a-cuboid",level:4},{value:"Parsing a <code>Step</code>",id:"parsing-a-step",level:4},{value:"Solution of Part 1",id:"solution-of-part-1",level:3},{value:"Solution of Part 2",id:"solution-of-part-2",level:3},{value:"Run it in the browser",id:"run-it-in-the-browser",level:2},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4},{value:"Run it locally",id:"run-it-locally",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],m={toc:u};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-22-reactor-reboot"},"Day 22: Reactor Reboot"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/bishabosha"},"@bishabosha")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/22"},"https://adventofcode.com/2021/day/22")),(0,i.kt)("h2",{id:"final-problem"},"Final Problem"),(0,i.kt)("h3",{id:"modelling-the-domain"},"Modelling The Domain"),(0,i.kt)("h4",{id:"basic-data-types"},"Basic Data Types"),(0,i.kt)("p",null,"We model the input as a series of steps, where each step has a\ncommand (either ",(0,i.kt)("inlineCode",{parentName:"p"},'"on"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"off"'),"), and\na cuboid area. Each cuboid is modelled by its dimensions\nin each of the x, y, and z dimensions.\nA dimension is modelled by two numbers - its start and end points,\ni.e. the minimum and maximum values on a single line in that\ndimension. Here are the data types modelling the above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Dimension(min: Int, max: Int):\n  require(min <= max)\n\ncase class Cuboid(xs: Dimension, ys: Dimension, zs: Dimension)\n\nenum Command:\n  case On, Off\n\ncase class Step(command: Command, cuboid: Cuboid)\n")),(0,i.kt)("h4",{id:"syntax-sugar-for-dimensions"},"Syntax Sugar for Dimensions"),(0,i.kt)("p",null,"To make construction of dimensions easier to read, we define an extension method so that we may write e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"n by m"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (x1: Int)\n  infix def by (x2: Int): Dimension = Dimension(x1, x2)\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"infix")," is a keyword in Scala that allows us to define a method\nthat can be called infix.")),(0,i.kt)("h4",{id:"does-a-dimension-fit-in-some-boundary-issubset"},"Does a Dimension Fit in Some Boundary? (",(0,i.kt)("inlineCode",{parentName:"h4"},"isSubset"),")"),(0,i.kt)("p",null,"We can test if some dimension fits within another\nby checking that their minimum and maximum values conform\nto each other. We can model this for ",(0,i.kt)("inlineCode",{parentName:"p"},"Dimension")," with a\nmember method ",(0,i.kt)("inlineCode",{parentName:"p"},"isSubset"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"...\n  def isSubset(d: Dimension): Boolean =\n    min >= d.min && max <= d.max\n")),(0,i.kt)("h4",{id:"does-one-dimension-intersect-with-another"},"Does one Dimension ",(0,i.kt)("inlineCode",{parentName:"h4"},"intersect")," with Another?"),(0,i.kt)("p",null,"Lets also add another method to ",(0,i.kt)("inlineCode",{parentName:"p"},"Dimension")," to get the\npart that intersects with another dimension, if it exists:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"...\n  infix def insersect(d: Dimension): Option[Dimension] =\n    Option.when(max >= d.min && min <= d.max) {\n      (min max d.min) by (max min d.max)\n    }\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You can think of intersecting dimensions as getting the part of\ntwo lines that overlap.")),(0,i.kt)("h4",{id:"what-size-is-a-dimension"},"What ",(0,i.kt)("inlineCode",{parentName:"h4"},"size")," is a Dimension?"),(0,i.kt)("p",null,"Lastly we add another method to ",(0,i.kt)("inlineCode",{parentName:"p"},"Dimension")," to get its size:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"...\n  def size: Int = max - min + 1\n")),(0,i.kt)("h4",{id:"does-one-cuboid-intersect-with-another"},"Does one Cuboid ",(0,i.kt)("inlineCode",{parentName:"h4"},"intersect")," with Another?"),(0,i.kt)("p",null,"Now that we know how to get the intersection of two\ndimensions, we can extend this to the intersection of two\ncuboids, by asserting that there is an intersection in\neach dimension. Here we add a method to ",(0,i.kt)("inlineCode",{parentName:"p"},"Cuboid"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"...\n  infix def intersect(curr: Cuboid): Option[Cuboid] =\n    for\n      xs <- this.xs insersect curr.xs\n      ys <- this.ys insersect curr.ys\n      zs <- this.zs insersect curr.zs\n    yield\n      Cuboid(xs, ys, zs)\n")),(0,i.kt)("h4",{id:"what-is-the-volume-of-a-cuboid"},"What is the ",(0,i.kt)("inlineCode",{parentName:"h4"},"volume")," of a Cuboid?"),(0,i.kt)("p",null,"With the ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," of each dimension determined, we can add a method\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"Cuboid")," to determine its ",(0,i.kt)("inlineCode",{parentName:"p"},"volume"),", it is computed as a\n",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," to avoid numeric overflow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def volume: BigInt = BigInt(1) * xs.size * ys.size * zs.size\n")),(0,i.kt)("h3",{id:"solving-the-problem"},"Solving the Problem"),(0,i.kt)("h4",{id:"method-summary"},"Method Summary"),(0,i.kt)("p",null,"The problem asks us to determine how many cubes are lit after\nall steps have been completed. We do this by modelling\nthe current lit cubes as a set of cuboids. Each step may\nadd or remove cuboids from this set. Aggregating cubes as cuboids\nmeans that we have the potential to save a lot of memory,\nas we only need 6 integer values to store all cubes within a\nspecific set of coordinates."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that with sufficient churn, i.e. steps that cause already\nlit areas to be turned off, many cuboids will be required, enough that\na more dense representation could be desirable to save memory.\nFor my input, < 3500 cuboids exist after the final step.")),(0,i.kt)("h4",{id:"removing-cubes-that-are-turned-off"},"Removing Cubes that are Turned Off"),(0,i.kt)("p",null,"The tricky part is when one step turns off some cubes that are\nalready lit, as this will leave a hole in at least one of cuboids\nin the set."),(0,i.kt)("p",null,"To simplify things, let's imagine that after the first\nstep, a square of cubes is in our set.\nThen in the next step, an area is turned off in the\nmiddle of that square.\nWe can update our set of lit cuboids by removing the square,\nand replacing it by four new cuboids, created by splitting\nthe square where it intersects with the hole. Here we\ncan see the set of lit cuboids for the first two steps:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513   \u250f\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2513\n  \u2503       \u2503   \u2503 \u2523\u2501\u2501\u2501\u252b \u2503\n1.\u2503       \u2503 2.\u2503 \u2503   \u2503 \u2503\n  \u2503       \u2503   \u2503 \u2523\u2501\u2501\u2501\u252b \u2503\n  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b   \u2517\u2501\u253b\u2501\u2501\u2501\u253b\u2501\u251b\n")),(0,i.kt)("p",null,"We provide a method ",(0,i.kt)("inlineCode",{parentName:"p"},"subdivide")," which follows the model described\nabove:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def subdivide(old: Cuboid, hole: Cuboid): Set[Cuboid] =\n  var on = Set.empty[Cuboid]\n  if old.xs.min != hole.xs.min then\n    on += Cuboid(xs = old.xs.min by hole.xs.min - 1, ys = old.ys, zs = old.zs)\n  if old.xs.max != hole.xs.max then\n    on += Cuboid(xs = hole.xs.max + 1 by old.xs.max, ys = old.ys, zs = old.zs)\n  if old.ys.min != hole.ys.min then\n    on += Cuboid(xs = hole.xs, ys = old.ys.min by hole.ys.min - 1, zs = old.zs)\n  if old.ys.max != hole.ys.max then\n    on += Cuboid(xs = hole.xs, ys = hole.ys.max + 1 by old.ys.max, zs = old.zs)\n  if old.zs.min != hole.zs.min then\n    on += Cuboid(xs = hole.xs, ys = hole.ys, zs = old.zs.min by hole.zs.min - 1)\n  if old.zs.max != hole.zs.max then\n    on += Cuboid(xs = hole.xs, ys = hole.ys, zs = hole.zs.max + 1 by old.zs.max)\n  on\n")),(0,i.kt)("h4",{id:"running-the-steps"},"Running the Steps"),(0,i.kt)("p",null,"We iterate through all the input steps once to accumulate\na set of cuboids, where each cuboid is a bounding box for\nlit cubes."),(0,i.kt)("p",null,"On each step, we create a new set of cuboids by subtracting the\nvolume of the current cuboid from any cuboids created in the\nprevious step (using our ",(0,i.kt)("inlineCode",{parentName:"p"},"subdivide")," method). We also include the\ncuboid of the current step if the command is ",(0,i.kt)("inlineCode",{parentName:"p"},'"on"'),".\nSee the code here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def run(steps: Iterator[Step]): Set[Cuboid] =\n\n  def subtract(cuboid: Cuboid)(on: Set[Cuboid], previouslyOn: Cuboid): Set[Cuboid] =\n    previouslyOn intersect cuboid match\n      case Some(hole) =>\n        on | subdivide(previouslyOn, hole)\n      case _ =>\n        on + previouslyOn\n\n  def turnOnCubes(on: Set[Cuboid], step: Step): Set[Cuboid] =\n    val Step(command, cuboid) = step\n    val newOn = if command == On then Set(cuboid) else Set.empty\n    on.foldLeft(newOn)(subtract(cuboid))\n\n  steps.foldLeft(Set.empty)(turnOnCubes)\n")),(0,i.kt)("h4",{id:"calculate-the-total-cubes-lit"},"Calculate the Total Cubes Lit"),(0,i.kt)("p",null,"To calculate the total number of cubes lit from the set of\ncuboids, we convert from a set to a sequence (to\nallow duplicates) then take the sum of cuboid volumes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def summary(on: Set[Cuboid]): BigInt =\n  on.toList.map(_.volume).sum\n")),(0,i.kt)("h3",{id:"parsing-the-input"},"Parsing The Input"),(0,i.kt)("p",null,"The input is made of a number of lines, typically like\nthe following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"on x=-29..15,y=-4..46,z=-21..23\n")),(0,i.kt)("p",null,"We parse each line into our ",(0,i.kt)("inlineCode",{parentName:"p"},"Step")," data type."),(0,i.kt)("h4",{id:"parser-type"},(0,i.kt)("inlineCode",{parentName:"h4"},"Parser")," Type"),(0,i.kt)("p",null,"First define a type ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser[A]")," which we will\nuse as a pattern match extractor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Parser[A] = PartialFunction[String, A]\n")),(0,i.kt)("h4",{id:"parsing-a-command"},"Parsing a ",(0,i.kt)("inlineCode",{parentName:"h4"},"Command")),(0,i.kt)("p",null,"To make a ",(0,i.kt)("inlineCode",{parentName:"p"},"Step")," we need both a ",(0,i.kt)("inlineCode",{parentName:"p"},"Command")," and a\na ",(0,i.kt)("inlineCode",{parentName:"p"},"Cuboid"),". We define a parser for ",(0,i.kt)("inlineCode",{parentName:"p"},"Command")," as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val CommandOf: Parser[Command] =\n  case "on" => On\n  case "off" => Off\n')),(0,i.kt)("h4",{id:"parsing-a-cuboid"},"Parsing a ",(0,i.kt)("inlineCode",{parentName:"h4"},"Cuboid")),(0,i.kt)("p",null,"We parse a ",(0,i.kt)("inlineCode",{parentName:"p"},"Cuboid")," from three ",(0,i.kt)("inlineCode",{parentName:"p"},"Dimension"),", which we\nparse as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val CuboidOf: Parser[Cuboid] =\n  case s"x=${DimensionOf(xs)},y=${DimensionOf(ys)},z=${DimensionOf(zs)}" => Cuboid(xs, ys, zs)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val DimensionOf: Parser[Dimension] =\n  case s"${NumOf(begin)}..${NumOf(end)}" => begin by end\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val NumOf: Parser[Int] =\n  case s if s.matches(raw"-?\\d+") => s.toInt\n')),(0,i.kt)("h4",{id:"parsing-a-step"},"Parsing a ",(0,i.kt)("inlineCode",{parentName:"h4"},"Step")),(0,i.kt)("p",null,"Finally we can parse a single ",(0,i.kt)("inlineCode",{parentName:"p"},"Step"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val StepOf: Parser[Step] =\n  case s"${CommandOf(command)} ${CuboidOf(cuboid)}" => Step(command, cuboid)\n')),(0,i.kt)("p",null,"To parse all lines, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"linesIterator"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val steps = input.linesIterator.map(StepOf)\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that the above call to ",(0,i.kt)("inlineCode",{parentName:"p"},".map")," will call\n",(0,i.kt)("inlineCode",{parentName:"p"},"StepOf.apply")," for each line, this may throw a\n",(0,i.kt)("inlineCode",{parentName:"p"},"MatchError")," if the line is formatted incorrectly.")),(0,i.kt)("h3",{id:"solution-of-part-1"},"Solution of Part 1"),(0,i.kt)("p",null,"For part one, we only run the steps that are in the\ninitialisation sequence, i.e. running all the first\nsteps while they fit within the\narea ",(0,i.kt)("inlineCode",{parentName:"p"},"x=-50..50,y=-50..50,z=-50..50"),"."),(0,i.kt)("p",null,"We check that a cuboid is in the initialisation\nsequence with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def isInit(cuboid: Cuboid): Boolean =\n  Seq(cuboid.xs, cuboid.ys, cuboid.zs).forall(_.isSubset(-50 by 50))\n")),(0,i.kt)("p",null,"The final code for part 1 is then to run the steps\nonly while they fit the initialisation sequence, and then\nsummarise the set of cuboids:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): BigInt =\n  val steps = input.linesIterator.map(StepOf)\n  summary(run(steps.takeWhile(s => isInit(s.cuboid))))\n")),(0,i.kt)("h3",{id:"solution-of-part-2"},"Solution of Part 2"),(0,i.kt)("p",null,"Part 2 is identical to part 1, except that we run all\nsteps, not just the initialisation sequence:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): BigInt =\n  summary(run(input.linesIterator.map(StepOf)))\n")),(0,i.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1"},"Part 1"),(0,i.kt)(o.Z,{puzzle:"day22-part1",year:"2021",mdxType:"Solver"}),(0,i.kt)("h4",{id:"part-2"},"Part 2"),(0,i.kt)(o.Z,{puzzle:"day22-part2",year:"2021",mdxType:"Solver"}),(0,i.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,i.kt)("p",null,"You can get this solution locally by cloning the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,i.kt)("p",null,"You can run it with ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ scala-cli 2021 -M day22.part1\nThe answer is: 647062\n\n$ scala-cli 2021 -M day22.part2\nThe answer is: 1319618626668022\n")),(0,i.kt)("p",null,"You can replace the content of the ",(0,i.kt)("inlineCode",{parentName:"p"},"input/day22")," file with your own input from ",(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/22"},"adventofcode.com")," to get your own solution."),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day22.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2021/tree/master/src/main/scala/rui/aoc/year2021/day22"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page."))}p.isMDXComponent=!0}}]);