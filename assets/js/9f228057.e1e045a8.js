"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9468],{4852:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));n(6340);const o={},l="Day 12: Hill Climbing Algorithm",s={unversionedId:"2022/puzzles/day12",id:"2022/puzzles/day12",title:"Day 12: Hill Climbing Algorithm",description:"Puzzle description",source:"@site/target/mdoc/2022/puzzles/day12.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day12",permalink:"/scala-advent-of-code/2022/puzzles/day12",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day12.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 11: Monkey in the Middle",permalink:"/scala-advent-of-code/2022/puzzles/day11"},next:{title:"Day 13: Distress Signal",permalink:"/scala-advent-of-code/2022/puzzles/day13"}},r={},d=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],u={toc:d};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-12-hill-climbing-algorithm"},"Day 12: Hill Climbing Algorithm"),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/12"},"https://adventofcode.com/2022/day/12")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"Today's challenge is to simulate the breadth-first search over a graph. First, let's create a standard Point class and define addition on it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Point(x: Int, y: Int):\n  def move(dx: Int, dy: Int): \n    Point = Point(x + dx, y + dy)\n  override def toString: String =\n    s"($x, $y)"\nend Point\n')),(0,i.kt)("p",null,"Now we need a representation that will serve as a substitute for moves:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val up    = (0, 1)\nval down  = (0, -1)\nval left  = (-1, 0)\nval right = (1, 0)\nval possibleMoves = List(up, down, left, right)\n")),(0,i.kt)("p",null,"Let's make a path function that will help us to calculate the length of our path to the point, based on our moves, that we defined before:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def path(point: Point, net: Map[Point, Char]): Seq[Point] = \n  possibleMoves.map(point.move).filter(net.contains)\n")),(0,i.kt)("p",null,"A function that fulfills our need to match an entry with the point we are searching for:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def matching(point: Point, net: Map[Point, Char]): Char = \n  net(point) match\n    case 'S' => 'a'\n    case 'E' => 'z'\n    case other => other\n")),(0,i.kt)("p",null,"Now we just need to put the program together. First of all, let's map out our indices to the source, so we can create a queue for path representation. After that we need to create a map, to keep track the length of our path. For that we will need to map ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," entry to zero. The last part is the implementation of bfs on a ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def solution(source: IndexedSeq[String], srchChar: Char): Int =\n  // create a sequence of Point objects and their corresponding character in source\n  val points =\n    for\n      y <- source.indices\n      x <- source.head.indices\n    yield\n      Point(x, y) -> source(y)(x)\n  val p = points.toMap\n  val initial = p.map(_.swap)('E')\n  val queue = collection.mutable.Queue(initial)\n  val length = collection.mutable.Map(initial -> 0)\n  //bfs\n  while queue.nonEmpty do\n    val visited = queue.dequeue()\n    if p(visited) == srchChar then\n      return length(visited)\n    for visited1 <- path(visited, p) do\n      val shouldAdd =\n        !length.contains(visited1)\n        && matching(visited, p) - matching(visited1, p) <= 1\n      if shouldAdd then\n        queue.enqueue(visited1)\n        length(visited1) = length(visited) + 1\n    end for\n  end while\n  throw IllegalStateException(\"unexpected end of search area\")\nend solution\n")),(0,i.kt)("p",null,"In part one srchChar is 'S', but since our method in non-exhaustive, we may apply the same function for 'a'"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(data: String): Int = \n  solution(IndexedSeq.from(data.linesIterator), 'S')\ndef part2(data: String): Int = \n  solution(IndexedSeq.from(data.linesIterator), 'a')\n")),(0,i.kt)("p",null,"And that's it!"),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}p.isMDXComponent=!0}}]);