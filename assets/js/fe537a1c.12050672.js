"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[91],{4414:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return u},default:function(){return h}});var a=t(7462),l=t(3366),i=(t(7294),t(3905)),r=t(5623),s=["components"],o={},p="Day 21: Dirac Dice",c={unversionedId:"puzzles/day21",id:"puzzles/day21",isDocsHomePage:!1,title:"Day 21: Dirac Dice",description:"by @sjrd",source:"@site/target/mdoc/puzzles/day21.md",sourceDirName:"puzzles",slug:"/puzzles/day21",permalink:"/scala-advent-of-code/puzzles/day21",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day21.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 20: Trench Map",permalink:"/scala-advent-of-code/puzzles/day20"},next:{title:"Day 22: Reactor Reboot",permalink:"/scala-advent-of-code/puzzles/day22"}},u=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Modeling and parsing the input",id:"modeling-and-parsing-the-input",children:[],level:2},{value:"The deterministic die",id:"the-deterministic-die",children:[],level:2},{value:"Playing with the deterministic die",id:"playing-with-the-deterministic-die",children:[],level:2},{value:"Solution for part 1",id:"solution-for-part-1",children:[],level:2},{value:"The Dirac die",id:"the-dirac-die",children:[],level:2},{value:"Naive solution (non-practical)",id:"naive-solution-non-practical",children:[],level:2},{value:"Simulating several universes at once",id:"simulating-several-universes-at-once",children:[],level:2},{value:"Solution for part 2",id:"solution-for-part-2",children:[],level:2},{value:"Run it locally",id:"run-it-locally",children:[],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],d={toc:u};function h(e){var n=e.components,t=(0,l.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-21-dirac-dice"},"Day 21: Dirac Dice"),(0,i.kt)("p",null,"by @sjrd"),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/21"},"https://adventofcode.com/2021/day/21")),(0,i.kt)("h2",{id:"modeling-and-parsing-the-input"},"Modeling and parsing the input"),(0,i.kt)("p",null,"As we did for previous solutions, we start by modeling the problem and parsing the input."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'type Cell = Int // from 0 to 9, to simplify computations\n\ncase class Player(cell: Cell, score: Long)\n\ntype Players = (Player, Player)\n\ndef parseInput(input: String): Players =\n  val lines = input.split("\\n")\n  (parsePlayer(lines(0)), parsePlayer(lines(1)))\n\ndef parsePlayer(line: String): Player =\n  line match\n    case s"Player $num starting position: $cell" =>\n      Player(cell.toInt - 1, 0L)\n')),(0,i.kt)("p",null,'The only thing worth noting is that we use numbers 0 to 9 for the cells (the "spaces") instead of 1 to 10.\nThe only reason is that it simplifies computations for wrapping around.'),(0,i.kt)("h2",{id:"the-deterministic-die"},"The deterministic die"),(0,i.kt)("p",null,"For the first part, with the deterministic die, we have to return the score of the losing player, while keeping tabs on how many times the die was rolled.\nWe model the deterministic die as an instance of a class ",(0,i.kt)("inlineCode",{parentName:"p"},"DeterministicDie"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final class DeterministicDie {\n  var throwCount: Int = 0\n  private var lastValue: Int = 100\n\n  def nextResult(): Int =\n    throwCount += 1\n    lastValue = (lastValue % 100) + 1\n    lastValue\n}\n")),(0,i.kt)("p",null,"An instance of that class keeps track of what its last roll was, and of how many times it was thrown."),(0,i.kt)("h2",{id:"playing-with-the-deterministic-die"},"Playing with the deterministic die"),(0,i.kt)("p",null,"We use the deterministic die in a tail-recursive function ",(0,i.kt)("inlineCode",{parentName:"p"},"playWithDeterministicDie")," to play out a full game:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"@tailrec\ndef playWithDeterministicDie(players: Players, die: DeterministicDie): Long =\n  val diesValue = die.nextResult() + die.nextResult() + die.nextResult()\n  val player = players(0)\n  val newCell = (player.cell + diesValue) % 10\n  val newScore = player.score + (newCell + 1)\n  if newScore >= 1000 then\n    players(1).score\n  else\n    val newPlayer = Player(newCell, newScore)\n    playWithDeterministicDie((players(1), newPlayer), die)\n")),(0,i.kt)("p",null,"In that function, it is always ",(0,i.kt)("inlineCode",{parentName:"p"},"players(0)"),"'s turn.\nIn the tail-recursive call, we swap out the two players, so that the next player to play always comes first."),(0,i.kt)("p",null,"Other than that, the function is a direct translation from the rules of the game in the puzzle description:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Throw the die 3 times, and add up the values"),(0,i.kt)("li",{parentName:"ol"},"Advance the player, wrapping around every 10 cells"),(0,i.kt)("li",{parentName:"ol"},"Compute the new score"),(0,i.kt)("li",{parentName:"ol"},"Detect the winning condition and return the loser's score, or continue with the next player")),(0,i.kt)("p",null,"If you are not familiar with modular arithmetics, it may not be obvious that the computation ",(0,i.kt)("inlineCode",{parentName:"p"},"(player.cell + diesValue) % 10")," is correct.\nAnother computation, which is perhaps more straightforward, would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val diesValueMod10 = diesValue % 10\nval newCell = (player.cell + diesValueMod10) % 10\n")),(0,i.kt)("p",null,"Indeed, for every group of 10 in ",(0,i.kt)("inlineCode",{parentName:"p"},"diesValue"),", the player will actually not move, so it moves only by ",(0,i.kt)("inlineCode",{parentName:"p"},"diesValue % 10"),".\nThe other ",(0,i.kt)("inlineCode",{parentName:"p"},"% 10")," wraps around the circular board."),(0,i.kt)("p",null,"Modular arithmetics tell us that ",(0,i.kt)("inlineCode",{parentName:"p"},"(player.cell + (diesValue % 10)) % 10")," is in fact equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"(player.cell + diesValue) % 10"),"."),(0,i.kt)("h2",{id:"solution-for-part-1"},"Solution for part 1"),(0,i.kt)("p",null,"This concludes part 1, whose entire code is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'type Cell = Int // from 0 to 9, to simplify computations\n\ncase class Player(cell: Cell, score: Long)\n\ntype Players = (Player, Player)\n\nfinal class DeterministicDie {\n  var throwCount: Int = 0\n  private var lastValue: Int = 100\n\n  def nextResult(): Int =\n    throwCount += 1\n    lastValue = (lastValue % 100) + 1\n    lastValue\n}\n\ndef part1(input: String): Long =\n  val players = parseInput(input)\n  val die = new DeterministicDie\n  val loserScore = playWithDeterministicDie(players, die)\n  loserScore * die.throwCount\n\ndef parseInput(input: String): Players =\n  val lines = input.split("\\n")\n  (parsePlayer(lines(0)), parsePlayer(lines(1)))\n\ndef parsePlayer(line: String): Player =\n  line match\n    case s"Player $num starting position: $cell" =>\n      Player(cell.toInt - 1, 0L)\n\n@tailrec\ndef playWithDeterministicDie(players: Players, die: DeterministicDie): Long =\n  val diesValue = die.nextResult() + die.nextResult() + die.nextResult()\n  val player = players(0)\n  val newCell = (player.cell + diesValue) % 10\n  val newScore = player.score + (newCell + 1)\n  if newScore >= 1000 then\n    players(1).score\n  else\n    val newPlayer = Player(newCell, newScore)\n    playWithDeterministicDie((players(1), newPlayer), die)\n')),(0,i.kt)(r.Z,{puzzle:"day21-part1",mdxType:"Solver"}),(0,i.kt)("h2",{id:"the-dirac-die"},"The Dirac die"),(0,i.kt)("p",null,"For part 2, our previous model falls short.\nWe now have to simulate a large number of universes."),(0,i.kt)("p",null,"The good thing is that our die is not stateful anymore, and we do not need to keep track of how many times it is thrown, so we do not use an instance for it at all."),(0,i.kt)("p",null,"However, we will have to count how many times each player wins, which I chose to keep track using mutable state again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final class Wins(var player1Wins: Long, var player2Wins: Long)\n\ndef part2(input: String): Long =\n  val players = parseInput(input)\n  val wins = new Wins(0L, 0L)\n  // ... Simulate universes here\n  Math.max(wins.player1Wins, wins.player2Wins)\n")),(0,i.kt)("h2",{id:"naive-solution-non-practical"},"Naive solution (non-practical)"),(0,i.kt)("p",null,"A first attempt would be to use a (non-tail) recursive function that branches out for every possible outcome of the three dice.\nThat would look like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def playWithDiracDie(players: Players, player1Turn: Boolean, wins: Wins): Unit =\n  for\n    die1 <- List(1, 2, 3)\n    die2 <- List(1, 2, 3)\n    die3 <- List(1, 2, 3)\n  do\n    val diesValue = die1 + die2 + die3\n    val player = players(0)\n    val newCell = (player.cell + diesValue) % 10\n    val newScore = player.score + (newCell + 1)\n    if newScore >= 21 then\n      if player1Turn then\n        wins.player1Wins += 1L\n      else\n        wins.player2Wins += 1L\n    else\n      val newPlayer = Player(newCell, newScore)\n      playWithDiracDie((players(1), newPlayer), !player1Turn, wins)\n  end for\n")),(0,i.kt)("p",null,"For every possible outcome, we compute the new cell and score.\nIf the game is over, we add 1 to the number of times that the current player wins.\nOtherwise, we recurse for the next roll."),(0,i.kt)("p",null,"The problem is that the branching factor is 27, which is too high to run in a reasonable time."),(0,i.kt)("h2",{id:"simulating-several-universes-at-once"},"Simulating several universes at once"),(0,i.kt)("p",null,"Fortunately, we can dramatically reduce the number of branches that we need with one observation.\nThere are only 7 ",(0,i.kt)("em",{parentName:"p"},"different")," outcomes to the roll of three dice, with most of them occurring several times.\nThe rest of the game is not affected by anything but the sum, although it will happen in several universes, which we need to count.\nWe can implement that by remembering in how many universes the current state of the game gets played, and add that amount to the number of times player 1 or 2 wins."),(0,i.kt)("p",null,"We first compute how many times each outcome happens:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"/** For each 3-die throw, how many of each total sum do we have? */\nval dieCombinations: List[(Int, Long)] =\n  val possibleRolls: List[Int] =\n    for\n      die1 <- List(1, 2, 3)\n      die2 <- List(1, 2, 3)\n      die3 <- List(1, 2, 3)\n    yield\n      die1 + die2 + die3\n  possibleRolls.groupMapReduce(identity)(_ => 1L)(_ + _).toList\n")),(0,i.kt)("p",null,"Then, we add a parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"inHowManyUniverses")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"playWithDiracDie"),", and multiply it in the recursive calls by the number of times that each outcome happens:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def playWithDiracDie(players: Players, player1Turn: Boolean, wins: Wins, inHowManyUniverses: Long): Unit =\n  for (diesValue, count) <- dieCombinations do\n    val newInHowManyUniverses = inHowManyUniverses * count\n    val player = players(0)\n    val newCell = (player.cell + diesValue) % 10\n    val newScore = player.score + (newCell + 1)\n    if newScore >= 21 then\n      if player1Turn then\n        wins.player1Wins += newInHowManyUniverses\n      else\n        wins.player2Wins += newInHowManyUniverses\n    else\n      val newPlayer = Player(newCell, newScore)\n      playWithDiracDie((players(1), newPlayer), !player1Turn, wins, newInHowManyUniverses)\n  end for\n")),(0,i.kt)("p",null,"We start with 1 universe, so the initial call to ",(0,i.kt)("inlineCode",{parentName:"p"},"playWithDiracDie")," is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"playWithDiracDie(players, player1Turn = true, wins, inHowManyUniverses = 1L)\n")),(0,i.kt)("p",null,"The reduction of the branching factor from 27 to 7 is enough to simulate all the possible universes in seconds, whereas I stopped waiting for the naive solution after a few minutes."),(0,i.kt)("h2",{id:"solution-for-part-2"},"Solution for part 2"),(0,i.kt)("p",null,"Here is the full code for part 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final class Wins(var player1Wins: Long, var player2Wins: Long)\n\ndef part2(input: String): Long =\n  val players = parseInput(input)\n  val wins = new Wins(0L, 0L)\n  playWithDiracDie(players, player1Turn = true, wins, inHowManyUniverses = 1L)\n  Math.max(wins.player1Wins, wins.player2Wins)\n\n/** For each 3-die throw, how many of each total sum do we have? */\nval dieCombinations: List[(Int, Long)] =\n  val possibleRolls: List[Int] =\n    for\n      die1 <- List(1, 2, 3)\n      die2 <- List(1, 2, 3)\n      die3 <- List(1, 2, 3)\n    yield\n      die1 + die2 + die3\n  possibleRolls.groupMapReduce(identity)(_ => 1L)(_ + _).toList\n\ndef playWithDiracDie(players: Players, player1Turn: Boolean, wins: Wins, inHowManyUniverses: Long): Unit =\n  for (diesValue, count) <- dieCombinations do\n    val newInHowManyUniverses = inHowManyUniverses * count\n    val player = players(0)\n    val newCell = (player.cell + diesValue) % 10\n    val newScore = player.score + (newCell + 1)\n    if newScore >= 21 then\n      if player1Turn then\n        wins.player1Wins += newInHowManyUniverses\n      else\n        wins.player2Wins += newInHowManyUniverses\n    else\n      val newPlayer = Player(newCell, newScore)\n      playWithDiracDie((players(1), newPlayer), !player1Turn, wins, newInHowManyUniverses)\n  end for\n")),(0,i.kt)(r.Z,{puzzle:"day21-part2",mdxType:"Solver"}),(0,i.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,i.kt)("p",null,"You can get this solution locally by cloning the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,i.kt)("p",null,"You can run it with ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ scala-cli src -M day21.part1\nThe answer is: 855624\n\n$ scala-cli src -M day21.part2\nThe answer is: 187451244607486\n")),(0,i.kt)("p",null,"You can replace the content of the ",(0,i.kt)("inlineCode",{parentName:"p"},"input/day21")," file with your own input from ",(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/21"},"adventofcode.com")," to get your own solution."),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day21.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),".")),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page."))}h.isMDXComponent=!0}}]);