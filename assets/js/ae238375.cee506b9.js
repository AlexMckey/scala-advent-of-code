"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8243],{4180:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var a=n(7462),o=(n(7294),n(3905)),i=n(6340);const s={},l="Day 9: Rope Bridge",r={unversionedId:"2022/puzzles/day09",id:"2022/puzzles/day09",title:"Day 9: Rope Bridge",description:"code by Jamie Thompson",source:"@site/target/mdoc/2022/puzzles/day09.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day09",permalink:"/scala-advent-of-code/2022/puzzles/day09",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day09.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 8: Treetop Tree House",permalink:"/scala-advent-of-code/2022/puzzles/day08"},next:{title:"Day 10: Cathode-Ray Tube",permalink:"/scala-advent-of-code/2022/puzzles/day10"}},p={},d=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-9-rope-bridge"},"Day 9: Rope Bridge"),(0,o.kt)("p",null,"code by ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/bishabosha"},"Jamie Thompson")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/9"},"https://adventofcode.com/2022/day/9")),(0,o.kt)("h2",{id:"solution"},"Solution"),(0,o.kt)("p",null,"Today's goal is to find the unique positions occupied by the final knot of a rope. For part 1 the rope has 2 knots, and\nfor part 2, it has 3."),(0,o.kt)("p",null,"To model a position, you can use a case class to store ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," coordinates:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Position(x: Int, y: Int)\n")),(0,o.kt)("p",null,"The front knot, or head of the rope can be translated in one of four directions ",(0,o.kt)("inlineCode",{parentName:"p"},"U"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"D"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"L"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"R"),"; modelled as an enum:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"enum Direction:\n  case U, D, L, R\n")),(0,o.kt)("p",null,"Reading the challenge description, we know that the head can translate in any direction by multiple steps. You can\nmodel a single step by the following method ",(0,o.kt)("inlineCode",{parentName:"p"},"moveOne")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"Position"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import Direction.*\n\ncase class Position(x: Int, y: Int):\n  def moveOne(dir: Direction): Position = dir match\n    case U => Position(x, y + 1)\n    case D => Position(x, y - 1)\n    case L => Position(x - 1, y)\n    case R => Position(x + 1, y)\n")),(0,o.kt)("p",null,"Then using the rules described in the challenge description, one knot follows another knot, by translating 1 position\nin the vector between it and the previous knot. This is modelled by another method, ",(0,o.kt)("inlineCode",{parentName:"p"},"follow")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"Position"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Position(x: Int, y: Int):\n  ...\n\n  def follow(head: Position): Position =\n    val dx = head.x - x\n    val dy = head.y - y\n    if dx.abs > 1 || dy.abs > 1 then Position(x + dx.sign, y + dy.sign) // follow the head\n    else this // stay put\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Its important to note that while the head of the rope can move in only 1 of the four directions, a trailing knot can\nmove in any 2D vector composed of those directions."),(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sign")," method on ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," gives ",(0,o.kt)("inlineCode",{parentName:"p"},"-1")," for a negative integer, ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," for a positive integer, or ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," for zero. This\nlets you move only 1 in distance in the direction towards the leading knot.")),(0,o.kt)("p",null,"Given all the methods necessary to move knots, now you can model an entire rope of knots following the head after it\nhas moved."),(0,o.kt)("p",null,"The idea here is to start with the head of the rope that has already been moved,\nthen with each knot in the rope, ",(0,o.kt)("inlineCode",{parentName:"p"},"follow")," the previous one, using each translated knot to build a new rope.\nThis is modelled with ",(0,o.kt)("inlineCode",{parentName:"p"},"followAll"),", like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def followAll(head: Position, knots: List[Position]): (Position, List[Position]) =\n  var prev = head // head was already moved with `moveOne`\n  val buf = List.newBuilder[Position]\n  for knot <- knots do\n    val next = knot.follow(prev)\n    buf += next\n    prev = next\n  (prev, buf.result())\nend followAll\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"followAll")," also returns the final knot, this is so we can track the position of the final knot after each\nstep.")),(0,o.kt)("p",null,"For the challenge, we also need to record the unique positions of the last knot in the list, as well as track the rope\nas it moves. This can be modelled in the following ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class State(uniques: Set[Position], head: Position, knots: List[Position])\n")),(0,o.kt)("p",null,"Then to iterate the whole state by 1 move in a direction, first move the head of the rope, then follow all the knots,\nadding the final knot to the set of unique positions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def step(dir: Direction, state: State) =\n  val head1 = state.head.moveOne(dir)\n  val (last, knots1) = followAll(head1, state.knots)\n  State(state.uniques + last, head1, knots1)\n")),(0,o.kt)("p",null,"then to model multiple steps in a direction, wrap ",(0,o.kt)("inlineCode",{parentName:"p"},"step")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"Iterator.iterate"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def steps(state: State, dir: Direction): Iterator[State] =\n  Iterator.iterate(state)(state => step(dir, state))\n")),(0,o.kt)("p",null,"This makes an infinite iterator that progresses the state by 1 step with each element."),(0,o.kt)("p",null,"Now you have all the pieces to read the challenge input.\nFirst create the initial state, which depends on the rope size, and as the rope starts at ",(0,o.kt)("inlineCode",{parentName:"p"},"0,0"),", record the position\nas seen:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def initialState(knots: Int) =\n  val zero = Position(0, 0)\n  State(Set(zero), zero, List.fill(knots - 1)(zero))\n")),(0,o.kt)("p",null,"Then taking the input string, read through all the lines, and ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft")," on the initial state.\nEach line you can extract the direction and steps count with a pattern binding ",(0,o.kt)("inlineCode",{parentName:"p"},'val (s"$dir $n") = line'),",\nthen use ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction.valueOf")," to lookup the direction, and ",(0,o.kt)("inlineCode",{parentName:"p"},".toInt")," to convert ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," to the number of steps."),(0,o.kt)("p",null,"Then to run ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," steps, create the ",(0,o.kt)("inlineCode",{parentName:"p"},"steps")," iterator, then drop ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," elements to advance the state ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," steps,\nthen take the ",(0,o.kt)("inlineCode",{parentName:"p"},"next()")," element:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def uniquePositions(input: String, knots: Int): Int =\n  val end = input.linesIterator.foldLeft(initialState(knots)) { case (state, line) =>\n    val (s"$dir $n") = line: @unchecked\n    steps(state, Direction.valueOf(dir)).drop(n.toInt).next()\n  }\n  end.uniques.size\n')),(0,o.kt)("p",null,"Part 1 needs 2 knots, and part 2 needs 10 knots, they can be implemented as such:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  uniquePositions(input, knots = 2)\n\ndef part2(input: String): Int =\n  uniquePositions(input, knots = 10)\n")),(0,o.kt)("h2",{id:"final-code"},"Final Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import Direction.*\n\ndef part1(input: String): Int =\n  uniquePositions(input, knots = 2)\n\ndef part2(input: String): Int =\n  uniquePositions(input, knots = 10)\n\ncase class Position(x: Int, y: Int):\n  def moveOne(dir: Direction): Position = dir match\n    case U => Position(x, y + 1)\n    case D => Position(x, y - 1)\n    case L => Position(x - 1, y)\n    case R => Position(x + 1, y)\n\n  def follow(head: Position): Position =\n    val dx = head.x - x\n    val dy = head.y - y\n    if dx.abs > 1 || dy.abs > 1 then Position(x + dx.sign, y + dy.sign) // follow the head\n    else this // stay put\n\ncase class State(uniques: Set[Position], head: Position, knots: List[Position])\n\nenum Direction:\n  case U, D, L, R\n\ndef followAll(head: Position, knots: List[Position]) =\n  var prev = head // head was already moved with `moveOne`\n  val buf = List.newBuilder[Position]\n  for knot <- knots do\n    val next = knot.follow(prev)\n    buf += next\n    prev = next\n  (prev, buf.result())\nend followAll\n\ndef step(dir: Direction, state: State) =\n  val head1 = state.head.moveOne(dir)\n  val (last, knots1) = followAll(head1, state.knots)\n  State(state.uniques + last, head1, knots1)\n\ndef steps(state: State, dir: Direction): Iterator[State] =\n  Iterator.iterate(state)(state => step(dir, state))\n\ndef initialState(knots: Int) =\n  val zero = Position(0, 0)\n  State(Set(zero), zero, List.fill(knots - 1)(zero))\n\ndef uniquePositions(input: String, knots: Int): Int =\n  val end = input.linesIterator.foldLeft(initialState(knots)) { case (state, line) =>\n    val (s"$dir $n") = line: @unchecked\n    steps(state, Direction.valueOf(dir)).drop(n.toInt).next()\n  }\n  end.uniques.size\n')),(0,o.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,o.kt)("h4",{id:"part-1"},"Part 1"),(0,o.kt)(i.Z,{puzzle:"day09-part1",year:"2022",mdxType:"Solver"}),(0,o.kt)("h4",{id:"part-2"},"Part 2"),(0,o.kt)(i.Z,{puzzle:"day09-part2",year:"2022",mdxType:"Solver"}),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/MewenCrespo/Advent-Of-Code/blob/main/src/adventofcode/year2022/Day9.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/MewenCrespo"},"Mewen Crespo"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2022/blob/master/src/main/scala/day09/Day09.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/SimY4/advent-of-code-scala/blob/master/src/main/scala/aoc/y2022/Day9.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/actinglikecrazy"},"SimY4"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/stewSquared/advent-of-code-scala/blob/master/src/main/scala/2022/Day09.worksheet.sc"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/stewSqrd"},"Stewart Stewart"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2022/src/test/scala/Day09.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day9.scala"},"Solution")," by Cosmin Ciobanu"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day09.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day9.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau/code-advent-2022/blob/master/src/main/scala/com/adventofcode/Day9.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau"},"Daniel Naumau")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/w-r-z-k/aoc2022/blob/main/src/main/scala/Day9.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/w-r-z-k"},"Richard W")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day9"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/rpiotrow/advent-of-code-2022/tree/main/src/main/scala/io/github/rpiotrow/advent2022/day09"},"Solution using ZIO")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/rpiotrow"},"Rafa\u0142 Piotrowski"))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}c.isMDXComponent=!0}}]);