"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[578],{5374:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=a(7462),o=(a(7294),a(3905));a(6340);const i={},l="Day 24: Blizzard Basin",r={unversionedId:"2022/puzzles/day24",id:"2022/puzzles/day24",title:"Day 24: Blizzard Basin",description:"Puzzle description",source:"@site/target/mdoc/2022/puzzles/day24.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day24",permalink:"/scala-advent-of-code/2022/puzzles/day24",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day24.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 23: Unstable Diffusion",permalink:"/scala-advent-of-code/2022/puzzles/day23"},next:{title:"Day 25: Full of Hot Air",permalink:"/scala-advent-of-code/2022/puzzles/day25"}},s={},d=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2},{value:"Solutions from the community",id:"solutions-from-the-community-1",level:2}],c={toc:d};function m(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-24-blizzard-basin"},"Day 24: Blizzard Basin"),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/24"},"https://adventofcode.com/2022/day/24")),(0,o.kt)("h2",{id:"solution"},"Solution"),(0,o.kt)("p",null,"Today's problem is similar to ",(0,o.kt)("a",{parentName:"p",href:"https://scalacenter.github.io/scala-advent-of-code/2022/puzzles/day12"},"Day 12"),", where we need to find our way through a maze. It's made more challenging by impassable blizzards moving through the maze. We can use a similar approach to that of Day 12 still, but we'll improve a little bit further by using ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/A*_search_algorithm"},"A* search")," instead of a standard breadth first search."),(0,o.kt)("p",null,"We'll need some kind of point and a few functions that are useful on the 2d grid. A simple tuple ",(0,o.kt)("inlineCode",{parentName:"p"},"(Int, Int)")," will suffice, and we'll add the functions as extension methods. We'll use Manhattan distance as the A* heuristic function, and we'll need the neighbours in cardinal directions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"type Coord = (Int, Int)\nextension (coord: Coord)\n  def x = coord._1\n  def y = coord._2\n  def up = (coord.x, coord.y - 1)\n  def down = (coord.x, coord.y + 1)\n  def left = (coord.x - 1, coord.y)\n  def right = (coord.x + 1, coord.y)\n  def cardinals = Seq(coord.up, coord.down, coord.left, coord.right)\n  def manhattan(rhs: Coord) = (coord.x - rhs.x).abs + (coord.y - rhs.y).abs\n  def +(rhs: Coord) = (coord.x + rhs.x, coord.y + rhs.y)\n")),(0,o.kt)("p",null,"Before we get to the search, let's deal with the input."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Blizzard(at: Coord, direction: Coord)\n\ndef parseMaze(in: Seq[String]) =\n  val start = (in.head.indexOf('.'), 0) // start in the empty spot in the top row\n  val end = (in.last.indexOf('.'), in.size - 1) // end in the empty spot in the bottom row\n  val xDomain = 1 to in.head.size - 2 // where blizzards are allowed to go\n  val yDomain = 1 to in.size - 2\n  val initialBlizzards =\n    for\n      y <- in.indices\n      x <- in(y).indices\n      if in(y)(x) != '.' // these aren't blizzards!\n      if in(y)(x) != '#'\n    yield in(y)(x) match\n      case '>' => Blizzard(at = (x, y), direction = (1, 0))\n      case '<' => Blizzard(at = (x, y), direction = (-1, 0))\n      case '^' => Blizzard(at = (x, y), direction = (0, -1))\n      case 'v' => Blizzard(at = (x, y), direction = (0, 1))\n\n  ??? // ...to be implemented\n")),(0,o.kt)("p",null,"Ok, let's deal with the blizzards. The blizzards move ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Toroid"},"toroidally"),", which is to say they loop around back to the start once they fall off an edge. This means that, eventually, the positions and directions of ",(0,o.kt)("em",{parentName:"p"},"all")," blizzards must loop at some point. Naively, after ",(0,o.kt)("inlineCode",{parentName:"p"},"xDomain.size * yDomain.size")," minutes, every blizzard must have returned to it's original starting location. Let's model that movement and calculate the locations of all the blizzards up until that time. With it, we'll have a way to tell us where the blizzards are at a given time ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),", for any ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def move(blizzard: Blizzard, xDomain: Range, yDomain: Range) =\n  blizzard.copy(at = cycle(blizzard.at + blizzard.direction, xDomain, yDomain))\n\ndef cycle(coord: Coord, xDomain: Range, yDomain: Range): Coord = (cycle(coord.x, xDomain), cycle(coord.y, yDomain))\n\ndef cycle(n: Int, bounds: Range): Int =\n  if n > bounds.max then bounds.min // we've fallen off the end, go to start\n  else if n < bounds.min then bounds.max // we've fallen off the start, go to the end\n  else n // we're chillin' in bounds still\n")),(0,o.kt)("p",null,"We can replace the ",(0,o.kt)("inlineCode",{parentName:"p"},"???")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"parseMaze")," now. And we'll need a return type for the function. We can cram everything into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Maze")," case class. For the blizzards, we actually only need to care about where they are after this point, as they'll prevent us from moving to those locations. We'll throw away the directions and just keep the set of ",(0,o.kt)("inlineCode",{parentName:"p"},"Coord"),"s the blizzards are at."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Maze(xDomain: Range, yDomain: Range, blizzards: Seq[Set[Coord]], start: Coord, end: Coord)\n\ndef parseMaze(in: Seq[String]): Maze =\n  /* ...omitted for brevity... */\n  def tick(blizzards: Seq[Blizzard]) = blizzards.map(move(_, xDomain, yDomain))\n  val allBlizzardLocations = Iterator.iterate(initialBlizzards)(tick)\n      .take(xDomain.size * yDomain.size)\n      .map(_.map(_.at).toSet)\n      .toIndexedSeq\n\n  Maze(xDomain, yDomain, allBlizzardLocations, start, end)\n")),(0,o.kt)("p",null,"But! We can do a little better for the blizzards. The blizzards actually cycle for ",(0,o.kt)("em",{parentName:"p"},"any common multiple")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"xDomain.size")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"yDomain.size"),". Using the least common multiple would be sensible to do the least amount of computation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def gcd(a: Int, b: Int): Int = if b == 0 then a else gcd(b, a % b)\ndef lcm(a: Int, b: Int): Int = a * b / gcd(a, b)\ndef tick(blizzards: Seq[Blizzard]) = blizzards.map(move(_, xDomain, yDomain))\nval allBlizzardLocations = Iterator.iterate(initialBlizzards)(tick)\n    .take(lcm(xDomain.size, yDomain.size))\n    .map(_.map(_.at).toSet)\n    .toIndexedSeq\n")),(0,o.kt)("p",null,"Great! Let's solve the maze."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable\ncase class Step(at: Coord, time: Int)\n\ndef solve(maze: Maze): Step =\n  // order A* options by how far we've taken + an estimated distance to the end\n  given Ordering[Step] = Ordering[Int].on((step: Step) => step.at.manhattan(maze.end) + step.time).reverse\n  val queue = mutable.PriorityQueue[Step]()\n  val visited = mutable.Set.empty[Step]\n  \n  def inBounds(coord: Coord) = coord match\n    case c if c == maze.start || c == maze.end => true\n    case c => maze.xDomain.contains(c.x) && maze.yDomain.contains(c.y)\n\n  queue += Step(at = maze.start, time = 0)\n  while queue.head.at != maze.end do\n    val step = queue.dequeue\n    val time = step.time + 1\n    // where are the blizzards for our next step? we can't go there\n    val blizzards = maze.blizzards(time % maze.blizzards.size)\n    // we can move in any cardinal direction, or chose to stay put; but it needs to be in the maze\n    val options = (step.at.cardinals :+ step.at).filter(inBounds).map(Step(_, time))\n    // queue up the options if they are possible; and if we have not already queued them\n    queue ++= options\n      .filterNot(o => blizzards(o.at)) // the option must not be in a blizzard\n      .filterNot(visited) // avoid duplicate work\n      .tapEach(visited.add) // keep track of what we've enqueued\n\n  queue.dequeue\n")),(0,o.kt)("p",null,"That's pretty much it! Part 1 is then:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(in: Seq[String]) = solve(parseMaze(in)).time\n")),(0,o.kt)("p",null,"Part 2 requires solving the maze 3 times. Make it to the end (so, solve part 1 again), go back to the start, then go back to the end. We can use the same ",(0,o.kt)("inlineCode",{parentName:"p"},"solve")," function, but we need to generalize a bit so we can start the solver at an arbitrary time. This will allow us to keep the state of the blizzards for subsequent runs. We actually only need to change one line!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def solve(maze: Maze, startingTime: Int = 0): Step =\n  /* the only line we need to change is... */\n  queue += Step(at = maze.start, time = startingTime)\n")),(0,o.kt)("p",null,"Then part 2 requires calling ",(0,o.kt)("inlineCode",{parentName:"p"},"solve")," 3 times. We need to be a little careful with the start/end locations and starting times."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(in: Seq[String]) =\n  val maze = parseMaze(in)\n  val first = solve(maze)\n  val second = solve(maze.copy(start = maze.end, end = maze.start), first.time)\n  solve(maze, second.time).time\n")),(0,o.kt)("p",null,"That's Day 24. Huzzah!"),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/twentylemon/advent-of-code/blob/main/src/test/scala/org/lemon/advent/year2022/Day24Test.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/twentylemon"},"twentylemon"))),(0,o.kt)("h2",{id:"solutions-from-the-community-1"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day24.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten"))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}m.isMDXComponent=!0}}]);