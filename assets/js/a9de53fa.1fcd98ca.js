"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8158],{4374:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>m,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var n=t(7462),i=(t(7294),t(3905)),s=t(6340);const r={},m="Day 25: Snowverload",l={unversionedId:"2023/puzzles/day25",id:"2023/puzzles/day25",title:"Day 25: Snowverload",description:"by @bishabosha",source:"@site/target/mdoc/2023/puzzles/day25.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day25",permalink:"/scala-advent-of-code/2023/puzzles/day25",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day25.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 24: Never Tell Me The Odds",permalink:"/scala-advent-of-code/2023/puzzles/day24"},next:{title:"Day 1: Calorie Counting",permalink:"/scala-advent-of-code/2022/puzzles/day01"}},p={},o=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Naive Way",id:"naive-way",level:3},{value:"Minumum Cut Algorithm",id:"minumum-cut-algorithm",level:3},{value:"Solving in Scala",id:"solving-in-scala",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Graph",id:"graph",level:3},{value:"MostConnected",id:"mostconnected",level:3},{value:"Writing the Algorithm",id:"writing-the-algorithm",level:3},{value:"minimumCutPhase",id:"minimumcutphase",level:4},{value:"minimumCutPhase",id:"minimumcutphase-1",level:4},{value:"Parsing",id:"parsing",level:3},{value:"Reading the input",id:"reading-the-input",level:4},{value:"Building the graph",id:"building-the-graph",level:4},{value:"The Solution",id:"the-solution",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:o};function h(e){let{components:a,...t}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-25-snowverload"},"Day 25: Snowverload"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/25"},"https://adventofcode.com/2023/day/25")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"We are told that there are 3 connections that when removed will partition the components into two groups.\nWe then have to multiply the sizes of the two partitions.\nThis is equivalent to finding a minimum cut in an undirected, unweighted graph, which can be solved with the\n",(0,i.kt)("a",{parentName:"p",href:"https://dl.acm.org/doi/pdf/10.1145/263867.263872"},"Stoer-Wagner minimum cut algorithm"),"."),(0,i.kt)("h3",{id:"naive-way"},"Naive Way"),(0,i.kt)("p",null,"You may be tempted to brute force the solution by testing all combinations of three edges to remove, and checking if the result makes two partitions. This works in reasonable time with the sample input. The real input is much larger however, and with about ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow"},"\u223c"),(0,i.kt)("mn",{parentName:"mrow"},"3400")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sim 3400")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.36687em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u223c"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"3"),(0,i.kt)("span",{parentName:"span",className:"mord"},"4"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0")))))," connections, which means there are\n",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mrow",{parentName:"mrow"},(0,i.kt)("mo",{parentName:"mrow",fence:"true"},"("),(0,i.kt)("mfrac",{parentName:"mrow",linethickness:"0px"},(0,i.kt)("mrow",{parentName:"mfrac"},(0,i.kt)("mo",{parentName:"mrow"},"\u223c"),(0,i.kt)("mn",{parentName:"mrow"},"3400")),(0,i.kt)("mn",{parentName:"mfrac"},"3")),(0,i.kt)("mo",{parentName:"mrow",fence:"true"},")")),(0,i.kt)("mo",{parentName:"mrow"},"\u2248"),(0,i.kt)("mn",{parentName:"mrow"},"6"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mn",{parentName:"mrow"},"500"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mn",{parentName:"mrow"},"000"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mn",{parentName:"mrow"},"000")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"{\\sim 3400 \\choose 3} \\approx 6,500,000,000")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1.245118em",verticalAlign:"-0.35001em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mopen delimcenter",style:{top:"0em"}},(0,i.kt)("span",{parentName:"span",className:"delimsizing size1"},"(")),(0,i.kt)("span",{parentName:"span",className:"mfrac"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8951079999999999em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.3550000000000004em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"3")))),(0,i.kt)("span",{parentName:"span",style:{top:"-3.144em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},(0,i.kt)("span",{parentName:"span",className:"mrel mtight"},"\u223c"),(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"3"),(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"4"),(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"0"))))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,i.kt)("span",{parentName:"span"}))))),(0,i.kt)("span",{parentName:"span",className:"mclose delimcenter",style:{top:"0em"}},(0,i.kt)("span",{parentName:"span",className:"delimsizing size1"},")")))),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u2248"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8388800000000001em",verticalAlign:"-0.19444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"6"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"5"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"0")))))," combinations to test."),(0,i.kt)("h3",{id:"minumum-cut-algorithm"},"Minumum Cut Algorithm"),(0,i.kt)("p",null,"The pseudo code for the ",(0,i.kt)("a",{parentName:"p",href:"https://dl.acm.org/doi/pdf/10.1145/263867.263872"},"Stoer-Wagner algorithm")," is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"G := {V, E}\n\ndef MinimumCutPhase(G, w, a) =\n  A := {a}\n  while A != V do\n    A += MostTightlyConnected(G, w, A)\n  cut := CutOfThePhase(G, A)\n  Shrink(G, w, A)\n  return cut\n\ndef MinumumCut(G, w, a) =\n  min := EmptyCut // an empty cut (impossible)\n  while V.size > 1 do\n    cut := MinimumCutPhase(G, w, a)\n    if Weight(cut) < Weight(min) || IsEmpty(min) then\n      min = cut\n  return min\n")),(0,i.kt)("p",null,"i.e. it is an iterative algorithm that begins with a graph (",(0,i.kt)("inlineCode",{parentName:"p"},"G"),") made of vertices (",(0,i.kt)("inlineCode",{parentName:"p"},"V"),") and undirected edges (",(0,i.kt)("inlineCode",{parentName:"p"},"E"),"), with a weight function (",(0,i.kt)("inlineCode",{parentName:"p"},"w"),"). It assumes that there is at most a single edge between any two vertices.\nThe algorithm works by iteratively shrinking a graph by removing edges, and testing if the cut (i.e. the removed edges) is minimal."),(0,i.kt)("p",null,"Begin in the main ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum-cut")," loop. Initialise the ",(0,i.kt)("inlineCode",{parentName:"p"},"min")," to an empty cut.\nWhile the graph has more than one vertex, run the ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum-cut-phase")," on the graph with an arbitrary vertex ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". The phase returns a single ",(0,i.kt)("inlineCode",{parentName:"p"},"cut-of-the-phase"),", stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"cut"),".\nIf the cut has a smaller weight than ",(0,i.kt)("inlineCode",{parentName:"p"},"min")," (or is non-empty), record it as the new minimum.\nAt the end of iteration, return ",(0,i.kt)("inlineCode",{parentName:"p"},"min")," which will be the minimum cut."),(0,i.kt)("p",null,"In each ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum-cut-phase"),", initialise ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to a set containing ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),".\nIteratively add new vertices to ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," until it equals ",(0,i.kt)("inlineCode",{parentName:"p"},"V"),".\nIn each iteration, the vertex added is always the current ",(0,i.kt)("inlineCode",{parentName:"p"},"most-tightly-connected"),(0,i.kt)("sup",null,"1.")," vertex from ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," to vertices of ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),".\nAfter iteration, store the ",(0,i.kt)("inlineCode",{parentName:"p"},"cut-of-the-phase"),(0,i.kt)("sup",null,"2.")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"cut"),"; then shrink the graph by merging",(0,i.kt)("sup",null,"3.")," the two vertices ",(0,i.kt)("inlineCode",{parentName:"p"},"added-last")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),". Return ",(0,i.kt)("inlineCode",{parentName:"p"},"cut"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"most-tightly-connected")," vertex, ",(0,i.kt)("inlineCode",{parentName:"li"},"z"),", is a vertex in ",(0,i.kt)("inlineCode",{parentName:"li"},"V")," (and not in ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),") where the total weight of edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"z")," is maximum."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"cut-of-the-phase")," is the cut formed by removing the vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"added-last")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),"."),(0,i.kt)("li",{parentName:"ol"},"Call ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," the vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"added-last")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," the next ",(0,i.kt)("inlineCode",{parentName:"li"},"added-last")," vertex.\nRemove ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"V"),".\nFrom ",(0,i.kt)("inlineCode",{parentName:"li"},"E"),", remove edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," to all other vertices (this is the ",(0,i.kt)("inlineCode",{parentName:"li"},"cut-of-the-phase"),").\nUpdate the weight function ",(0,i.kt)("inlineCode",{parentName:"li"},"w")," such that the weight of an edge from ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," to some vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," is added to the weight of any edge from ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," to the same ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),".")),(0,i.kt)("h2",{id:"solving-in-scala"},"Solving in Scala"),(0,i.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"Scala comes standard with a rich collections library to help us, we will solve this problem with purely immutable collections. However we will need to augment with a few custom data structures:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"Graph")," to store the vertices, edges and weights"),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("inlineCode",{parentName:"li"},"MostConnected"),' heap structure that will provide the next "most-tightly-connected" vertex.')),(0,i.kt)("h3",{id:"graph"},"Graph"),(0,i.kt)("p",null,"To begin let's describe the ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.immutable.BitSet\n\ntype Id = Int\ntype Vertices = BitSet\ntype Weight = Map[Id, Map[Id, Int]]\n\ncase class Graph(v: Vertices, nodes: Map[Id, Vertices], w: Weight)\n")),(0,i.kt)("p",null,"In the problem statement, the vertices are strings. However, comparisons of strings are expensive, so to improve performance, we will represent each vertex as a unique integer."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Converting string keys to integer IDs is a lossy operation, so for debugging purposes, before you build the graph, it could be useful to store a reverse lookup from an integer ID to its original key, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},'0 -> "dpx"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'1 -> "bkx"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'2 -> "xzl"'),", etc.")),(0,i.kt)("p",null,"the graph has three fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"v")," a bitset of vertex IDs,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes")," is particularly useful for the Stoer-Wagner algorithm.\nFor any vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"y")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),", it stores the set of vertices that have been merged with ",(0,i.kt)("inlineCode",{parentName:"li"},"y")," (including ",(0,i.kt)("inlineCode",{parentName:"li"},"y")," itself)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"w")," is an adjacency matrix of vertices, and also stores the weight associated with each edge.")),(0,i.kt)("p",null,"Now, consider the problem.\nWe have to find a minimum cut, it should have weight 3, and we also need to find the resulting partition of the cut (so we can multiply the sizes of each partition)."),(0,i.kt)("p",null,"so we can add the following to the code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Graph(v: Vertices, nodes: Map[Id, Vertices], w: Weight):\n  def cutOfThePhase(t: Id) = Graph.Cut(t = t, edges = w(t)) // 1.\n\n  def partition(cut: Graph.Cut): (Vertices, Vertices) = // 2.\n    (nodes(cut.t), (v - cut.t).flatMap(nodes))\n\nobject Graph:\n  def emptyCut = Cut(t = -1, edges = Map.empty) // 3.\n\n  case class Cut(t: Id, edges: Map[Id, Int]): // 4.\n    lazy val weight: Int = edges.values.sum\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"cutOfThePhase")," makes a cut from ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),', which is the final "most-tightly-connected" vertex in a phase.'),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"partition")," takes a cut, and returns two partitions: the nodes associated with ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),"; and the rest."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Graph.emptyCut")," is a default value for a cut, it is empty."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Graph.Cut")," stores a vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),", and the weights of edges of reachable vertices from ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),".\na cut also has a ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," property, which is the total weight of all the edges of the cut.")),(0,i.kt)("p",null,'The last property the graph needs is a way to "shrink" it. We are given ',(0,i.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," will be removed from the graph and its edges merge with ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// in case class Graph:\n  def shrink(s: Id, t: Id): Graph =\n    def fetch(x: Id) = // 1.\n      w(x).view.filterKeys(y => y != s && y != t) // 1.\n\n    val prunedW = (w - t).view.mapValues(_ - t).toMap // 2.\n\n    val fromS = fetch(s).toMap // 3.\n    val fromT = fetch(t).map: (y, w0) => // 3.\n      y -> (fromS.getOrElse(y, 0) + w0) // 3.\n    val mergedWeights = fromS ++ fromT // 3.\n\n    val reverseMerged = mergedWeights.view.map: (y, w0) => // 4.\n      y -> (prunedW(y) + (s -> w0)) // 4.\n\n    val v1 = v - t // 5.\n    val w1 = prunedW + (s -> mergedWeights) ++ reverseMerged // 6.\n    val nodes1 = nodes - t + (s -> (nodes(s) ++ nodes(t))) // 7.\n    Graph(v1, nodes1, w1) // 8.\n  end shrink\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"fetch")," finds the edges from vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," to any vertex that is not ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),"."),(0,i.kt)("li",{parentName:"ol"},"remove the edges of ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"w")," in both directions (from and to)."),(0,i.kt)("li",{parentName:"ol"},"merge the weights of edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," into edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," (ignoring edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"s"),").\nThe result ",(0,i.kt)("inlineCode",{parentName:"li"},"mergedWeights")," is an adjacency list from the merged ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," vertex."),(0,i.kt)("li",{parentName:"ol"},"To preserve the property of undirected edges, reverse the direction of ",(0,i.kt)("inlineCode",{parentName:"li"},"mergedWeights"),"."),(0,i.kt)("li",{parentName:"ol"},"remove ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),"."),(0,i.kt)("li",{parentName:"ol"},"update the edges of ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," in both directions."),(0,i.kt)("li",{parentName:"ol"},"remove ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"nodes"),", and add a new mapping from ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," to the combined nodes of ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"t")),(0,i.kt)("li",{parentName:"ol"},"return a new graph with the merged vertices, nodes and edges.")),(0,i.kt)("h3",{id:"mostconnected"},"MostConnected"),(0,i.kt)("p",null,"according to the ",(0,i.kt)("a",{parentName:"p",href:"https://dl.acm.org/doi/pdf/10.1145/263867.263872"},"Stoer-Wagner algorithm"),' the "most-tightly-connected" vertex ',(0,i.kt)("inlineCode",{parentName:"p"},"z")," is defined as follows:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"z"),(0,i.kt)("mo",{parentName:"mrow",mathvariant:"normal"},"\u2209"),(0,i.kt)("mi",{parentName:"mrow"},"A")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"z \\notin A")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.04398em"}},"z"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u2208")),(0,i.kt)("span",{parentName:"span",className:"mord vbox"},(0,i.kt)("span",{parentName:"span",className:"thinbox"},(0,i.kt)("span",{parentName:"span",className:"llap"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"inner"},(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord"},"/"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.05555555555555555em"}}))),(0,i.kt)("span",{parentName:"span",className:"fix"}))))),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"A")))))," such that ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"w"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"A"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"z"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,i.kt)("mo",{parentName:"mrow"},"="),(0,i.kt)("mi",{parentName:"mrow"},"m"),(0,i.kt)("mi",{parentName:"mrow"},"a"),(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"{"),(0,i.kt)("mi",{parentName:"mrow"},"w"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"A"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"y"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,i.kt)("mtext",{parentName:"mrow"},"\xa0"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,i.kt)("mtext",{parentName:"mrow"},"\xa0"),(0,i.kt)("mi",{parentName:"mrow"},"y"),(0,i.kt)("mo",{parentName:"mrow",mathvariant:"normal"},"\u2209"),(0,i.kt)("mi",{parentName:"mrow"},"A"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"}")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"w(A, z) = max \\{ w(A, y) ~|~ y \\notin A\\}")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02691em"}},"w"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"A"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.04398em"}},"z"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"="),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"a"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"{"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02691em"}},"w"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"A"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"),(0,i.kt)("span",{parentName:"span",className:"mspace nobreak"},"\xa0"),(0,i.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,i.kt)("span",{parentName:"span",className:"mspace nobreak"},"\xa0"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u2208")),(0,i.kt)("span",{parentName:"span",className:"mord vbox"},(0,i.kt)("span",{parentName:"span",className:"thinbox"},(0,i.kt)("span",{parentName:"span",className:"llap"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"inner"},(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord"},"/"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.05555555555555555em"}}))),(0,i.kt)("span",{parentName:"span",className:"fix"}))))),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"A"),(0,i.kt)("span",{parentName:"span",className:"mclose"},"}")))))),(0,i.kt)("p",{parentName:"blockquote"},"where ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"w"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"A"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"y"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"w(A, y)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02691em"}},"w"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"A"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")")))))," is the sum of the weights of all the edges between ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"A")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"A")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"A")))))," and ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"y")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"y")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"))))),".")),(0,i.kt)("p",null,"An efficient way to compute this is a heap structure, that stores the total weight of all edges from ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),".\nAt each step of the ",(0,i.kt)("inlineCode",{parentName:"p"},"minimumCutPhase")," we will remove the top of the heap to get ",(0,i.kt)("inlineCode",{parentName:"p"},"z"),", and then grow the remaining heap by adding connections from the newly added ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," to the rest of ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("p",null,"Here is the implementation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.immutable.TreeSet\n\nclass MostConnected(\n  totalWeights: Map[Id, Int], // 1.\n  queue: TreeSet[MostConnected.Entry] // 2.\n):\n\n  def pop = // 3.\n    val id = queue.head.id\n    id -> MostConnected(totalWeights - id, queue.tail)\n\n  def expand(z: Id, explore: Vertices, w: Weight) = // 4.\n    val connectedEdges =\n      w(z).view.filterKeys(explore)\n    var totalWeights0 = totalWeights\n    var queue0 = queue\n    for (id, w) <- connectedEdges do\n      val w1 = totalWeights0.getOrElse(id, 0) + w\n      totalWeights0 += id -> w1\n      queue0 += MostConnected.Entry(id, w1)\n    MostConnected(totalWeights0, queue0)\n  end expand\n\nend MostConnected\n\nobject MostConnected:\n  def empty = MostConnected(Map.empty, TreeSet.empty)\n  given Ordering[Entry] = (e1, e2) =>\n    val first = e2.weight.compareTo(e1.weight)\n    if first == 0 then e2.id.compareTo(e1.id) else first\n  class Entry(val id: Id, val weight: Int):\n    override def hashCode: Int = id\n    override def equals(that: Any): Boolean = that match\n      case that: Entry => id == that.id\n      case _ => false\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"MostConnected")," structure is immutable, and stores a heap of entries. Each entry stores a vertex ID and the total weight of edges from ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to that vertex."),(0,i.kt)("p",null,"We can describe the structure of ",(0,i.kt)("inlineCode",{parentName:"p"},"MostConnected")," as a composition of two other collections:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"totalWeights")," map, which is a fast lookup, storing a mapping from a vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"y")," to the total weights of edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"y"),"."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"queue"),", which is a ",(0,i.kt)("inlineCode",{parentName:"li"},"TreeSet")," of entries. A tree set is useful to implement a heap structure because its entries are sorted (using an ",(0,i.kt)("inlineCode",{parentName:"li"},"Ordering"),"). Each entry stores the same information as a mapping in ",(0,i.kt)("inlineCode",{parentName:"li"},"totalWeights"),", and will be sorted according to the ordering defined in the companion object of ",(0,i.kt)("inlineCode",{parentName:"li"},"MostConnected"),'. At any instant, the entry describing the "most-tightly-connected" vertex is first in the ',(0,i.kt)("inlineCode",{parentName:"li"},"queue"),".")),(0,i.kt)("p",null,"Next, pay attention to the signatures of ",(0,i.kt)("inlineCode",{parentName:"p"},"pop")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"expand"),", which are used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"minimumCutPhase"),":"),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"pop")," is used to extract the mostly tightly connected vertex ",(0,i.kt)("inlineCode",{parentName:"li"},"z"),". It returns a tuple of ",(0,i.kt)("inlineCode",{parentName:"li"},"z"),", and the remaining heap (i.e. by removing ",(0,i.kt)("inlineCode",{parentName:"li"},"z"),")."),(0,i.kt)("li",{parentName:"ol"},"After adding some ",(0,i.kt)("inlineCode",{parentName:"li"},"z")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),", then call ",(0,i.kt)("inlineCode",{parentName:"li"},"expand")," to add the new edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"z")," to the vertices of ",(0,i.kt)("inlineCode",{parentName:"li"},"explore")," (the vertices of ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," not in ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),"), using the weights of the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"w"),".")),(0,i.kt)("h3",{id:"writing-the-algorithm"},"Writing the Algorithm"),(0,i.kt)("p",null,"We now have enough code to implement the Stoer-Wagner algorithm in Scala code, using immutable data structures and local mutability."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha"),": ",(0,i.kt)("em",{parentName:"p"},"Hopefully you can see that the code is very similar to the ",(0,i.kt)("a",{parentName:"em",href:"#minumum-cut-algorithm"},"pseudocode")," presented above. I hope that this demonstrates that functional programming principles can be used to create concise and expressive code in Scala."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def minimumCutPhase(g: Graph) =\n  val a = g.v.head // 1.\n  var A = a :: Nil // 2.\n  var explore = g.v - a // 3.\n  var mostConnected =\n    MostConnected.empty.expand(a, explore, g.w) // 4.\n  while explore.nonEmpty do // 5.\n    val (z, rest) = mostConnected.pop // 6.\n    A ::= z // 7.\n    explore -= z // 7.\n    mostConnected = rest.expand(z, explore, g.w) // 8.\n  val t :: s :: _ = A: @unchecked // 9.\n  (g.shrink(s, t), g.cutOfThePhase(t)) // 10.\n\ndef minimumCut(g: Graph) =\n  var g0 = g // 11.\n  var min = (g, Graph.emptyCut) // 12.\n  while g0.v.size > 1 do\n    val (g1, cutOfThePhase) = minimumCutPhase(g0) // 13.\n    if cutOfThePhase.weight < min(1).weight\n      || min(1).weight == 0\n    then\n      min = (g0, cutOfThePhase)\n    g0 = g1 // 14.\n  min\n")),(0,i.kt)("p",null,"Here are some footnotes to explain the differences with the ",(0,i.kt)("a",{parentName:"p",href:"#minumum-cut-algorithm"},"pseudocode"),":"),(0,i.kt)("h4",{id:"minimumcutphase"},"minimumCutPhase"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The initial ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," vertex of ",(0,i.kt)("inlineCode",{parentName:"li"},"minimumCutPhase")," can be arbitrary, so use the first vertex of ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," (from graph ",(0,i.kt)("inlineCode",{parentName:"li"},"g"),")."),(0,i.kt)("li",{parentName:"ol"},"Instead of a set, use a list to store ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),", this is so we can later remember the final two nodes added.\nDue to the invariants of the algorithm, all the elements will be unique anyway."),(0,i.kt)("li",{parentName:"ol"},"For efficient lookup, we define explore as a bitset of vertices in ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," that have not yet been added to ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),"."),(0,i.kt)("li",{parentName:"ol"},"Initialise the ",(0,i.kt)("inlineCode",{parentName:"li"},"mostConnected")," heap with the weights of edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," to the vertices in ",(0,i.kt)("inlineCode",{parentName:"li"},"explore"),"."),(0,i.kt)("li",{parentName:"ol"},"when ",(0,i.kt)("inlineCode",{parentName:"li"},"explore")," is empty, then ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," will equal ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"pop")," from the ",(0,i.kt)("inlineCode",{parentName:"li"},"mostConnected")," heap, returning a tuple of ",(0,i.kt)("inlineCode",{parentName:"li"},"z"),' (the "most-tightly-connected" node), and the remaining heap.'),(0,i.kt)("li",{parentName:"ol"},"update the graph partitions, i.e. add ",(0,i.kt)("inlineCode",{parentName:"li"},"z")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),", and remove ",(0,i.kt)("inlineCode",{parentName:"li"},"z")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"explore"),"."),(0,i.kt)("li",{parentName:"ol"},"update the ",(0,i.kt)("inlineCode",{parentName:"li"},"rest")," of the heap by adding the weights of edges from ",(0,i.kt)("inlineCode",{parentName:"li"},"z")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"explore")," (i.e. this saves computation time because the weights of the edges from other vertices of ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," are already stored)."),(0,i.kt)("li",{parentName:"ol"},"extract ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"s"),', the two "added-last" nodes of ',(0,i.kt)("inlineCode",{parentName:"li"},"A"),"."),(0,i.kt)("li",{parentName:"ol"},"return a tuple of a shrunk graph, by merging ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"s"),", and the cut of the phase made by removing ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"g"),".")),(0,i.kt)("h4",{id:"minimumcutphase-1"},"minimumCutPhase"),(0,i.kt)("ol",{start:11},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Graph")," is an immutable data structure, but each iteration demands that we shrink the graph (i.e produce a new data structure containing the updated vertices, edges and weights), so ",(0,i.kt)("inlineCode",{parentName:"li"},"g0"),' stores the "current" graph being inspected.'),(0,i.kt)("li",{parentName:"ol"},"For our specific problem, we also need to find the partition caused by the minimum cut, so as well as storing the minimum cut, store the graph of the phase that produced the cut. At the end of all iterations we can compute the partition using the minimum cut."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"minimumCutPhase")," returns both the shrunk graph, and the cut of the phase."),(0,i.kt)("li",{parentName:"ol"},"Update ",(0,i.kt)("inlineCode",{parentName:"li"},"g0")," to the newly shrunk graph.")),(0,i.kt)("h3",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"We now need to construct our graph from the input."),(0,i.kt)("h4",{id:"reading-the-input"},"Reading the input"),(0,i.kt)("p",null,"First, ",(0,i.kt)("inlineCode",{parentName:"p"},"parse")," the input to an adjacency list as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(input: String): Map[String, Set[String]] =\n  input\n    .linesIterator\n    .map:\n      case s"$key: $values" => key -> values.split(" ").toSet\n    .toMap\n')),(0,i.kt)("p",null,"here a single line of the input, such as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"bvb: xhk hfx\n")),(0,i.kt)("p",null,"will parse to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'"bvb" -> Set("xhk", "hfx")\n')),(0,i.kt)("p",null,"Then the final ",(0,i.kt)("inlineCode",{parentName:"p"},".toMap")," will put all the lines together as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'Map(\n  "bvb" -> Set("xhk", "hfx"),\n  "qnr" -> Set("nvd"),\n  //...\n)\n')),(0,i.kt)("h4",{id:"building-the-graph"},"Building the graph"),(0,i.kt)("p",null,"The adjacency list we just parsed is not suitable for the Stoer-Wagner algorithm, as its edges are directed.\nWe will have to do the following processing steps to build a suitable graph representation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"identify all the vertices, and generate a unique integer ID for each one,"),(0,i.kt)("li",{parentName:"ul"},"generate an undirected adjacency matrix of weights. We must duplicate each edge from the original input to make an efficient lookup table. We will initialise each weight to 1 (remember that even though each edge is equal initially, when edges are merged, their weights must be combined).")),(0,i.kt)("p",null,"Here is the code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def readGraph(alist: Map[String, Set[String]]): Graph =\n  val all = alist.flatMap((k, vs) => vs + k).toSet\n\n  val (_, lookup) =\n    // perfect hashing\n    val initial = (0, Map.empty[String, Id])\n    all.foldLeft(initial): (acc, s) =>\n      val (id, seen) = acc\n      (id + 1, seen + (s -> id))\n\n  def asEdges(k: String, v: String) =\n    val t = (lookup(k), lookup(v))\n    t :: t.swap :: Nil\n\n  val v = lookup.values.to(BitSet)\n  val nodes = v.unsorted.map(id => id -> BitSet(id)).toMap\n  val edges =\n    for\n      (k, vs) <- alist.toSet\n      v <- vs\n      e <- asEdges(k, v) // (k -> v) + (v -> k)\n    yield\n      e\n\n  val w = edges\n    .groupBy((v, _) => v)\n    .view\n    .mapValues: m =>\n      m\n        .groupBy((_, v) => v)\n        .view\n        .mapValues(_ => 1)\n        .toMap\n    .toMap\n  Graph(v, nodes, w)\n")),(0,i.kt)("h3",{id:"the-solution"},"The Solution"),(0,i.kt)("p",null,"Putting everything together, we can now solve the problem!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val alist = parse(input) // 1.\n  val g = readGraph(alist) // 2.\n  val (graph, cut) = minimumCut(g) // 3.\n  val (out, in) = graph.partition(cut) // 4.\n  in.size * out.size // 5.\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse the input into an adjacency list (note. the edges are directed)"),(0,i.kt)("li",{parentName:"ol"},"Convert the adjacency list to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Graph")," structure."),(0,i.kt)("li",{parentName:"ol"},"Call the ",(0,i.kt)("inlineCode",{parentName:"li"},"minimumCut")," function on the graph, storing the minimum cut,\nand the state of the graph when the cut was made."),(0,i.kt)("li",{parentName:"ol"},"use the cut on the graph to get the partition of vertices."),(0,i.kt)("li",{parentName:"ol"},"multiply the sizes of the partitions to get the final answer.")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.collection.immutable.BitSet\nimport scala.collection.immutable.TreeSet\n\ndef part1(input: String): Int =\n  val alist = parse(input)\n  val g = readGraph(alist)\n  val (graph, cut) = minimumCut(g)\n  val (out, in) = graph.partition(cut)\n  in.size * out.size\n\ntype Id = Int\ntype Vertices = BitSet\ntype Weight = Map[Id, Map[Id, Int]]\n\ndef parse(input: String): Map[String, Set[String]] =\n  input\n    .linesIterator\n    .map:\n      case s"$key: $values" => key -> values.split(" ").toSet\n    .toMap\n\ndef readGraph(alist: Map[String, Set[String]]): Graph =\n  val all = alist.flatMap((k, vs) => vs + k).toSet\n\n  val (_, lookup) =\n    // perfect hashing\n    val initial = (0, Map.empty[String, Id])\n    all.foldLeft(initial): (acc, s) =>\n      val (id, seen) = acc\n      (id + 1, seen + (s -> id))\n\n  def asEdges(k: String, v: String) =\n    val t = (lookup(k), lookup(v))\n    t :: t.swap :: Nil\n\n  val v = lookup.values.to(BitSet)\n  val nodes = v.unsorted.map(id => id -> BitSet(id)).toMap\n  val edges =\n    for\n      (k, vs) <- alist.toSet\n      v <- vs\n      e <- asEdges(k, v)\n    yield\n      e\n\n  val w = edges\n    .groupBy((v, _) => v)\n    .view\n    .mapValues: m =>\n      m\n        .groupBy((_, v) => v)\n        .view\n        .mapValues(_ => 1)\n        .toMap\n    .toMap\n  Graph(v, nodes, w)\n\nclass MostConnected(\n  totalWeights: Map[Id, Int],\n  queue: TreeSet[MostConnected.Entry]\n):\n\n  def pop =\n    val id = queue.head.id\n    id -> MostConnected(totalWeights - id, queue.tail)\n\n  def expand(z: Id, explore: Vertices, w: Weight) =\n    val connectedEdges =\n      w(z).view.filterKeys(explore)\n    var totalWeights0 = totalWeights\n    var queue0 = queue\n    for (id, w) <- connectedEdges do\n      val w1 = totalWeights0.getOrElse(id, 0) + w\n      totalWeights0 += id -> w1\n      queue0 += MostConnected.Entry(id, w1)\n    MostConnected(totalWeights0, queue0)\n  end expand\n\nend MostConnected\n\nobject MostConnected:\n  def empty = MostConnected(Map.empty, TreeSet.empty)\n  given Ordering[Entry] = (e1, e2) =>\n    val first = e2.weight.compareTo(e1.weight)\n    if first == 0 then e2.id.compareTo(e1.id) else first\n  class Entry(val id: Id, val weight: Int):\n    override def hashCode: Int = id\n    override def equals(that: Any): Boolean = that match\n      case that: Entry => id == that.id\n      case _ => false\n\ncase class Graph(v: Vertices, nodes: Map[Id, Vertices], w: Weight):\n  def cutOfThePhase(t: Id) = Graph.Cut(t = t, edges = w(t))\n\n  def partition(cut: Graph.Cut): (Vertices, Vertices) =\n    (nodes(cut.t), (v - cut.t).flatMap(nodes))\n\n  def shrink(s: Id, t: Id): Graph =\n    def fetch(x: Id) =\n      w(x).view.filterKeys(y => y != s && y != t)\n\n    val prunedW = (w - t).view.mapValues(_ - t).toMap\n\n    val fromS = fetch(s).toMap\n    val fromT = fetch(t).map: (y, w0) =>\n      y -> (fromS.getOrElse(y, 0) + w0)\n    val mergedWeights = fromS ++ fromT\n\n    val reverseMerged = mergedWeights.view.map: (y, w0) =>\n      y -> (prunedW(y) + (s -> w0))\n\n    val v1 = v - t // 5.\n    val w1 = prunedW + (s -> mergedWeights) ++ reverseMerged\n    val nodes1 = nodes - t + (s -> (nodes(s) ++ nodes(t)))\n    Graph(v1, nodes1, w1)\n  end shrink\n\nobject Graph:\n  def emptyCut = Cut(t = -1, edges = Map.empty)\n\n  case class Cut(t: Id, edges: Map[Id, Int]):\n    lazy val weight: Int = edges.values.sum\n\ndef minimumCutPhase(g: Graph) =\n  val a = g.v.head\n  var A = a :: Nil\n  var explore = g.v - a\n  var mostConnected =\n    MostConnected.empty.expand(a, explore, g.w)\n  while explore.nonEmpty do\n    val (z, rest) = mostConnected.pop\n    A ::= z\n    explore -= z\n    mostConnected = rest.expand(z, explore, g.w)\n  val t :: s :: _ = A: @unchecked\n  (g.shrink(s, t), g.cutOfThePhase(t))\n\n/** See Stoer-Wagner min cut algorithm\n  * https://dl.acm.org/doi/pdf/10.1145/263867.263872\n  */\ndef minimumCut(g: Graph) =\n  var g0 = g\n  var min = (g, Graph.emptyCut)\n  while g0.v.size > 1 do\n    val (g1, cutOfThePhase) = minimumCutPhase(g0)\n    if cutOfThePhase.weight < min(1).weight\n      || min(1).weight == 0 // initial case\n    then\n      min = (g0, cutOfThePhase)\n    g0 = g1\n  min\n')),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Beware that Safari is not able to run this solution efficiently (Chrome and Firefox are ok)")),(0,i.kt)(s.Z,{puzzle:"day25-part1",year:"2023",mdxType:"Solver"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"There is no part 2 for this day!")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2023/Day25.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day25.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}h.isMDXComponent=!0}}]);