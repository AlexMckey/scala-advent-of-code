"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7784],{4874:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>m,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var n=t(7462),i=(t(7294),t(3905)),l=t(6340);const o={},r="Day 2: Cube Conundrum",s={unversionedId:"2023/puzzles/day02",id:"2023/puzzles/day02",title:"Day 2: Cube Conundrum",description:"by @bishabosha",source:"@site/target/mdoc/2023/puzzles/day02.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day02",permalink:"/scala-advent-of-code/2023/puzzles/day02",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day02.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 1: Trebuchet?!",permalink:"/scala-advent-of-code/2023/puzzles/day01"},next:{title:"Day 1: Calorie Counting",permalink:"/scala-advent-of-code/2022/puzzles/day01"}},m={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Framework",id:"framework",level:4},{value:"Parsing",id:"parsing",level:4},{value:"Summary",id:"summary",level:4},{value:"Part 2",id:"part-2",level:3},{value:"Summary",id:"summary-1",level:4},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:u};function c(e){let{components:a,...t}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-2-cube-conundrum"},"Day 2: Cube Conundrum"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/2"},"https://adventofcode.com/2023/day/2")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Iterate over each line of the input."),(0,i.kt)("li",{parentName:"ol"},"Parse each line into a game"),(0,i.kt)("li",{parentName:"ol"},"Summarise each game (using the appropriate summary function for ",(0,i.kt)("inlineCode",{parentName:"li"},"part1")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"part2"),")")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"part1")," requires to check first if any hand in a game (by removing cubes) will cause a negative cube count, compared to the initial configuration of ",(0,i.kt)("em",{parentName:"li"},'"possible"')," cubes. If there are no negative counts, then the game is possible and summarise as the game's id, otherwise summarise as zero."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"part2")," requires to find the maximum cube count of each color in any given hand, and then summarise as the product of those cube counts.")),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"Sum the total of summaries")),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("h4",{id:"framework"},"Framework"),(0,i.kt)("p",null,"The main driver for solving will be the ",(0,i.kt)("inlineCode",{parentName:"p"},"solution")," function.\nIn a single pass over the puzzle ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," it will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"iterate through each line,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parse")," each line into a game,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"summarise")," each game as an ",(0,i.kt)("inlineCode",{parentName:"li"},"Int"),","),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sum")," the total of summaries.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Colors(color: String, count: Int)\ncase class Game(id: Int, hands: List[List[Colors]])\ntype Summary = Game => Int\n\ndef solution(input: String, summarise: Summary): Int =\n  input.linesIterator.map(parse andThen summarise).sum\n\ndef parse(line: String): Game = ???\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"part1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"part2")," will use this framework, plugging in the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"summarise")," function."),(0,i.kt)("h4",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"Let's fill in the ",(0,i.kt)("inlineCode",{parentName:"p"},"parse")," function as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parseColors(pair: String): Colors =\n  val Array(count0, color0) = pair.split(" ")\n  Colors(color = color0, count = count0.toInt)\n\ndef parse(line: String): Game =\n  val Array(game0, hands) = line.split(": "): @unchecked\n  val Array(_, id) = game0.split(" "): @unchecked\n  val hands0 = hands.split("; ").toList\n  val hands1 = hands0.map(_.split(", ").map(parseColors).toList)\n  Game(id = id.toInt, hands = hands1)\n')),(0,i.kt)("h4",{id:"summary"},"Summary"),(0,i.kt)("p",null,"As described above, to summarise each game, we evaluate it as a ",(0,i.kt)("inlineCode",{parentName:"p"},"possibleGame"),", where if it is a ",(0,i.kt)("inlineCode",{parentName:"p"},"validGame")," summarise as the game's ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("p",null,"A game is valid if for all ",(0,i.kt)("inlineCode",{parentName:"p"},"hands")," in the game, all the colors in each hand has a ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," that is less-than or equal-to the count of same color from the ",(0,i.kt)("inlineCode",{parentName:"p"},"possibleCubes")," configuration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val possibleCubes = Map(\n  "red" -> 12,\n  "green" -> 13,\n  "blue" -> 14,\n)\n\ndef validGame(game: Game): Boolean =\n  game.hands.forall: hand =>\n    hand.forall:\n      case Colors(color, count) =>\n        count <= possibleCubes.getOrElse(color, 0)\n\nval possibleGame: Summary =\n  case game if validGame(game) => game.id\n  case _ => 0\n\ndef part1(input: String): Int = solution(input, possibleGame)\n')),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("h4",{id:"summary-1"},"Summary"),(0,i.kt)("p",null,"In part 2, the summary of a game requires us to find the ",(0,i.kt)("inlineCode",{parentName:"p"},"minimumCubes")," necessary to make a possible game.\nWhat this means is for any given game, across all hands calculating the maximum cubes drawn for each color."),(0,i.kt)("p",null,"In Scala we can accumulate the maximum counts for each cube in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," from color to count.\nTake the initial maximums as all zero:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val initial = Seq("red", "green", "blue").map(_ -> 0).toMap\n')),(0,i.kt)("p",null,"Then for each game we can compute the maximum cubes drawn in each game as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def minimumCubes(game: Game): Int =\n  var maximums = initial\n  for\n    hand <- game.hands\n    Colors(color, count) <- hand\n  do\n    maximums += (color -> (maximums(color) `max` count))\n  maximums.values.product\n")),(0,i.kt)("p",null,"Finally we can complete the solution by using ",(0,i.kt)("inlineCode",{parentName:"p"},"minimumCubes")," to summarise each game:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int = solution(input, minimumCubes)\n")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Colors(color: String, count: Int)\ncase class Game(id: Int, hands: List[List[Colors]])\ntype Summary = Game => Int\n\ndef parseColors(pair: String): Colors =\n  val Array(count0, color0) = pair.split(" ")\n  Colors(color = color0, count = count0.toInt)\n\ndef parse(line: String): Game =\n  val Array(game0, hands) = line.split(": "): @unchecked\n  val Array(_, id) = game0.split(" "): @unchecked\n  val hands0 = hands.split("; ").toList\n  val hands1 = hands0.map(_.split(", ").map(parseColors).toList)\n  Game(id = id.toInt, hands = hands1)\n\ndef solution(input: String, summarise: Summary): Int =\n  input.linesIterator.map(parse andThen summarise).sum\n\nval possibleCubes = Map(\n  "red" -> 12,\n  "green" -> 13,\n  "blue" -> 14,\n)\n\ndef validGame(game: Game): Boolean =\n  game.hands.forall: hand =>\n    hand.forall:\n      case Colors(color, count) =>\n        count <= possibleCubes.getOrElse(color, 0)\n\nval possibleGame: Summary =\n  case game if validGame(game) => game.id\n  case _ => 0\n\ndef part1(input: String): Int = solution(input, possibleGame)\n\nval initial = Seq("red", "green", "blue").map(_ -> 0).toMap\n\ndef minimumCubes(game: Game): Int =\n  var maximums = initial\n  for\n    hand <- game.hands\n    Colors(color, count) <- hand\n  do\n    maximums += (color -> (maximums(color) `max` count))\n  maximums.values.product\n\ndef part2(input: String): Int = solution(input, minimumCubes)\n')),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1-1"},"Part 1"),(0,i.kt)(l.Z,{puzzle:"day02-part1",year:"2023",mdxType:"Solver"}),(0,i.kt)("h4",{id:"part-2-1"},"Part 2"),(0,i.kt)(l.Z,{puzzle:"day02-part2",year:"2023",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2023/src/test/scala/Day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gist.github.com/CJSmith-0141/b7a43228aeadfe2169cd163d38e732b3"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/CJSmith-0141"},"CJ Smith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2023/blob/main/src/main/scala/solutions/day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2023/day2/Day2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/kbielefe/advent-of-code/blob/edf8e706229a5f3785291824f26778de8a583c35/2023/src/main/scala/2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/kbielefe"},"Karl Bielefeldt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/susliko/adventofcode/blob/master/2023/day2/cubeCondurum.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/susliko"},"Vail Markoukin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2023/blob/main/day02/cube-conundrum.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/02.worksheet.sc#L87"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2023/src/main/scala/Day2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code_2023/blob/main/src/main/scala/days/day02/DayTwo.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/pkarthick/AdventOfCode/blob/master/2023/scala/src/main/scala/day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/pkarthick"},"Karthick Pachiappan"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}c.isMDXComponent=!0}}]);