"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[120],{6279:function(e,n,a){a.r(n),a.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return u},default:function(){return h}});var t=a(7462),r=a(3366),i=(a(7294),a(3905)),s=a(5623),o=["components"],l={},c="Day 16: Packet Decoder",p={unversionedId:"puzzles/day16",id:"puzzles/day16",isDocsHomePage:!1,title:"Day 16: Packet Decoder",description:"by @tgodzik",source:"@site/target/mdoc/puzzles/day16.md",sourceDirName:"puzzles",slug:"/puzzles/day16",permalink:"/scala-advent-of-code/puzzles/day16",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day16.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 15: Chiton",permalink:"/scala-advent-of-code/puzzles/day15"},next:{title:"Day 17: Trick Shot",permalink:"/scala-advent-of-code/puzzles/day17"}},u=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Part1: You&#39;ve got mail!",id:"part1-youve-got-mail",children:[{value:"Full solution",id:"full-solution",children:[],level:3}],level:2},{value:"Part 2: The Elven calculus",id:"part-2-the-elven-calculus",children:[{value:"Full solution",id:"full-solution-1",children:[],level:3}],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],d={toc:u};function h(e){var n=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-16-packet-decoder"},"Day 16: Packet Decoder"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tgodzik"},"@tgodzik")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/16"},"https://adventofcode.com/2021/day/16")),(0,i.kt)("h2",{id:"part1-youve-got-mail"},"Part1: You've got mail!"),(0,i.kt)("p",null,"It seems that we can split our problem into two parts. First, we need to parse\nthe example into structures that we can later use to calculate our results."),(0,i.kt)("p",null,"Let's start with defining the data structures to use:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum Packet(version: Int, typeId: Int):\n  case Literal(version: Int, value: Long) extends Packet(version, 4)\n  case Operator(version: Int, typeId: Int, exprs: List[Packet]) extends Packet(version, typeId)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Packet.Literal")," will represent simple literal packets, that contain only a\nvalue. We are using Long, just in case of large integer numbers based on the\nexperience with previous Advent of Code puzzles."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Packet.Operator")," will represent all the other operators that can contain other\npackets."),(0,i.kt)("p",null,"Now we need to map our input to these structures."),(0,i.kt)("p",null,"Let's start by mapping the hexadecimal input to a list of chars that we can\nanalyze easier when checking for packets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val hexadecimalMapping =\n  Map(\n    '0' -> \"0000\",\n    '1' -> \"0001\",\n    '2' -> \"0010\",\n    '3' -> \"0011\",\n    '4' -> \"0100\",\n    '5' -> \"0101\",\n    '6' -> \"0110\",\n    '7' -> \"0111\",\n    '8' -> \"1000\",\n    '9' -> \"1001\",\n    'A' -> \"1010\",\n    'B' -> \"1011\",\n    'C' -> \"1100\",\n    'D' -> \"1101\",\n    'E' -> \"1110\",\n    'F' -> \"1111\"\n  )\n\ndef parse(input: String) =\n  val byteInput = input.toList.flatMap(hex => hexadecimalMapping(hex).toCharArray)\n  ...\n")),(0,i.kt)("p",null,"This will produce the input that we have seen in the puzzle description:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"110100101111111000101000")),(0,i.kt)("p",null,"Since we've got that we can start defining our function for decoding packets. We\nfirst define parsing of elements common to all the packets, which is the version\nand the type ID. Based on the type id we can see how we need to parse the rest\nof the data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type BinaryData = List[Char]\n\n// helper function to read binary data 01101 to decimal 13\ndef toInt(chars: BinaryData): Int =\n  Integer.parseInt(chars.mkString, 2)\n\n// helper function to read binary data 01101 to decimal 13, but in a Long format\ndef toLong(chars: BinaryData): Long =\n  java.lang.Long.parseLong(chars.mkString, 2)\n\ndef readLiteralBody(input: BinaryData): (Long, BinaryData) = ???\ndef readOperatorBody(input: BinaryData): (List[Packet], BinaryData) = ???\n\ndef decodePacket(packet: BinaryData): (Packet, BinaryData) =\n  val (versionBits, rest) = packet.splitAt(3)\n  val version = toInt(versionBits)\n  val (typeBits, body) = rest.splitAt(3)\n  val tpe = toInt(typeBits)\n\n  tpe match\n    case 4 =>\n      val (value, remaining) = readLiteralBody(body, Nil)\n      (Packet.Literal(version, value), remaining)\n    case otherTpe =>\n      val (values, remaining) = readOperatorBody(body)\n      (Packet.Operator(version, otherTpe, values), remaining)\n  end match\nend decodePacket\n")),(0,i.kt)("p",null,"We use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"splitAt"),", which gives us the ability to split the input\ninto the part that we need, for example 3 bits for version, and the rest of the\npacket data. This way we can read the version and typeId, pattern match on the\nlatter and use proper logic for reading in each case. We can then create our new\nstructures. We also defined a helper type ",(0,i.kt)("inlineCode",{parentName:"p"},"BinaryData"),", since we will be using\nit throughout the puzzle. What remains is defining ",(0,i.kt)("inlineCode",{parentName:"p"},"readLiteralBody")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"readOperatorBody"),". You might notice that we return additional ",(0,i.kt)("inlineCode",{parentName:"p"},"BinaryData")," from\neach function. This is because we will be later able to use it to analyze the\noutput further in a recursive manner, but we'll get back to it."),(0,i.kt)("p",null,"Let's start with the first undefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"readLiteralBody"),". In the\ndescription we read that the body of the literal consists of segments of 5 bits,\nwhere the last segment will start with 0 and all the others with 1. The\nremaining 4 bits can be used to construct a number. We can create a recursive\nfunction that will handle it perfectly!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"@tailrec\ndef readLiteralBody(tail: BinaryData, numAcc: BinaryData): (Long, BinaryData) =\n  val (num, rest) = tail.splitAt(5)\n  if num(0) == '1' then readLiteralBody(rest, numAcc.appendedAll(num.drop(1)))\n  else\n    val bits = numAcc.appendedAll(num.drop(1))\n    (toLong(bits), rest)\nend readLiteralBody\n")),(0,i.kt)("p",null,"In each step we read 5 bits from the input and check if we should finish. If the\nfirst bit is ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," then we know that we can append the last 5 bits and return the\ncurrent result. In case the first bit is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", we need to repeat the step once\nmore on the remaining bits."),(0,i.kt)("p",null,"The harder part will be defining ",(0,i.kt)("inlineCode",{parentName:"p"},"readOperatorBody")," since we know that operator\npackets can contain other packets and those packets can also be operators! This\nmeans we will need to apply a recursive approach:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def readOperatorBody(current: BinaryData): (List[Packet], BinaryData) =\n  val (lenId, rest) = current.splitAt(1)\n\n  @tailrec\n  def readMaxBits(\n      current: BinaryData,\n      remaining: Int,\n      acc: List[Packet]\n  ): (List[Packet], BinaryData) =\n    if remaining == 0 then (acc, current)\n    else\n      val (newExpr, rest) = decodePacket(current)\n      readMaxBits(rest, remaining - (current.size - rest.size), acc :+ newExpr)\n\n  @tailrec\n  def readMaxPackets(\n      current: BinaryData,\n      remaining: Int,\n      acc: List[Packet]\n  ): (List[Packet], BinaryData) =\n    if remaining == 0 then (acc, current)\n    else\n      val (newExpr, rest) = decodePacket(current)\n      readMaxPackets(rest, remaining - 1, acc :+ newExpr)\n\n  // read based on length\n  if lenId(0) == '0' then\n    val (size, packets) = rest.splitAt(15)\n    readMaxBits(packets, toInt(size), Nil)\n  // read based on number of packages\n  else\n    val (size, packets) = rest.splitAt(11)\n    readMaxPackets(packets, toInt(size), Nil)\n  end match\nend readOperatorBody\n")),(0,i.kt)("p",null,"In the above function we first check the first bit of the operator body, which\ntells us how we should check the rest of the body."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"if the bit is ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," it means that the next 15 bits can be turned into a number,\nthat will define how many of the further bits are the subpackets of the\noperator.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"if the bit is ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," it means that the next 11 bits can be turned into a number,\nthat will define how many subpackets should belong to the operator."))),(0,i.kt)("p",null,"We defined two helper recursive functions ",(0,i.kt)("inlineCode",{parentName:"p"},"readMaxBits")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"readMaxPackets"),"\nwhich will check if the stopping condition (either max bits read or max packets\nread) is achieved or read a new packet using recursively the ",(0,i.kt)("inlineCode",{parentName:"p"},"decodePacket"),"\nfunction otherwise. At the end they will both return a list of packets, that we\ncan later use to put into the operator packet, and the remaining input that we\nmight need to check for more packets."),(0,i.kt)("p",null,"This should already allow us to create a full structure and what remains is\nadding a function that can add up all the versions. We can add that function to\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"Packet")," enum and sum it all recursively."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def versionSum: Int =\n    this match\n      case Literal(version, _)     => version\n      case Operator(version, exprs, _) => version + exprs.map(_.versionSum).sum\n")),(0,i.kt)("p",null,"That's it! We should be able to solve the part 1."),(0,i.kt)("h3",{id:"full-solution"},"Full solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"package day16\n\nimport scala.util.Using\nimport scala.io.Source\nimport scala.annotation.tailrec\n\n@main def part1(): Unit =\n  println(s\"The solution is ${part1(readInput())}\")\n\ndef readInput(): String =\n  Using.resource(Source.fromFile(\"input/day16\"))(_.mkString)\n\nval hexadecimalMapping =\n  Map(\n    '0' -> \"0000\",\n    '1' -> \"0001\",\n    '2' -> \"0010\",\n    '3' -> \"0011\",\n    '4' -> \"0100\",\n    '5' -> \"0101\",\n    '6' -> \"0110\",\n    '7' -> \"0111\",\n    '8' -> \"1000\",\n    '9' -> \"1001\",\n    'A' -> \"1010\",\n    'B' -> \"1011\",\n    'C' -> \"1100\",\n    'D' -> \"1101\",\n    'E' -> \"1110\",\n    'F' -> \"1111\"\n  )\n\nenum Packet(version: Int, typeId: Int):\n  case Literal(version: Int, value: Long) extends Packet(version, 4)\n  case Operator(version: Int, typeId: Int, exprs: List[Packet]) extends Packet(version, typeId)\n  def versionSum: Int =\n    this match\n      case Literal(version, _)         => version\n      case Operator(version, _, exprs) => version + exprs.map(_.versionSum).sum\n\ntype BinaryData = List[Char]\n\n// helper function to read binary data 01101 to decimal 13\ndef toInt(chars: BinaryData): Int =\n  Integer.parseInt(chars.mkString, 2)\n\n// helper function to read binary data 01101 to decimal 13, but in a Long format\ndef toLong(chars: BinaryData): Long =\n  java.lang.Long.parseLong(chars.mkString, 2)\n\n@tailrec\ndef readLiteralBody(tail: BinaryData, numAcc: BinaryData): (Long, BinaryData) =\n  val (num, rest) = tail.splitAt(5)\n  if num(0) == '1' then readLiteralBody(rest, numAcc.appendedAll(num.drop(1)))\n  else\n    val bits = numAcc.appendedAll(num.drop(1))\n    (toLong(bits), rest)\nend readLiteralBody\n\ndef readOperatorBody(current: BinaryData): (List[Packet], BinaryData) =\n  val (lenId, rest) = current.splitAt(1)\n\n  @tailrec\n  def readMaxBits(\n      current: BinaryData,\n      remaining: Int,\n      acc: List[Packet]\n  ): (List[Packet], BinaryData) =\n    if remaining == 0 then (acc, current)\n    else\n      val (newExpr, rest) = decodePacket(current)\n      readMaxBits(rest, remaining - (current.size - rest.size), acc :+ newExpr)\n\n  @tailrec\n  def readMaxPackets(\n      current: BinaryData,\n      remaining: Int,\n      acc: List[Packet]\n  ): (List[Packet], BinaryData) =\n    if remaining == 0 then (acc, current)\n    else\n      val (newExpr, rest) = decodePacket(current)\n      readMaxPackets(rest, remaining - 1, acc :+ newExpr)\n\n  lenId match\n    // read based on length\n    case List('0') =>\n      val (size, packets) = rest.splitAt(15)\n      readMaxBits(packets, toInt(size), Nil)\n\n    // read based on number of packages\n    case _ =>\n      val (size, packets) = rest.splitAt(11)\n      readMaxPackets(packets, toInt(size), Nil)\n  end match\nend readOperatorBody\n\ndef decodePacket(input: BinaryData): (Packet, BinaryData) =\n  val (versionBits, rest) = input.splitAt(3)\n  val version = toInt(versionBits)\n  val (typeBits, body) = rest.splitAt(3)\n  val tpe = toInt(typeBits)\n\n  tpe match\n    case 4 =>\n      val (value, remaining) = readLiteralBody(body, Nil)\n      (Packet.Literal(version, value), remaining)\n    case otherTpe =>\n      val (values, remaining) = readOperatorBody(body)\n      (Packet.Operator(version, otherTpe, values), remaining)\n  end match\nend decodePacket\n\ndef parse(input: String) =\n  val number = input.toList.flatMap(hex => hexadecimalMapping(hex).toCharArray)\n  val (operator, _) = decodePacket(number)\n  operator\n\ndef part1(input: String) =\n  val packet = parse(input)\n  packet.versionSum\n")),(0,i.kt)(s.Z,{puzzle:"day16-part1",mdxType:"Solver"}),(0,i.kt)("h2",{id:"part-2-the-elven-calculus"},"Part 2: The Elven calculus"),(0,i.kt)("p",null,"Turns out that operator packets are actual mathematical operators and we can use\nthe type ID to distinguish them!"),(0,i.kt)("p",null,"We need to improve our structure to better show the different mathematical\noperators. For that we define additional enum cases instead of a single\n",(0,i.kt)("inlineCode",{parentName:"p"},"Operator")," case."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum Packet(version: Int, typeId: Int):\n  case Sum(version: Int, exprs: List[Packet]) extends Packet(version, 0)\n  case Product(version: Int, exprs: List[Packet]) extends Packet(version, 1)\n  case Minimum(version: Int, exprs: List[Packet]) extends Packet(version, 2)\n  case Maximum(version: Int, exprs: List[Packet]) extends Packet(version, 3)\n  case Literal(version: Int, literalValue: Long) extends Packet(version, 4)\n  case GreaterThan(version: Int, lhs: Packet, rhs: Packet) extends Packet(version, 5)\n  case LesserThan(version: Int, lhs: Packet, rhs: Packet) extends Packet(version, 6)\n  case Equals(version: Int, lhs: Packet, rhs: Packet) extends Packet(version, 7)\n")),(0,i.kt)("p",null,"We will also need to modify the way we create these operators:"),(0,i.kt)("p",null,"So instead of"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"      val (values, remaining) = readOperatorBody(body)\n      (Packet.Operator(version, otherTpe, values), remaining)\n")),(0,i.kt)("p",null,"we will need to write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"     val (values, remaining) = readOperatorBody(body)\n      otherTpe match\n        case 0 => (Packet.Sum(version, values), remaining)\n        case 1 => (Packet.Product(version, values), remaining)\n        case 2 => (Packet.Minimum(version, values), remaining)\n        case 3 => (Packet.Maximum(version, values), remaining)\n        case 5 => (Packet.GreaterThan(version, values(0), values(1)), remaining)\n        case 6 => (Packet.LesserThan(version, values(0), values(1)), remaining)\n        case 7 => (Packet.Equals(version, values(0), values(1)), remaining)\n")),(0,i.kt)("p",null,"This makes our structure accurately show the mathematical computation that is\nconstructed from the packets. The last remaining step is to create a function\nthat will calculate the equation. We can do it similarly to the ",(0,i.kt)("inlineCode",{parentName:"p"},"versionsSum"),"\nfunction in the previous part:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def value: Long =\n    this match\n      case Sum(version, exprs)            => exprs.map(_.value).sum\n      case Product(version, exprs)        => exprs.map(_.value).reduce(_ * _)\n      case Minimum(version, exprs)        => exprs.map(_.value).min\n      case Maximum(version, exprs)        => exprs.map(_.value).max\n      case Literal(version, value)        => value\n      case GreaterThan(version, lhs, rhs) => if lhs.value > rhs.value then 1 else 0\n      case LesserThan(version, lhs, rhs)  => if lhs.value < rhs.value then 1 else 0\n      case Equals(version, lhs, rhs)      => if lhs.value == rhs.value then 1 else 0\n")),(0,i.kt)("h3",{id:"full-solution-1"},"Full solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'package day16\n\nimport scala.util.Using\nimport scala.io.Source\nimport scala.annotation.tailrec\n\n@main def part1(): Unit =\n  println(s"The solution is ${part1(readInput())}")\n\n@main def part2(): Unit =\n  println(s"The solution is ${part2(readInput())}")\n\ndef readInput(): String =\n  Using.resource(Source.fromFile("input/day16"))(_.mkString)\n\nval hexadecimalMapping =\n  Map(\n    \'0\' -> "0000",\n    \'1\' -> "0001",\n    \'2\' -> "0010",\n    \'3\' -> "0011",\n    \'4\' -> "0100",\n    \'5\' -> "0101",\n    \'6\' -> "0110",\n    \'7\' -> "0111",\n    \'8\' -> "1000",\n    \'9\' -> "1001",\n    \'A\' -> "1010",\n    \'B\' -> "1011",\n    \'C\' -> "1100",\n    \'D\' -> "1101",\n    \'E\' -> "1110",\n    \'F\' -> "1111"\n  )\n\n/*\n * Structures for all possible operators\n */\nenum Packet(version: Int, typeId: Int):\n  case Sum(version: Int, exprs: List[Packet]) extends Packet(version, 0)\n  case Product(version: Int, exprs: List[Packet]) extends Packet(version, 1)\n  case Minimum(version: Int, exprs: List[Packet]) extends Packet(version, 2)\n  case Maximum(version: Int, exprs: List[Packet]) extends Packet(version, 3)\n  case Literal(version: Int, literalValue: Long) extends Packet(version, 4)\n  case GreaterThan(version: Int, lhs: Packet, rhs: Packet) extends Packet(version, 5)\n  case LesserThan(version: Int, lhs: Packet, rhs: Packet) extends Packet(version, 6)\n  case Equals(version: Int, lhs: Packet, rhs: Packet) extends Packet(version, 7)\n\n  def versionSum: Int =\n    this match\n      case Sum(version, exprs)            => version + exprs.map(_.versionSum).sum\n      case Product(version, exprs)        => version + exprs.map(_.versionSum).sum\n      case Minimum(version, exprs)        => version + exprs.map(_.versionSum).sum\n      case Maximum(version, exprs)        => version + exprs.map(_.versionSum).sum\n      case Literal(version, value)        => version\n      case GreaterThan(version, lhs, rhs) => version + lhs.versionSum + rhs.versionSum\n      case LesserThan(version, lhs, rhs)  => version + lhs.versionSum + rhs.versionSum\n      case Equals(version, lhs, rhs)      => version + lhs.versionSum + rhs.versionSum\n\n  def value: Long =\n    this match\n      case Sum(version, exprs)            => exprs.map(_.value).sum\n      case Product(version, exprs)        => exprs.map(_.value).reduce(_ * _)\n      case Minimum(version, exprs)        => exprs.map(_.value).min\n      case Maximum(version, exprs)        => exprs.map(_.value).max\n      case Literal(version, value)        => value\n      case GreaterThan(version, lhs, rhs) => if lhs.value > rhs.value then 1 else 0\n      case LesserThan(version, lhs, rhs)  => if lhs.value < rhs.value then 1 else 0\n      case Equals(version, lhs, rhs)      => if lhs.value == rhs.value then 1 else 0\nend Packet\n\ntype BinaryData = List[Char]\n\ninline def toInt(chars: BinaryData): Int =\n  Integer.parseInt(chars.mkString, 2)\n\ninline def toLong(chars: BinaryData): Long =\n  java.lang.Long.parseLong(chars.mkString, 2)\n\n@tailrec\ndef readLiteralBody(tail: BinaryData, numAcc: BinaryData): (Long, BinaryData) =\n  val (num, rest) = tail.splitAt(5)\n  if num(0) == \'1\' then readLiteralBody(rest, numAcc.appendedAll(num.drop(1)))\n  else\n    val bits = numAcc.appendedAll(num.drop(1))\n    (toLong(bits), rest)\nend readLiteralBody\n\ndef readOperatorBody(current: BinaryData): (List[Packet], BinaryData) =\n  val (lenId, rest) = current.splitAt(1)\n\n  @tailrec\n  def readMaxBits(\n      current: BinaryData,\n      remaining: Int,\n      acc: List[Packet]\n  ): (List[Packet], BinaryData) =\n    if remaining == 0 then (acc, current)\n    else\n      val (newExpr, rest) = decodePacket(current)\n      readMaxBits(rest, remaining - (current.size - rest.size), acc :+ newExpr)\n\n  @tailrec\n  def readMaxPackets(\n      current: BinaryData,\n      remaining: Int,\n      acc: List[Packet]\n  ): (List[Packet], BinaryData) =\n    if remaining == 0 then (acc, current)\n    else\n      val (newExpr, rest) = decodePacket(current)\n      readMaxPackets(rest, remaining - 1, acc :+ newExpr)\n\n  lenId match\n    // read based on length\n    case List(\'0\') =>\n      val (size, packets) = rest.splitAt(15)\n      readMaxBits(packets, toInt(size), Nil)\n\n    // read based on number of packages\n    case _ =>\n      val (size, packets) = rest.splitAt(11)\n      readMaxPackets(packets, toInt(size), Nil)\n  end match\nend readOperatorBody\n\ndef decodePacket(packet: BinaryData): (Packet, BinaryData) =\n  val (versionBits, rest) = packet.splitAt(3)\n  val version = toInt(versionBits)\n  val (typeBits, body) = rest.splitAt(3)\n  val tpe = toInt(typeBits)\n\n  tpe match\n    case 4 =>\n      val (value, remaining) = readLiteralBody(body, Nil)\n      (Packet.Literal(version, value), remaining)\n    case otherTpe =>\n      val (values, remaining) = readOperatorBody(body)\n      otherTpe match\n        case 0 => (Packet.Sum(version, values), remaining)\n        case 1 => (Packet.Product(version, values), remaining)\n        case 2 => (Packet.Minimum(version, values), remaining)\n        case 3 => (Packet.Maximum(version, values), remaining)\n        case 5 => (Packet.GreaterThan(version, values(0), values(1)), remaining)\n        case 6 => (Packet.LesserThan(version, values(0), values(1)), remaining)\n        case 7 => (Packet.Equals(version, values(0), values(1)), remaining)\n  end match\nend decodePacket\n\ndef parse(input: String) =\n  val number = input.toList.flatMap(hex => hexadecimalMapping(hex).toCharArray)\n  val (operator, _) = decodePacket(number)\n  operator\n\ndef part1(input: String) =\n  val packet = parse(input)\n  packet.versionSum\n\ndef part2(input: String) =\n  val packet = parse(input)\n  packet.value\nend part2\n\n')),(0,i.kt)("p",null,"You might have noticed that we had to slightly modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"versionsSum")," function\nto work with our new structure."),(0,i.kt)(s.Z,{puzzle:"day16-part2",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day16/Day16.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),".")),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page."))}h.isMDXComponent=!0}}]);