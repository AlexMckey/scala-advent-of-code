"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4404],{2959:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),l=(a(7294),a(3905)),i=a(6340);const o={},r="Day 3: Gear Ratios",s={unversionedId:"2023/puzzles/day03",id:"2023/puzzles/day03",title:"Day 3: Gear Ratios",description:"by @bishabosha and @iusildra",source:"@site/target/mdoc/2023/puzzles/day03.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day03",permalink:"/scala-advent-of-code/2023/puzzles/day03",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day03.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 2: Cube Conundrum",permalink:"/scala-advent-of-code/2023/puzzles/day02"},next:{title:"Day 4: Scratchcards",permalink:"/scala-advent-of-code/2023/puzzles/day04"}},m={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Global",id:"global",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:p};function u(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"day-3-gear-ratios"},"Day 3: Gear Ratios"),(0,l.kt)("p",null,"by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")," and ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/iusildra"},"@iusildra")),(0,l.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/3"},"https://adventofcode.com/2023/day/3")),(0,l.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,l.kt)("p",null,"The solution models the input as a grid of numbers and symbols."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Define some models to represent the input:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"case class Coord(x: Int, y: Int)")," to represent one coordinate on the grid"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"case class Symbol(sym: String, pos: Coord)")," to represent one symbol and its location"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"case class PartNumber(value: Int, start: Coord, end: Coord)")," to represent one number and its starting/ending location"))),(0,l.kt)("li",{parentName:"ol"},"Parse the input to create a dense collection of symbols and numbers"),(0,l.kt)("li",{parentName:"ol"},"Separate the symbols from the numbers"),(0,l.kt)("li",{parentName:"ol"},"Then summarise the whole grid as follows:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"in ",(0,l.kt)("inlineCode",{parentName:"li"},"part1"),", find all ",(0,l.kt)("inlineCode",{parentName:"li"},"numbers")," adjacent to a ",(0,l.kt)("inlineCode",{parentName:"li"},"symbol"),", and sum the total of the resulting ",(0,l.kt)("inlineCode",{parentName:"li"},"number")," values,"),(0,l.kt)("li",{parentName:"ul"},"in ",(0,l.kt)("inlineCode",{parentName:"li"},"part2"),",",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Find all ",(0,l.kt)("inlineCode",{parentName:"li"},"numbers")," adjacent to a ",(0,l.kt)("inlineCode",{parentName:"li"},"symbol")," whose ",(0,l.kt)("inlineCode",{parentName:"li"},"char")," value is ",(0,l.kt)("inlineCode",{parentName:"li"},"*")),(0,l.kt)("li",{parentName:"ol"},"Filter out the ",(0,l.kt)("inlineCode",{parentName:"li"},"*")," symbol with less/more than 2 adjacent numbers"),(0,l.kt)("li",{parentName:"ol"},"For each ",(0,l.kt)("inlineCode",{parentName:"li"},"*")," symbol remaining, take the product of its two number values"),(0,l.kt)("li",{parentName:"ol"},"Sum the resulting products"))),(0,l.kt)("li",{parentName:"ul"},"a symbol is adjacent to a number (and vice-versa) if that symbol is inside the number's bounding box on the grid at 1 unit away (see manhattan distance)")))),(0,l.kt)("h3",{id:"global"},"Global"),(0,l.kt)("p",null,"We want a convenient way to represent a coordinate to be able to compute whether one element is within the bounding box of another."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"case class Coord(x: Int, y: Int):\n  def within(start: Coord, end: Coord) =\n    if y < start.y || y > end.y then false\n    else if x < start.x || x > end.x then false\n    else true\n")),(0,l.kt)("p",null,"We also want to easily distinguish a ",(0,l.kt)("inlineCode",{parentName:"p"},"Symbol")," from a ",(0,l.kt)("inlineCode",{parentName:"p"},"Number"),", and to know wether a ",(0,l.kt)("inlineCode",{parentName:"p"},"Symbol")," is adjacent to a ",(0,l.kt)("inlineCode",{parentName:"p"},"Number"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"case class PartNumber(value: Int, start: Coord, end: Coord)\ncase class Symbol(sym: String, pos: Coord):\n  def neighborOf(number: PartNumber) = pos.within(\n    Coord(number.start.x - 1, number.start.y - 1),\n    Coord(number.end.x + 1, number.end.y + 1)\n  )\n")),(0,l.kt)("p",null,"Then we need to parse the input to get every ",(0,l.kt)("inlineCode",{parentName:"p"},"Symbol")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Number"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.util.matching.Regex.Match\n\nobject IsInt:\n  def unapply(in: Match): Option[Int] = in.matched.toIntOption\n\ndef findPartsAndSymbols(source: String) =\n  val extractor = """(\\d+)|[^.\\d]""".r\n  source.split("\\n").zipWithIndex.flatMap: (line, i) =>\n    extractor\n      .findAllMatchIn(line)\n      .map:\n        case m @ IsInt(nb) =>\n          PartNumber(nb, Coord(m.start, i), Coord(m.end - 1, i))\n        case s => Symbol(s.matched, Coord(s.start, i))\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"object IsInt")," with the ",(0,l.kt)("inlineCode",{parentName:"p"},".unapply")," method is called an extractor. It allows to define patterns to match on. Here it will give me a number if it can parse it from a string"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"findPartsAndSymbols")," does the parsing and returns a collection of ",(0,l.kt)("inlineCode",{parentName:"p"},"PartNumber")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Symbol"),". What we want to match on is either a number or a symbol (which is anything except the ",(0,l.kt)("inlineCode",{parentName:"p"},".")," and a ",(0,l.kt)("inlineCode",{parentName:"p"},"digit"),"). The regex match gives us some information (such as starting / ending position of the matched string) which we use to create the ",(0,l.kt)("inlineCode",{parentName:"p"},"PartNumber")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Symbol")," instances."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"m @ IsInt(nb)")," is a pattern match that will match on the ",(0,l.kt)("inlineCode",{parentName:"p"},"IsInt")," extractor and binds the parsed integer to ",(0,l.kt)("inlineCode",{parentName:"p"},"nb")," and the value being matched to ",(0,l.kt)("inlineCode",{parentName:"p"},"m"),". A similar way to achieve this is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},".map: m =>\n  m match\n    case IsInt(nb) => PartNumber(nb, Coord(m.start, i), Coord(m.end - 1, i))\n    case s => Symbol(s.matched, Coord(s.start, i))\n")),(0,l.kt)("h3",{id:"part-1"},"Part 1"),(0,l.kt)("p",null,"Compute ",(0,l.kt)("inlineCode",{parentName:"p"},"part1")," as described above:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Find all ",(0,l.kt)("inlineCode",{parentName:"li"},"numbers")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"symbols")," in the grid"),(0,l.kt)("li",{parentName:"ol"},"Filter out the symbols in a separate collection"),(0,l.kt)("li",{parentName:"ol"},"For each number element of the grid and if it has a least one symbol neighbor, return its value"),(0,l.kt)("li",{parentName:"ol"},"Sum the resulting values")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String) =\n  val all = findPartsAndSymbols(input)\n  val symbols = all.collect { case s: Symbol => s }\n  all\n    .collect:\n      case n: PartNumber if symbols.exists(_.neighborOf(n)) =>\n        n.value\n    .sum\n")),(0,l.kt)("h3",{id:"part-2"},"Part 2"),(0,l.kt)("p",null,"We might want to represent a ",(0,l.kt)("inlineCode",{parentName:"p"},"Gear")," to facilitate the computation of the gear ratios:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"case class Gear(part: PartNumber, symbol: Symbol)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"(Note: a case class is not necessary here, a tuple would do the job)")),(0,l.kt)("p",null,"Compute ",(0,l.kt)("inlineCode",{parentName:"p"},"part2")," as described above:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Find all ",(0,l.kt)("inlineCode",{parentName:"li"},"numbers")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"symbols")," in the grid"),(0,l.kt)("li",{parentName:"ol"},"Filter out the symbols in a separate collection"),(0,l.kt)("li",{parentName:"ol"},"For each number element of the grid and if it has one ",(0,l.kt)("inlineCode",{parentName:"li"},"*")," neighbor, return a ",(0,l.kt)("inlineCode",{parentName:"li"},"Gear")," with the number and the ",(0,l.kt)("inlineCode",{parentName:"li"},"*")," symbol. For any other cases, return ",(0,l.kt)("inlineCode",{parentName:"li"},"None"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},".flatMap")," method will filter out the ",(0,l.kt)("inlineCode",{parentName:"li"},"None")," values when flattening, so we get a collection of ",(0,l.kt)("inlineCode",{parentName:"li"},"Gear")," only"))),(0,l.kt)("li",{parentName:"ol"},"Group them by ",(0,l.kt)("inlineCode",{parentName:"li"},"symbol")," and map the values to the ",(0,l.kt)("inlineCode",{parentName:"li"},"number")," values",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"So we obtain a ",(0,l.kt)("inlineCode",{parentName:"li"},"Map[Symbol, List[Int]]")," instead of a ",(0,l.kt)("inlineCode",{parentName:"li"},"Map[Symbol, List[Gear]]")))),(0,l.kt)("li",{parentName:"ol"},"Filter out the symbols with less/more than 2 adjacent numbers"),(0,l.kt)("li",{parentName:"ol"},"For each entry remaining, take the product of its two number values and sum the resulting products")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String) =\n  val all = findPartsAndSymbols(input)\n  val symbols = all.collect { case s: Symbol => s }\n  all\n    .flatMap:\n      case n: PartNumber =>\n        symbols\n          .find(_.neighborOf(n))\n          .filter(_.sym == "*")\n          .map(Gear(n, _))\n      case _ => None\n    .groupMap(_.symbol)(_.part.value)\n    .filter(_._2.length == 2)\n    .foldLeft(0) { _ + _._2.product }\n')),(0,l.kt)("h2",{id:"final-code"},"Final code"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'case class Coord(x: Int, y: Int):\n  def within(start: Coord, end: Coord) =\n    if y < start.y || y > end.y then false\n    else if x < start.x || x > end.x then false\n    else true\ncase class PartNumber(value: Int, start: Coord, end: Coord)\ncase class Symbol(sym: String, pos: Coord):\n  def neighborOf(number: PartNumber) = pos.within(\n    Coord(number.start.x - 1, number.start.y - 1),\n    Coord(number.end.x + 1, number.end.y + 1)\n  )\n\nobject IsInt:\n  def unapply(in: Match): Option[Int] = in.matched.toIntOption\n\ndef findPartsAndSymbols(source: String) =\n  val extractor = """(\\d+)|[^.\\d]""".r\n  source.split("\\n").zipWithIndex.flatMap: (line, i) =>\n    extractor\n      .findAllMatchIn(line)\n      .map:\n        case m @ IsInt(nb) =>\n          PartNumber(nb, Coord(m.start, i), Coord(m.end - 1, i))\n        case s => Symbol(s.matched, Coord(s.start, i))\n\ndef part1(input: String) =\n  val all = findPartsAndSymbols(input)\n  val symbols = all.collect { case s: Symbol => s }\n  all\n    .collect:\n      case n: PartNumber if symbols.exists(_.neighborOf(n)) =>\n        n.value\n    .sum\n\ncase class Gear(part: PartNumber, symbol: Symbol)\n\ndef part2(input: String) =\n  val all = findPartsAndSymbols(input)\n  val symbols = all.collect { case s: Symbol => s }\n  all\n    .flatMap:\n      case n: PartNumber =>\n        symbols\n          .find(_.neighborOf(n))\n          .filter(_.sym == "*")\n          .map(Gear(n, _))\n      case _ => None\n    .groupMap(_.symbol)(_.part.value)\n    .filter(_._2.length == 2)\n    .foldLeft(0) { _ + _._2.product }\n')),(0,l.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,l.kt)("h4",{id:"part-1-1"},"Part 1"),(0,l.kt)(i.Z,{puzzle:"day03-part1",year:"2023",mdxType:"Solver"}),(0,l.kt)("h4",{id:"part-2-1"},"Part 2"),(0,l.kt)(i.Z,{puzzle:"day03-part2",year:"2023",mdxType:"Solver"}),(0,l.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://scastie.scala-lang.org/zSILlpFtTmCmQ3tmOcNPQg"},"Solution")," by johnduffell"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2023/src/main/scala/Day3.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/pkarthick/AdventOfCode/blob/master/2023/scala/src/main/scala/day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/pkarthick"},"Karthick Pachiappan")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2023/blob/master/src/main/scala/day03/Day03.scala"},"Solution")," of ",(0,l.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/03.worksheet.sc#L89"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2023/blob/main/src/main/scala/solutions/day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2023/day3/Day3.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2023/blob/main/2023-day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/kbielefe/advent-of-code/blob/master/2023/src/main/scala/3.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/kbielefe"},"Karl Bielefeldt")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/mpilquist/aoc/blob/main/2023/day3.sc"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/mpilquist"},"Michael Pilquist")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/nryabykh/aoc2023/blob/master/src/main/scala/Day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/nryabykh/"},"Nikolai Riabykh")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/bxiang/advent-of-code-2023/blob/main/src/main/scala/com/aoc/Solution3.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/bxiang"},"Brian Xiang")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://gist.github.com/CJSmith-0141/347a6ec4fd12dce31892046a827dbbc8"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/CJSmith-0141"},"CJ Smith")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/alexandru/advent-of-code/blob/main/scala3/2023/src/main/scala/day3.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/alexandru/"},"Alexandru Nedelcu")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/joeledwards/advent-of-code/blob/master/2023/src/main/scala/com/buzuli/advent/days/day3.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/joeledwards"},"Joel Edwards")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code_2023/blob/main/src/main/scala/days/day03/DayThree.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2023/blob/main/day03/gear-ratios.sc"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/wbillingsley/advent-of-code-2023-scala/blob/star6/solver.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/wbillingsley"},"Will Billingsley")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2023/src/test/scala/Day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh/aoc-2023/blob/main/Day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh"},"Thanh Le")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/master/task03/src/main/scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/marconilanna/advent-of-code/blob/master/2023/Day03.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/marconilanna"},"Marconi Lanna"))),(0,l.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}u.isMDXComponent=!0}}]);