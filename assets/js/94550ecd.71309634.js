"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7238],{3542:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>u});var n=a(7462),o=(a(7294),a(3905)),i=a(6340);const s={},l="Day 16: Proboscidea Volcanium",r={unversionedId:"2022/puzzles/day16",id:"2022/puzzles/day16",title:"Day 16: Proboscidea Volcanium",description:"code by Tyler Coles (javadocmd.com), Quentin Bernet, @sjrd, and @bishabosha",source:"@site/target/mdoc/2022/puzzles/day16.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day16",permalink:"/scala-advent-of-code/2022/puzzles/day16",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day16.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 15: Beacon Exclusion Zone",permalink:"/scala-advent-of-code/2022/puzzles/day15"},next:{title:"Day 17: Pyroclastic Flow",permalink:"/scala-advent-of-code/2022/puzzles/day17"}},d={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:u};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-16-proboscidea-volcanium"},"Day 16: Proboscidea Volcanium"),(0,o.kt)("p",null,"code by Tyler Coles (javadocmd.com), Quentin Bernet, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sjrd"},"@sjrd"),", and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/16"},"https://adventofcode.com/2022/day/16")),(0,o.kt)("h2",{id:"final-code"},"Final Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'type Id = String\ncase class Room(id: Id, flow: Int, tunnels: List[Id])\n\ntype Input = List[Room]\n// $_ to avoid tunnel/tunnels distinction and so on\ndef parse(xs: String): Input = xs.split("\\n").map{ case s"Valve $id has flow rate=$flow; tunnel$_ lead$_ to valve$_ $tunnelsStr" =>\n  val tunnels = tunnelsStr.split(", ").toList\n  Room(id, flow.toInt, tunnels)\n}.toList\n\ncase class RoomsInfo(\n  /** map of rooms by id */\n  rooms: Map[Id, Room],\n  /** map from starting room to a map containing the best distance to all other rooms */\n  routes: Map[Id, Map[Id, Int]],\n  /** rooms containing non-zero-flow valves */\n  valves: Set[Id]\n)\n\n// precalculate useful things like pathfinding\ndef constructInfo(input: Input): RoomsInfo =\n  val rooms: Map[Id, Room]          = Map.from(for r <- input yield r.id -> r)\n  val valves: Set[Id]               = Set.from(for r <- input if r.flow > 0 yield r.id)\n  val tunnels: Map[Id, List[Id]]    = rooms.mapValues(_.tunnels).toMap\n  val routes: Map[Id, Map[Id, Int]] = (valves + "AA").iterator.map{ id => id -> computeRoutes(id, tunnels) }.toMap\n  RoomsInfo(rooms, routes, valves)\n\n// a modified A-star to calculate the best distance to all rooms rather then the best path to a single room\ndef computeRoutes(start: Id, neighbors: Id => List[Id]): Map[Id, Int] =\n\n  case class State(frontier: List[(Id, Int)], scores: Map[Id, Int]):\n\n    private def getScore(id: Id): Int = scores.getOrElse(id, Int.MaxValue)\n    private def setScore(id: Id, s: Int) = State((id, s + 1) :: frontier, scores + (id -> s))\n\n    def dequeued: (Id, State) =\n      val sorted = frontier.sortBy(_._2)\n      (sorted.head._1, copy(frontier = sorted.tail))\n\n    def considerEdge(from: Id, to: Id): State =\n      val toScore = getScore(from) + 1\n      if toScore >= getScore(to) then this\n      else setScore(to, toScore)\n  end State\n\n  object State:\n    def initial(start: Id) = State(List((start, 0)), Map(start -> 0))\n\n  def recurse(state: State): State =\n    if state.frontier.isEmpty then\n      state\n    else\n      val (curr, currState) = state.dequeued\n      val newState = neighbors(curr)\n        .foldLeft(currState) { (s, n) =>\n          s.considerEdge(curr, n)\n        }\n      recurse(newState)\n\n  recurse(State.initial(start)).scores\n\nend computeRoutes\n\n\n// find the best path (the order of valves to open) and the total pressure released by taking it\ndef bestPath(map: RoomsInfo, start: Id, valves: Set[Id], timeAllowed: Int): Int =\n  // each step involves moving to a room with a useful valve and opening it\n  // we don\'t need to track each (empty) room in between\n  // we limit our options by only considering the still-closed valves\n  // and `valves` has already culled any room with a flow value of 0 -- no point in considering these rooms!\n\n  val valvesLookup = IArray.from(valves)\n  val valveCount = valvesLookup.size\n  val _activeValveIndices = Array.fill[Boolean](valveCount + 1)(true) // add an extra valve for the initial state\n  def valveIndexLeft(i: Int) = _activeValveIndices(i)\n  def withoutValve(i: Int)(f: => Int) =\n    _activeValveIndices(i) = false\n    val result = f\n    _activeValveIndices(i) = true\n    result\n  val roomsByIndices = IArray.tabulate(valveCount)(i => map.rooms(valvesLookup(i)))\n\n  def recurse(hiddenValve: Int, current: Id, timeLeft: Int, totalValue: Int): Int = withoutValve(hiddenValve):\n    // recursively consider all plausible options\n    // we are finished when we no longer have time to reach another valve or all valves are open\n    val routesOfCurrent = map.routes(current)\n    var bestValue = totalValue\n    for index <- 0 to valveCount do\n      if valveIndexLeft(index) then\n        val id = valvesLookup(index)\n        val distance = routesOfCurrent(id)\n        // how much time is left after we traverse there and open the valve?\n        val t = timeLeft - distance - 1\n        // if `t` is zero or less this option can be skipped\n        if t > 0 then\n          // the value of choosing a particular valve (over the life of our simulation)\n          // is its flow rate multiplied by the time remaining after opening it\n          val value = roomsByIndices(index).flow * t\n          val recValue = recurse(hiddenValve = index, id, t, totalValue + value)\n          if recValue > bestValue then\n            bestValue = recValue\n        end if\n      end if\n    end for\n    bestValue\n  end recurse\n  recurse(valveCount, start, timeAllowed, 0)\n\ndef part1(input: String) =\n  val time   = 30\n  val map    = constructInfo(parse(input))\n  bestPath(map, "AA", map.valves, time)\nend part1\n\ndef part2(input: String) =\n  val time = 26\n  val map  = constructInfo(parse(input))\n\n  // in the optimal solution, the elephant and I will have divided responsibility for switching the valves\n  // 15 (useful valves) choose 7 (half) yields only 6435 possible divisions which is a reasonable search space!\n  val valvesA = map.valves.toList\n    .combinations(map.valves.size / 2)\n    .map(_.toSet)\n\n  // NOTE: I assumed an even ditribution of valves would be optimal, and that turned out to be true.\n  // However I suppose it\'s possible an uneven distribution could have been optimal for some graphs.\n  // To be safe, you could re-run this using all reasonable values of `n` for `combinations` (1 to 7) and\n  // taking the best of those.\n\n  // we can now calculate the efforts separately and sum their values to find the best\n  val allPaths =\n    for va <- valvesA yield\n      val vb              = map.valves -- va\n      val scoreA = bestPath(map, "AA", va, time)\n      val scoreB = bestPath(map, "AA", vb, time)\n      scoreA + scoreB\n\n  allPaths.max\nend part2\n')),(0,o.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,o.kt)("h4",{id:"part-1"},"Part 1"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Warning: This is pretty slow and may cause the UI to freeze (close tab if problematic)")),(0,o.kt)(i.Z,{puzzle:"day16-part1",year:"2022",mdxType:"Solver"}),(0,o.kt)("h4",{id:"part-2"},"Part 2"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Warning: This is pretty slow and may cause the UI to freeze (close tab if problematic)")),(0,o.kt)(i.Z,{puzzle:"day16-part2",year:"2022",mdxType:"Solver"}),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day16.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gist.github.com/JavadocMD/ad657672282b2b547334f10bd15d3066"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/JavadocMD"},"Tyler Coles")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day16.scala"},"Solution")," by Cosmin Ciobanu"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day16"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/w-r-z-k/aoc2022/blob/main/src/main/scala/Day16.scala"},"Solution")," by Richard W"),(0,o.kt)("li",{parentName:"ul"})),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}p.isMDXComponent=!0}}]);