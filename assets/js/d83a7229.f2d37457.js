"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6523],{5779:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));n(6340);const o={},r="Day 18: Lavaduct Lagoon",l={unversionedId:"2023/puzzles/day18",id:"2023/puzzles/day18",title:"Day 18: Lavaduct Lagoon",description:"by @EugeneFlesselle",source:"@site/target/mdoc/2023/puzzles/day18.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day18",permalink:"/scala-advent-of-code/2023/puzzles/day18",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day18.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 17: Clumsy Crucible",permalink:"/scala-advent-of-code/2023/puzzles/day17"},next:{title:"Day 19: Aplenty",permalink:"/scala-advent-of-code/2023/puzzles/day19"}},c={},s=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:s};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-18-lavaduct-lagoon"},"Day 18: Lavaduct Lagoon"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/EugeneFlesselle"},"@EugeneFlesselle")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/18"},"https://adventofcode.com/2023/day/18")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"Assume we have a given ",(0,i.kt)("inlineCode",{parentName:"p"},"digPlan: Seq[Trench]")," for which to compute the area,\nand let the following classes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"enum Direction:\n  case Up, Down, Left, Right\n\ncase class Trench(dir: Direction, length: Int)\n")),(0,i.kt)("p",null,"We can go through the dig plan keeping track of the current position,\nby starting from ",(0,i.kt)("inlineCode",{parentName:"p"},"(x = 0, y = 0)"),", increasing ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," when going right, increasing ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," when going down, and so on."),(0,i.kt)("p",null,"Provided our current position, we can then keep track of the lagoon area as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When going ",(0,i.kt)("inlineCode",{parentName:"li"},"Right"),": we count all the points in the line we cover, i.e the ",(0,i.kt)("inlineCode",{parentName:"li"},"length")," of the trench."),(0,i.kt)("li",{parentName:"ul"},"When going ",(0,i.kt)("inlineCode",{parentName:"li"},"Down"),": we count all the points which we leave on the left (or pass over),\ni.e. the ",(0,i.kt)("inlineCode",{parentName:"li"},"length")," of the downwards trench times our current ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," coordinate,\n",(0,i.kt)("inlineCode",{parentName:"li"},"+1")," to count the current vertical trench as in the area.\nOf course, we may be including too much at this point,\nsince we do not yet know what part of the left is actually in the lagoon,\nbut we will account for it later."),(0,i.kt)("li",{parentName:"ul"},"When going ",(0,i.kt)("inlineCode",{parentName:"li"},"Left"),": there is nothing to add,\nthe position could only have been reached from a downwards trench,\nhence the area has already been counted."),(0,i.kt)("li",{parentName:"ul"},"When going ",(0,i.kt)("inlineCode",{parentName:"li"},"Up"),": we now know by how much we had over increased the area when going down,\nand can remove everything strictly to the left of the current ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," position.")),(0,i.kt)("p",null,"In summary, we assume we cover everything to the left when going down\nand remove the uncovered part when coming back up.\nFinally, we must start from an area of ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"as the starting position ",(0,i.kt)("inlineCode",{parentName:"p"},"(0, 0)")," is naturally covered,\nbut isn't counted by the first trench whichever it may be.\nAll of which translates to the following foldLeft in scala \ud83d\ude09:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val (_, area) = digPlan.foldLeft((0, 0), 1L):\n  case (((x, y), area), Trench(dir, len)) => dir match\n    case Right => ((x + len, y), area + len)\n    case Down  => ((x, y + len), area + (x + 1) * len.toLong)\n    case Left  => ((x - len, y), area)\n    case Up    => ((x, y - len), area - x * len.toLong)\n")),(0,i.kt)("p",null,"Also note we have to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Long"),"s to avoid the computations from overflowing."),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"We can get the ",(0,i.kt)("inlineCode",{parentName:"p"},"Trench")," of each line in the ",(0,i.kt)("inlineCode",{parentName:"p"},"input: String"),",\nby parsing the direction from the corresponding character\nand ignoring the color of the trench.\nAnd then proceed as above with the obtained ",(0,i.kt)("inlineCode",{parentName:"p"},"digPlan"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"object Direction:\n  def fromChar(c: Char): Direction = c match\n    case 'U' => Up case 'D' => Down case 'L' => Left case 'R' => Right\n\nval digPlan = for\n  case s\"$dirC $len (#$_)\" <- input.linesIterator\n  dir = Direction.fromChar(dirC.head)\nyield Trench(dir, len.toInt)\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"We do the same for part 2, except we use the color to\nget the trench fields:\nits direction from the last digit,\nand its length by converting from the hexadecimal encoding of the remaining digits."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"object Direction:\n  def fromInt(i: Char): Direction = i match\n    case '0' => Right case '1' => Down case '2' => Left case '3' => Up\n\nval digPlan = for\n  case s\"$_ $_ (#$color)\" <- input.linesIterator\n  dir = Direction.fromInt(color.last)\n  len = BigInt(x = color.init, radix = 16)\nyield Trench(dir, len.toInt)\n")),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"enum Direction:\n  case Up, Down, Left, Right\nobject Direction:\n  def fromChar(c: Char): Direction = c match\n    case 'U' => Up case 'D' => Down case 'L' => Left case 'R' => Right\n  def fromInt(i: Char): Direction = i match\n    case '0' => Right case '1' => Down case '2' => Left case '3' => Up\nimport Direction.*\n\ncase class Trench(dir: Direction, length: Int)\n\ndef area(digPlan: Seq[Trench]): Long =\n  val (_, area) = digPlan.foldLeft((0, 0), 1L):\n    case (((x, y), area), Trench(dir, len)) => dir match\n      case Right => ((x + len, y), area + len)\n      case Down  => ((x, y + len), area + (x + 1) * len.toLong)\n      case Left  => ((x - len, y), area)\n      case Up    => ((x, y - len), area - x * len.toLong)\n  area\n\ndef part1(input: String): String =\n  val digPlan = for\n    case s\"$dirC $len (#$_)\" <- input.linesIterator\n    dir = Direction.fromChar(dirC.head)\n  yield Trench(dir, len.toInt)\n\n  area(digPlan.toSeq).toString\n\ndef part2(input: String): String =\n  val digPlan = for\n    case s\"$_ $_ (#$color)\" <- input.linesIterator\n    dir = Direction.fromInt(color.last)\n    len = BigInt(x = color.init, radix = 16)\n  yield Trench(dir, len.toInt)\n\n  area(digPlan.toSeq).toString\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2023/blob/main/src/main/scala/Day18.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/"},"merlin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/18.worksheet.sc#L101"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day18.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/master/task18/src/main/scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2023/blob/main/2023-day18.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}d.isMDXComponent=!0}}]);