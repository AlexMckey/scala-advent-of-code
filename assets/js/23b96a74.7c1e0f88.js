"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8752],{1307:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var a=t(7462),s=(t(7294),t(3905));t(6340);const l={},o="Day 20: Pulse Propagation",i={unversionedId:"2023/puzzles/day20",id:"2023/puzzles/day20",title:"Day 20: Pulse Propagation",description:"by @merlinorg",source:"@site/target/mdoc/2023/puzzles/day20.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day20",permalink:"/scala-advent-of-code/2023/puzzles/day20",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day20.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 19: Aplenty",permalink:"/scala-advent-of-code/2023/puzzles/day19"},next:{title:"Day 21: Step Counter",permalink:"/scala-advent-of-code/2023/puzzles/day21"}},u={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Summary",id:"summary",level:2},{value:"Model",id:"model",level:2},{value:"Pulses",id:"pulses",level:3},{value:"Modules",id:"modules",level:3},{value:"The Machine",id:"the-machine",level:3},{value:"Parsing",id:"parsing",level:3},{value:"The Elves&#39; State Machine",id:"the-elves-state-machine",level:2},{value:"State",id:"state",level:3},{value:"Update",id:"update",level:3},{value:"Part 1 State Machine",id:"part-1-state-machine",level:2},{value:"State",id:"state-1",level:3},{value:"Update",id:"update-1",level:3},{value:"Part 1 Solution",id:"part-1-solution",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Part 2 Optimised: State Machine",id:"part-2-optimised-state-machine",level:2},{value:"Subgraphs",id:"subgraphs",level:4},{value:"State",id:"state-2",level:3},{value:"Update",id:"update-2",level:3},{value:"Part 2 Solution",id:"part-2-solution",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],r={toc:c};function h(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,a.Z)({},r,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"day-20-pulse-propagation"},"Day 20: Pulse Propagation"),(0,s.kt)("p",null,"by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/merlinorg"},"@merlinorg")),(0,s.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/20"},"https://adventofcode.com/2023/day/20")),(0,s.kt)("h2",{id:"summary"},"Summary"),(0,s.kt)("p",null,"Day 20 involves executing a machine that is operated by pushing a button to\nsend pulses to various modules. These modules update their internal state\naccording to their type and the pulse information, and then send further\npulses through the machine."),(0,s.kt)("p",null,"It is tempting to implement the machine using mutable state, however a\npure functional ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Finite-state_machine"},"state machine"),"\ngives us much more flexibility."),(0,s.kt)("h2",{id:"model"},"Model"),(0,s.kt)("h3",{id:"pulses"},"Pulses"),(0,s.kt)("p",null,"Pulses are the messages of our primary state machine. They combine a pulse\nlevel, either low (",(0,s.kt)("inlineCode",{parentName:"p"},"false"),") or high (",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"), and travel from a source to a\ndestination module."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},'type ModuleName = String\n\nfinal case class Pulse(\n  source: ModuleName,\n  destination: ModuleName,\n  level: Boolean,\n)\n\nobject Pulse:\n  final val ButtonPress = Pulse("button", "broadcaster", false)\n')),(0,s.kt)("h3",{id:"modules"},"Modules"),(0,s.kt)("p",null,"The modules include a pass-through (the broadcaster) which simply forwards\npulses, flip flops which toggle state and emit when they receive a low pulse,\nand conjunctions which emit a low signal when all inputs are high."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Module:\n  def name: ModuleName\n  def destinations: Vector[ModuleName]\n  // Generate pulses for all the destinations of this module\n  def pulses(level: Boolean): Vector[Pulse] =\n    destinations.map(Pulse(name, _, level))\nend Module\n\nfinal case class PassThrough(\n  name: ModuleName,\n  destinations: Vector[ModuleName],\n) extends Module\n\nfinal case class FlipFlop(\n  name: ModuleName,\n  destinations: Vector[ModuleName],\n  state: Boolean,\n) extends Module\n\nfinal case class Conjunction(\n  name: ModuleName,\n  destinations: Vector[ModuleName],\n  // The source modules that most-recently sent a high pulse\n  state: Set[ModuleName],\n) extends Module\n")),(0,s.kt)("h3",{id:"the-machine"},"The Machine"),(0,s.kt)("p",null,"The machine itself comprises a collection of named modules and a map that\ngathers which modules serve as sources for each module in the machine. We\nneed this source map because various parts of the algorithm require that\nwe know which modules feed into other modules."),(0,s.kt)("p",null,"Here, we model the source map as ",(0,s.kt)("inlineCode",{parentName:"p"},"Map[ModuleName, Set[ModuleName]]"),". In a\nless constrained environment we would use\n",(0,s.kt)("a",{parentName:"p",href:"https://www.javadoc.io/doc/org.scala-lang.modules/scala-collection-contrib_3/latest/scala/collection/immutable/MultiDict.html"},"MultiDict")," that has the same\nshape but is more ergonomic."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Machine(\n  modules: Map[ModuleName, Module],\n  sources: Map[ModuleName, Set[ModuleName]]\n)\n\nobject Machine:\n  val Initial = Machine(Map.empty, Map.empty)\n\nextension (self: Machine)\n  inline def +(module: Module): Machine =\n    import self.*\n    copy(\n      modules = modules.updated(module.name, module),\n      sources = module.destinations.foldLeft(sources): (sources, destination) =>\n        sources.updatedWith(destination):\n          case None         => Some(Set(module.name))\n          case Some(values) => Some(values + module.name)\n    )\n")),(0,s.kt)("h3",{id:"parsing"},"Parsing"),(0,s.kt)("p",null,"To parse the input we first parse all of the modules using fairly na\xefve\nstring matching, and then fold these modules into a new machine."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(input: String): Machine =\n  val modules = input.linesIterator.map:\n    case s"%$name -> $targets" =>\n      FlipFlop(name, targets.split(", ").toVector, false)\n    case s"&$name -> $targets" =>\n      Conjunction(name, targets.split(", ").toVector, Set.empty)\n    case s"$name -> $targets"  =>\n      PassThrough(name, targets.split(", ").toVector)\n  modules.foldLeft(Machine.Initial)(_ + _)\n')),(0,s.kt)("h2",{id:"the-elves-state-machine"},"The Elves' State Machine"),(0,s.kt)("p",null,"The primary state machine executes the Elves' machine itself. It is a\nclassical ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Moore_machine"},"Moore Machine"),",\na state machine whose next state is purely defined by its current state;\nthere are no external inputs."),(0,s.kt)("h3",{id:"state"},"State"),(0,s.kt)("p",null,"The state contained in the primary state machine is the machine definition,\nthe number of button presses that have occurred, and a queue of pending\npulses."),(0,s.kt)("p",null,"For a queue we use uses the immutable ",(0,s.kt)("inlineCode",{parentName:"p"},"Queue")," class which has a method\n",(0,s.kt)("inlineCode",{parentName:"p"},"dequeueOption: Option[(A, Queue[A])]")," which returns the head element\nand the remainder of the queue, or ",(0,s.kt)("inlineCode",{parentName:"p"},"None")," if the queue is empty."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.immutable.Queue\n\nfinal case class MachineFSM(\n  machine: Machine,\n  presses: Long = 0,\n  queue: Queue[Pulse] = Queue.empty,\n)\n")),(0,s.kt)("h3",{id:"update"},"Update"),(0,s.kt)("p",null,"The next state is determined purely by the current state."),(0,s.kt)("p",null,"If the queue is empty, we increment the button press count and enqueue a\nbutton press pulse."),(0,s.kt)("p",null,"Otherwise, we pull the next pulse from the start of the queue, find\nthe module it has been sent to and then return a new state accordingly.\nThe new state will contain a new queue (with the head removed, and\nnew pulses enqueued), along with a revised machine definition that\ncontains the updated module state."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"def nextState(fsm: MachineFSM): MachineFSM =\n  import fsm.*\n\n  queue.dequeueOption match\n  case None =>\n    copy(presses = presses + 1, queue = Queue(Pulse.ButtonPress))\n\n  case Some((Pulse(source, destination, level), tail)) =>\n    machine.modules.get(destination) match\n      case Some(passThrough: PassThrough) =>\n        copy(queue = tail ++ passThrough.pulses(level))\n\n      case Some(flipFlop: FlipFlop) if !level =>\n        val flipFlop2 = flipFlop.copy(state = !flipFlop.state)\n        copy(\n          machine = machine + flipFlop2,\n          queue = tail ++ flipFlop2.pulses(flipFlop2.state)\n        )\n\n      case Some(conjunction: Conjunction) =>\n        val conjunction2 = conjunction.copy(\n          state = if level then conjunction.state + source\n                           else conjunction.state - source\n        )\n        val active = machine.sources(conjunction2.name) == conjunction2.state\n        copy(\n          machine = machine + conjunction2,\n          queue = tail ++ conjunction2.pulses(!active)\n        )\n\n      case _ =>\n        copy(queue = tail)\nend nextState\n")),(0,s.kt)("h2",{id:"part-1-state-machine"},"Part 1 State Machine"),(0,s.kt)("p",null,"The part 1 state machine is a\n",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mealy_machine"},"Mealy Machine")," which contains\nan internal state that is updated by some input. In this case, the input to\nupdate the problem 1 state machine is the Elves' state machine itself.\nWe will look at each state to observe the pulses that flow and terminate when\n1000 button presses have occurred."),(0,s.kt)("h3",{id:"state-1"},"State"),(0,s.kt)("p",null,"The part 1 state machine comprises the number of low and high pulses\nobserved, and whether the problem is complete (after 1000 presses). The\nresult of the state machine when complete is the product of low and high\npulses observed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Problem1FSM(\n  lows: Long,\n  highs: Long,\n  complete: Boolean,\n)\n\nobject Problem1FSM:\n  final val Initial = Problem1FSM(0, 0, false)\n\n  def solution(fsm: Problem1FSM): Option[Long] =\n    import fsm.*\n    Option.when(complete)(lows * highs)\n")),(0,s.kt)("h3",{id:"update-1"},"Update"),(0,s.kt)("p",null,"If the head of the pulse queue is a low or high pulse then we update the\nlow/high count. If the pulse queue is empty and the button has been pressed\n1000 times then we update the state to complete."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"extension (self: Problem1FSM)\n  inline def +(state: MachineFSM): Problem1FSM =\n    import self.*\n    state.queue.headOption match\n    case Some(Pulse(_, _, false))      => copy(lows = lows + 1)\n    case Some(Pulse(_, _, true))       => copy(highs = highs + 1)\n    case None if state.presses == 1000 => copy(complete = true)\n    case None                          => self\n")),(0,s.kt)("h2",{id:"part-1-solution"},"Part 1 Solution"),(0,s.kt)("p",null,"Part 1 is solved by first constructing the primary state machine that\nexecutes the pulse machinery. Each state of this machine is then fed to the\npart 1 state machine. We then run the combined state machines to\ncompletion."),(0,s.kt)("p",null,"We can execute a Moore Machine using ",(0,s.kt)("inlineCode",{parentName:"p"},"Iterator.iterate(a: A)(f: A => A)"),"\nwhich takes an initial state and will then iterate through the machine's\nstates."),(0,s.kt)("p",null,"We can execute a Mealy Machine using ",(0,s.kt)("inlineCode",{parentName:"p"},"scanLeft(b: B)(f: (B, A) => B)"),"\nwhich takes an initial state and will then provide each element\nof the iterator as an input to the state machine to compute its next state."),(0,s.kt)("p",null,"Finally, we can just iterate until we reach the complete state and get the\nresult."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"// An unruly and lawless find-map-get\nextension [A](self: Iterator[A])\n  def findMap[B](f: A => Option[B]): B = self.flatMap(f).next()\n\ndef part1(input: String): Long =\n  val machine = parse(input)\n  Iterator\n    .iterate(MachineFSM(machine))(nextState)\n    .scanLeft(Problem1FSM.Initial)(_ + _)\n    .findMap(Problem1FSM.solution)\n")),(0,s.kt)("h2",{id:"part-2"},"Part 2"),(0,s.kt)("p",null,'Part 2 asks how many button presses are required for a particular output\nmodule "rx" to receive a high pulse.'),(0,s.kt)("p",null,"This can crudely be solved by just running the Elves' state machine\nuntil you find such a pulse:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},'Iterator\n  .iterate(MachineFSM(machine))(nextState)\n  .findMap: state =>\n    state.queue.headOption.collect:\n      case Pulse(_, "rx", false) => state.presses\n')),(0,s.kt)("p",null,"Knowing the Advent of Code, this will not complete in any reasonable\ntime. Indeed, my machine can run 100,000 button presses per second and\nwould take 70 years to solve the problem in this manner."),(0,s.kt)("p",null,"The state machine also does not obviously lend itself to a mathematical\nreduction, at least not within the available time constraints."),(0,s.kt)("p",null,'Instead, we have to look at the actual input text itself. Analyzing the\nstructure of the machine, it turns out that the "rx" module is fed by a\nconjunction module which is itself fed by four completely independent\nsubgraphs. This terminal conjunction will emit a high pulse when it\nreceives a high pulse from each of the subgraphs.'),(0,s.kt)("p",null,"Each subgraph emits a high pulse on a repeating cycle. This reminds us of\n",(0,s.kt)("a",{parentName:"p",href:"/scala-advent-of-code/2023/puzzles/day05"},"day 8"),"; the soonest point at which all the subgraphs will simultaneously\nemit a high pulse will be the\n",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Least_common_multiple"},"least common multiple"),"\nof the subgraph cycle times. It is not uncommon for AoC problems to\nreuse techniques from prior days and lend themselves to a quicker solution\nbased on analyzing the puzzle input."),(0,s.kt)("h2",{id:"part-2-optimised-state-machine"},"Part 2 Optimised: State Machine"),(0,s.kt)("p",null,"We will solve part 2 using another Mealy Machine. We will watch the\nElves' state machine until we have determined the cycle times of each of\nthe terminal subgraphs, then compute the LCM."),(0,s.kt)("h4",{id:"subgraphs"},"Subgraphs"),(0,s.kt)("p",null,"The terminal module is a module that doesn't serve as an input to\nany other module. We could hardcode ",(0,s.kt)("inlineCode",{parentName:"p"},'"rx"'),", but this is more general.\nThe output modules of the independent subgraphs are then all the\ninputs to the sole input to this terminal conjunction:\n",(0,s.kt)("inlineCode",{parentName:"p"},'("a", "b", "c", "d") -> "penultimate" -> "rx"'),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"def subgraphs(machine: Machine): Set[ModuleName] =\n  val terminal = (machine.sources.keySet -- machine.modules.keySet).head\n  machine.sources(machine.sources(terminal).head)\n")),(0,s.kt)("h3",{id:"state-2"},"State"),(0,s.kt)("p",null,"The state is just a map that records the cycle time of each subgraph.\nWe initialise it with 0 values for each module of interest and then\nexecute until they are all non-zero."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.annotation.tailrec\n\nfinal case class Problem2FSM(\n  cycles: Map[ModuleName, Long],\n)\n\nobject Problem2FSM:\n\n  def from(machine: Machine): Problem2FSM =\n    Problem2FSM(subgraphs(machine).map(_ -> 0L).toMap)\n\n  private def lcm(list: Iterable[Long]): Long =\n    list.foldLeft(1L)((a, b) => b * a / gcd(a, b))\n\n  @tailrec\n  private def gcd(x: Long, y: Long): Long =\n    if y == 0 then x else gcd(y, x % y)\n\n  def solution(fsm: Problem2FSM): Option[Long] =\n    import fsm.cycles\n    Option.when(cycles.values.forall(_ > 0))(lcm(cycles.values))\n")),(0,s.kt)("h3",{id:"update-2"},"Update"),(0,s.kt)("p",null,"Our update step just watches the Elves' state machine, looking for\na high pulse from the output module of a subgraph, and records the\nbutton press count at that point."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"extension (self: Problem2FSM)\n  inline def +(state: MachineFSM): Problem2FSM =\n    import self.*\n    state.queue.headOption match\n      case Some(Pulse(src, _, true)) if cycles.get(src).contains(0L) =>\n        copy(cycles = cycles + (src -> state.presses))\n      case _  => self\n")),(0,s.kt)("h2",{id:"part-2-solution"},"Part 2 Solution"),(0,s.kt)("p",null,"Part 2 is solved identically to part 1, combining the state machines\nand iterating until we reach a solution."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Long =\n  val machine = parse(input)\n  Iterator\n    .iterate(MachineFSM(machine))(nextState)\n    .scanLeft(Problem2FSM.from(machine))(_ + _)\n    .findMap(Problem2FSM.solution)\n")),(0,s.kt)("h2",{id:"final-code"},"Final Code"),(0,s.kt)("p",null,"The complete, rather lengthy solution follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\ntype ModuleName = String\n\n// Pulses are the messages of our primary state machine. They are either low\n// (false) or high (true) and travel from a source to a destination module\nfinal case class Pulse(\n  source: ModuleName,\n  destination: ModuleName,\n  level: Boolean,\n)\n\nobject Pulse:\n  final val ButtonPress = Pulse("button", "broadcaster", false)\n\n// The modules include pass-throughs which simply forward pulses, flip flips\n// which toggle state and emit when they receive a low pulse, and conjunctions\n// which emit a low signal when all inputs are high.\n\nsealed trait Module:\n  def name: ModuleName\n  def destinations: Vector[ModuleName]\n  // Generate pulses for all the destinations of this module\n  def pulses(level: Boolean): Vector[Pulse] =\n    destinations.map(Pulse(name, _, level))\nend Module\n\nfinal case class PassThrough(\n  name: ModuleName,\n  destinations: Vector[ModuleName],\n) extends Module\n\nfinal case class FlipFlop(\n  name: ModuleName,\n  destinations: Vector[ModuleName],\n  state: Boolean,\n) extends Module\n\nfinal case class Conjunction(\n  name: ModuleName,\n  destinations: Vector[ModuleName],\n  // The source modules that most-recently sent a high pulse\n  state: Set[ModuleName],\n) extends Module\n\n// The machine comprises a collection of named modules and a map that gathers\n// which modules serve as sources for each module in the machine.\n\nfinal case class Machine(\n  modules: Map[ModuleName, Module],\n  sources: Map[ModuleName, Set[ModuleName]]\n)\n\nobject Machine:\n  val Initial = Machine(Map.empty, Map.empty)\n\nextension (self: Machine)\n  inline def +(module: Module): Machine =\n    import self.*\n    copy(\n      modules = modules.updated(module.name, module),\n      sources = module.destinations.foldLeft(sources): (sources, destination) =>\n        sources.updatedWith(destination):\n          case None         => Some(Set(module.name))\n          case Some(values) => Some(values + module.name)\n    )\n\nval Initial = Machine(Map.empty, Map.empty)\n\n// To parse the input we first parse all of the modules and then fold them\n// into a new machine\ndef parse(input: String): Machine =\n  val modules = input.linesIterator.map:\n    case s"%$name -> $targets" =>\n      FlipFlop(name, targets.split(", ").toVector, false)\n    case s"&$name -> $targets" =>\n      Conjunction(name, targets.split(", ").toVector, Set.empty)\n    case s"$name -> $targets"  =>\n      PassThrough(name, targets.split(", ").toVector)\n  modules.foldLeft(Machine.Initial)(_ + _)\n\n// The primary state machine state comprises the machine itself, the number of\n// button presses and a queue of outstanding pulses.\n\nfinal case class MachineFSM(\n  machine: Machine,\n  presses: Long = 0,\n  queue: Queue[Pulse] = Queue.empty,\n)\n\ndef nextState(fsm: MachineFSM): MachineFSM =\n  import fsm.*\n\n  queue.dequeueOption match\n  case None =>\n    copy(presses = presses + 1, queue = Queue(Pulse.ButtonPress))\n\n  case Some((Pulse(source, destination, level), tail)) =>\n    machine.modules.get(destination) match\n      case Some(passThrough: PassThrough) =>\n        copy(queue = tail ++ passThrough.pulses(level))\n\n      case Some(flipFlop: FlipFlop) if !level =>\n        val flipFlop2 = flipFlop.copy(state = !flipFlop.state)\n        copy(\n          machine = machine + flipFlop2,\n          queue = tail ++ flipFlop2.pulses(flipFlop2.state)\n        )\n\n      case Some(conjunction: Conjunction) =>\n        val conjunction2 = conjunction.copy(\n          state = if level then conjunction.state + source\n                           else conjunction.state - source\n        )\n        val active = machine.sources(conjunction2.name) == conjunction2.state\n        copy(\n          machine = machine + conjunction2,\n          queue = tail ++ conjunction2.pulses(!active)\n        )\n\n      case _ =>\n        copy(queue = tail)\nend nextState\n\n// An unruly and lawless find-map-get\nextension [A](self: Iterator[A])\n  def findMap[B](f: A => Option[B]): B = self.flatMap(f).next()\n\n// The problem 1 state machine comprises the number of low and high pulses\n// processed, and whether the problem is complete (after 1000 presses). This\n// state machine gets updated by each state of the primary state machine.\n\nfinal case class Problem1FSM(\n  lows: Long,\n  highs: Long,\n  complete: Boolean,\n)\n\nobject Problem1FSM:\n  final val Initial = Problem1FSM(0, 0, false)\n\n  // The result is the product of lows and highs\n  def solution(fsm: Problem1FSM): Option[Long] =\n    import fsm.*\n    Option.when(complete)(lows * highs)\n\n// If the head of the pulse queue is a low or high pulse then update the\n// low/high count. If the pulse queue is empty and the button has been pressed\n// 1000 times then complete.\n\nextension (self: Problem1FSM)\n  inline def +(state: MachineFSM): Problem1FSM =\n    import self.*\n    state.queue.headOption match\n    case Some(Pulse(_, _, false))      => copy(lows = lows + 1)\n    case Some(Pulse(_, _, true))       => copy(highs = highs + 1)\n    case None if state.presses == 1000 => copy(complete = true)\n    case None                          => self\n\n// Part 1 is solved by first constructing the primary state machine that\n// executes the pulse machinery. Each state of this machine is then fed to a\n// second problem 1 state machine. We then run the combined state machines to\n// completion.\n\ndef part1(input: String): Long =\n  val machine = parse(input)\n  Iterator\n    .iterate(MachineFSM(machine))(nextState)\n    .scanLeft(Problem1FSM.Initial)(_ + _)\n    .findMap(Problem1FSM.solution)\n\n// The problem is characterized by a terminal module ("rx") that is fed by\n// several subgraphs so we look to see which are the sources of the terminal\n// module; these are the subgraphs whose cycle lengths we need to count.\ndef subgraphs(machine: Machine): Set[ModuleName] =\n  val terminal = (machine.sources.keySet -- machine.modules.keySet).head\n  machine.sources(machine.sources(terminal).head)\n\n// The problem 2 state machine is looking for the least common multiple of the\n// cycle lengths of the subgraphs that feed into the output "rx" module. When it\n// observes a high pulse from the final module of one these subgraphs, it\n// records the number of button presses to reach this state.\n\nfinal case class Problem2FSM(\n  cycles: Map[ModuleName, Long],\n)\n\nobject Problem2FSM:\n\n  def from(machine: Machine): Problem2FSM =\n    Problem2FSM(subgraphs(machine).map(_ -> 0L).toMap)\n\n  private def lcm(list: Iterable[Long]): Long =\n    list.foldLeft(1L)((a, b) => b * a / gcd(a, b))\n\n  @tailrec\n  private def gcd(x: Long, y: Long): Long =\n    if y == 0 then x else gcd(y, x % y)\n\n  def solution(fsm: Problem2FSM): Option[Long] =\n    import fsm.cycles\n    Option.when(cycles.values.forall(_ > 0))(lcm(cycles.values))\n\nextension (self: Problem2FSM)\n  inline def +(state: MachineFSM): Problem2FSM =\n    import self.*\n    state.queue.headOption match\n      case Some(Pulse(src, _, true)) if cycles.get(src).contains(0L) =>\n        copy(cycles = cycles + (src -> state.presses))\n      case _  => self\n\n// Part 2 is solved by first constructing the primary state machine that\n// executes the pulse machinery. Each state of this machine is then fed to a\n// second problem 2 state machine. We then run the combined state machines to\n// completion.\n\ndef part2(input: String): Long =\n  val machine = parse(input)\n  Iterator\n    .iterate(MachineFSM(machine))(nextState)\n    .scanLeft(Problem2FSM.from(machine))(_ + _)\n    .findMap(Problem2FSM.solution)\n')),(0,s.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day20.scala"},"Solution")," by ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2023/blob/main/2023-day20.scala"},"Solution")," by ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson"))),(0,s.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}h.isMDXComponent=!0}}]);