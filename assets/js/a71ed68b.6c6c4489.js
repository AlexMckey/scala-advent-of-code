"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[48],{2191:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return u},default:function(){return c}});var i=n(7462),a=n(3366),l=(n(7294),n(3905)),o=["components"],r={sidebar_position:1},p="Template 1: Report Repair",s={unversionedId:"puzzles/template1",id:"puzzles/template1",isDocsHomePage:!1,title:"Template 1: Report Repair",description:"by @adpi2",source:"@site/target/mdoc/puzzles/template1.md",sourceDirName:"puzzles",slug:"/puzzles/template1",permalink:"/scala-advent-of-code/puzzles/template1",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/template1.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Setup",permalink:"/scala-advent-of-code/setup"}},u=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution of Part 1",id:"solution-of-part-1",children:[{value:"About <code>Seq[Int]</code>",id:"about-seqint",children:[],level:3}],level:2},{value:"Solution of Part 2",id:"solution-of-part-2",children:[],level:2},{value:"Final solution",id:"final-solution",children:[{value:"Run it locally",id:"run-it-locally",children:[],level:3},{value:"Run it in the browser",id:"run-it-in-the-browser",children:[{value:"Part 1",id:"part-1",children:[],level:4},{value:"Part 2",id:"part-2",children:[],level:4}],level:3}],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],d={toc:u};function c(e){var t=e.components,n=(0,a.Z)(e,o);return(0,l.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"template-1-report-repair"},"Template 1: Report Repair"),(0,l.kt)("p",null,"by @adpi2"),(0,l.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2020/day/1"},"https://adventofcode.com/2020/day/1")),(0,l.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'@main def part1: Unit = \n  // read the input as a sequence of Int\n  val input: String = Source.fromFile("input/template1.part1").mkString\n  val entries: Seq[Int] = input.split(\'\\n\').map(_.toInt)\n  \n  // compute all the pairs of entries\n  val pairs: Seq[(Int, Int)] =\n    for \n      (x, i) <- entries.zipWithIndex\n      y <- entries.drop(i)\n    yield (x, y)\n  \n  // find the pair whose product is 2020\n  val solution = pairs.find((x, y) => x * y == 2020)\n\n  // print the solution\n  solution match\n    case Some((x, y)) => "The solution is ${x * y}"\n    case None => "No solution found"\n')),(0,l.kt)("h3",{id:"about-seqint"},"About ",(0,l.kt)("inlineCode",{parentName:"h3"},"Seq[Int]")),(0,l.kt)("p",null,"A value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[Int]")," is a sequence of integers.\nFor instance it can be ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq(156, 48, 674, 8481)")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"zipWithIndex")," is a method of  ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[Int]")," that associates each element with its index.\nIt returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[(Int, Int)]")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ Seq(156, 48, 674, 8481).zipWithIndex\nSeq((156, 0), (48, 1), (674, 2), (8481, 3))\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"drop(n: Int)")," is a method of ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[Int]")," that builds a new sequence of ",(0,l.kt)("inlineCode",{parentName:"p"},"Int")," by dropping ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," elements from the left."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ Seq(156, 48, 674, 8481).drop(2)\nSeq(674, 8481)\n")),(0,l.kt)("p",null,"We can build all the pairs of entries by iterating over all of them twice.\nOn the second iteration we need to skip the entries that we already saw.\nWe can do so by dropping the first ",(0,l.kt)("inlineCode",{parentName:"p"},"i + 1")," elements where ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," is the index of the first iteratee."),(0,l.kt)("p",null,"Hence we have:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val pairs: Seq[(Int, Int)] =\n  for \n    (x, i) <- entries.zipWithIndex\n    y <- entries.drop(i + 1)\n  yield (x, y)\n")),(0,l.kt)("h2",{id:"solution-of-part-2"},"Solution of Part 2"),(0,l.kt)("p",null,"In the second part we need to compute all the 3-tuples of elements instead of the pairs."),(0,l.kt)("p",null,"We can use a similar approach and iterate three times:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val tuples: Seq[(Int, Int, Int)] =\n  for \n    (x, i) <- entries.zipWithIndex\n    (y, j) <- entries.drop(i + 1)\n    z <- entries.drop(i + j + 1)\n  yield (x, y, z)\n")),(0,l.kt)("h2",{id:"final-solution"},"Final solution"),(0,l.kt)("p",null,"Is it possible to generalize the code that computes all the tuples of size ",(0,l.kt)("inlineCode",{parentName:"p"},"n"),"?"),(0,l.kt)("p",null,"Yes it is, and it is already implemented in the ",(0,l.kt)("inlineCode",{parentName:"p"},"scala-library")," under the method of ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[Int]")," called ",(0,l.kt)("inlineCode",{parentName:"p"},"combinations"),".\nWe can use this method to simplify our code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// using scala 3.0.2\n\npackage template1\n\nimport scala.io.Source\n\n@main def part1(): Unit =\n  val input = Source.fromFile("input/template1.part1").mkString\n  val answer = computeAnswer(2)(input)\n  println(s"The solution is $answer")\n\n@main def part2(): Unit =\n  val input = Source.fromFile("input/template1.part2").mkString\n  val answer = computeAnswer(3)(input)\n  println(s"The solution is $answer")\n\ndef computeAnswer(n: Int)(input: String): String =\n  val entries = input.split(\'\\n\').map(_.toInt).toSeq\n  val combinations = entries.combinations(n)\n  combinations.find(_.sum == 2020)\n    .map(_.product.toString)\n    .getOrElse(throw new Exception("No solution found"))\n')),(0,l.kt)("h3",{id:"run-it-locally"},"Run it locally"),(0,l.kt)("p",null,"You can get this solution locally by cloning the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd advent-of-code\n")),(0,l.kt)("p",null,"The you can run it with scala-cli:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ scala-cli . -M template1.part1\nThe answer is 970816\n\n$ scala-cli . -M template1.part2\nThe answer is 96047280\n")),(0,l.kt)("p",null,"Replace the ",(0,l.kt)("inlineCode",{parentName:"p"},"input/template1.part1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"input/template2.part2")," files with your own input from ",(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2020/day/1"},"adventofcode.com")," to get your own solution."),(0,l.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,l.kt)("h4",{id:"part-1"},"Part 1"),(0,l.kt)("div",{id:"template1-part1"}),(0,l.kt)("h4",{id:"part-2"},"Part 2"),(0,l.kt)("div",{id:"template1-part2"}),(0,l.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,l.kt)("p",null,"You can edit this page to add a link toward your solution."))}c.isMDXComponent=!0}}]);