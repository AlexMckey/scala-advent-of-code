"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3856],{2679:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905)),r=a(6340);const o={},l="Day 10: Cathode-Ray Tube",s={unversionedId:"2022/puzzles/day10",id:"2022/puzzles/day10",title:"Day 10: Cathode-Ray Tube",description:"code and article by Mewen Crespo (reviewed by Jamie Thompson)",source:"@site/target/mdoc/2022/puzzles/day10.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day10",permalink:"/scala-advent-of-code/2022/puzzles/day10",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day10.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 9: Rope Bridge",permalink:"/scala-advent-of-code/2022/puzzles/day09"},next:{title:"Day 11: Monkey in the Middle",permalink:"/scala-advent-of-code/2022/puzzles/day11"}},d={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-10-cathode-ray-tube"},"Day 10: Cathode-Ray Tube"),(0,i.kt)("p",null,"code and article by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/MewenCrespo"},"Mewen Crespo")," (reviewed by ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/bishabosha"},"Jamie Thompson"),")"),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/10"},"https://adventofcode.com/2022/day/10")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"Today's goal is to simulate the register's values over time. Once this is done, the rest falls in place rather quickly. From the puzzle description, we know there are two commands availaible: noop and addx. This can be implemented with a enum:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum Command:\n  case Noop\n  case Addx(x: Int)\n")),(0,i.kt)("p",null,"Now, we need to parse this commands from the string. This can be done using a for loop to match each line of the input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import Command.*\n\ndef commandsIterator(input: String): Iterator[Command] =\n  for line <- input.linesIterator yield line match\n    case "noop" => Noop\n    case s"addx $x" if x.toIntOption.isDefined => Addx(x.toInt)\n    case _ => throw IllegalArgumentException(s"Invalid command \'$line\'\'")\n')),(0,i.kt)("p",null,"Here you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"linesIterator")," to retrieve the lines (it returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator[String]"),") and mapped every line using a ",(0,i.kt)("inlineCode",{parentName:"p"},"for .. yield")," comprehension with a ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," body. Note the use of the string interpolator ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," for a simple way to parse strings."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Error checking:\nAlthought not necessary in this puzzle, it is a good practice to check the validity of the input. Here, we checked that the string matched with ",(0,i.kt)("inlineCode",{parentName:"p"},"$x")," is a valid integer string before entering the second case and throw an exception if none of the first cases were matched.")),(0,i.kt)("p",null,"Now we are ready to compute the registers values. We choose to implement it as an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator[Int]")," which will return the register's value each cycle at a time. For this, we need to loop throught the commands. If the command is a noop, then the next cycle will have the same value. If the command is a addx x then the next cycle will be the same value and the cycle afterward will be ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," more. There is an issue here: the addx command generates two cycles whereas the noop command generates only one."),(0,i.kt)("p",null,"To circumvent this issue, generate an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator[List[Int]]")," first which will be flattened afterwards. The first iterator is constructed using the scanLeft method to yield the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val RegisterStartValue = 1\n\ndef registerValuesIterator(input: String): Iterator[Int] =\n  val steps = commandsIterator(input).scanLeft(RegisterStartValue :: Nil) { (values, cmd) =>\n    val value = values.last\n    cmd match\n      case Noop => value :: Nil\n      case Addx(x) => value :: value + x :: Nil\n  }\n  steps.flatten\n")),(0,i.kt)("p",null,"Notice that at each step we call ",(0,i.kt)("inlineCode",{parentName:"p"},".last")," on the accumulated ",(0,i.kt)("inlineCode",{parentName:"p"},"List[Int]")," value which, in this case, is the register's value at the start of the last cycle."),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"In the first part, the challenge asks you to compute the strength at the 20th cycle and then every 40th cycle. This can be done using a combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"drop")," (to skip the first 19 cycles), grouped (to group the cycles by 40) and ",(0,i.kt)("inlineCode",{parentName:"p"},"map(_.head)")," (to only take the first cycle of each group of 40). The computation of the strengths is, on the other hand, done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"zipWithIndex")," method and a ",(0,i.kt)("inlineCode",{parentName:"p"},"for ... yield")," comprehension. This leads to the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def registerStrengthsIterator(input: String): Iterator[Int] =\n  val it = for (reg, i) <- registerValuesIterator(input).zipWithIndex yield (i + 1) * reg\n  it.drop(19).grouped(40).map(_.head)\n")),(0,i.kt)("p",null,"The result of Part 1 is the sum of this iterator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int = registerStrengthsIterator(input).sum\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"In the second part, we are asked to draw a CRT output. As stated in the puzzle description, the register is interpreted as the position of a the sprite ",(0,i.kt)("inlineCode",{parentName:"p"},"###"),". The CRT iterates throught each line and, if the sprites touches the touches the current position, draws a ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),". Otherwise the CRT draws a ",(0,i.kt)("inlineCode",{parentName:"p"},"."),". The register's cycles are stepped in synced with the CRT."),(0,i.kt)("p",null,"First, the CRT's position is just the cycle's index modulo the CRT's width (40 in our puzzle). Then, the CRT draw the sprite if and only if the register's value is the CRT's position, one more or one less. In other words, if ",(0,i.kt)("inlineCode",{parentName:"p"},"(reg_value - (cycle_id % 40)).abs <= 1"),". Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"zipWithIndex")," method to obtain the cycles' indexes we end up with the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val CRTWidth: Int = 40\n\ndef CRTCharIterator(input: String): Iterator[Char] =\n  for (reg, crtPos) <- registerValuesIterator(input).zipWithIndex yield\n    if (reg - (crtPos % CRTWidth)).abs <= 1 then\n      '#'\n    else\n      '.'\n")),(0,i.kt)("p",null,"Now, concatenate the chars and add new lines at the required places. This is done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"mkString")," methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): String =\n  CRTCharIterator(input).grouped(CRTWidth).map(_.mkString).mkString("\\n")\n')),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import Command.*\n\ndef part1(input: String): Int =\n  registerStrengthsIterator(input).sum\n\ndef part2(input: String): String =\n  CRTCharIterator(input).grouped(CRTWidth).map(_.mkString).mkString("\\n")\n\nenum Command:\n  case Noop\n  case Addx(x: Int)\n\ndef commandsIterator(input: String): Iterator[Command] =\n  for line <- input.linesIterator yield line match\n    case "noop" => Noop\n    case s"addx $x" if x.toIntOption.isDefined => Addx(x.toInt)\n    case _ => throw IllegalArgumentException(s"Invalid command \'$line\'\'")\n\nval RegisterStartValue = 1\n\ndef registerValuesIterator(input: String): Iterator[Int] =\n  val steps = commandsIterator(input).scanLeft(RegisterStartValue :: Nil) { (values, cmd) =>\n    val value = values.last\n    cmd match\n      case Noop => value :: Nil\n      case Addx(x) => value :: value + x :: Nil\n  }\n  steps.flatten\n\ndef registerStrengthsIterator(input: String): Iterator[Int] =\n  val it = for (reg, i) <- registerValuesIterator(input).zipWithIndex yield (i + 1) * reg\n  it.drop(19).grouped(40).map(_.head)\n\nval CRTWidth: Int = 40\n\ndef CRTCharIterator(input: String): Iterator[Char] =\n  for (reg, crtPos) <- registerValuesIterator(input).zipWithIndex yield\n    if (reg - (crtPos % CRTWidth)).abs <= 1 then\n      \'#\'\n    else\n      \'.\'\n')),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1-1"},"Part 1"),(0,i.kt)(r.Z,{puzzle:"day10-part1",year:"2022",mdxType:"Solver"}),(0,i.kt)("h4",{id:"part-2-1"},"Part 2"),(0,i.kt)(r.Z,{puzzle:"day10-part2",year:"2022",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day10.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2022/blob/master/src/main/scala/day10/Day10.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2022/src/test/scala/Day10.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day10.scala"},"Solution")," by Cosmin Ciobanu"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day10.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau/code-advent-2022/blob/master/src/main/scala/com/adventofcode/Day10.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau"},"Daniel Naumau"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}c.isMDXComponent=!0}}]);