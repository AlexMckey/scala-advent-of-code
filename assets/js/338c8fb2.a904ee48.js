"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6324],{9130:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=t(7462),l=(t(7294),t(3905)),i=t(6340);const o={},r="Day 20: Trench Map",s={unversionedId:"puzzles/day20",id:"puzzles/day20",title:"Day 20: Trench Map",description:"Puzzle description",source:"@site/target/mdoc/puzzles/day20.md",sourceDirName:"puzzles",slug:"/puzzles/day20",permalink:"/scala-advent-of-code/puzzles/day20",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day20.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 19: Beacon Scanner",permalink:"/scala-advent-of-code/puzzles/day19"},next:{title:"Day 21: Dirac Dice",permalink:"/scala-advent-of-code/puzzles/day21"}},p={},h=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Modeling and parsing the input",id:"modeling-and-parsing-the-input",level:2},{value:"Image enhancement algorithm",id:"image-enhancement-algorithm",level:2},{value:"Solution of part 1",id:"solution-of-part-1",level:2},{value:"Full code for part 1",id:"full-code-for-part-1",level:2},{value:"Solution for part 2",id:"solution-for-part-2",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Run it locally",id:"run-it-locally",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:h};function d(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"day-20-trench-map"},"Day 20: Trench Map"),(0,l.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/20"},"https://adventofcode.com/2021/day/20")),(0,l.kt)("h2",{id:"modeling-and-parsing-the-input"},"Modeling and parsing the input"),(0,l.kt)("p",null,"The input is an image enhancement algorithm string, and an initial input image."),(0,l.kt)("p",null,"The image is a black and white rectangle. We model the pixels with an\nenumeration:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"enum Pixel:\n  case Lit, Dark\n")),(0,l.kt)("p",null,"A pixel can either be lit, or dark."),(0,l.kt)("p",null,'In the input text, lit pixels are represented by the character "#", whereas\ndark pixels are represented by the character "." (dot). We use pattern\nmatching to parse them:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object Pixel:\n  def parse(char: Char): Pixel =\n    char match\n      case '#' => Pixel.Lit\n      case '.' => Pixel.Dark\nend Pixel\n")),(0,l.kt)("p",null,'In case the input is malformed (ie, it contains a character other than "#"\nor "."), the method ',(0,l.kt)("inlineCode",{parentName:"p"},"parse")," raises an exception."),(0,l.kt)("p",null,"The enhancement algorithm string is provided as a line of 512 pixels. We\nparse it as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"class Enhancer(enhancementString: IndexedSeq[Pixel])\n\nobject Enhancer:\n  def parse(input: String): Enhancer =\n    Enhancer(input.map(Pixel.parse))\nend Enhancer\n")),(0,l.kt)("p",null,"There is a subtlety regarding the input image to which we want to apply the\nenhancement algorithm: its size is infinite. Initially, its pixels are all\ndark except in the rectangle we are given as initial input. So, we model an\nimage as a two-dimensional indexed sequence, and the color of all the pixels\nthat are out of the bounds of that two-dimensional indexed sequence:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'class Image(pixels: IndexedSeq[IndexedSeq[Pixel]], outOfBoundsPixel: Pixel):\n  require(pixels.map(_.length).distinct.size == 1, "All the rows must have the same length")\n\n  val height = pixels.length\n  val width  = pixels(0).length\n')),(0,l.kt)("p",null,"Since there is no direct way to model two-dimensional collections in the\nstandard library, we model the table of pixels as a collection of rows,\nwhere each row is a collection of pixels. We add the call to ",(0,l.kt)("inlineCode",{parentName:"p"},"require")," to\nmake sure that all the lines have the same length."),(0,l.kt)("p",null,"We parse the input image by parsing every line of the provided rectangular\narea, and by setting the color of the out-of-bounds pixels to ",(0,l.kt)("inlineCode",{parentName:"p"},"Dark"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object Image:\n  def parse(input: String): Image =\n    val pixels =\n      input\n        .linesIterator.map(line => line.map(Pixel.parse))\n        .toIndexedSeq\n    val outOfBoundsPixel = Pixel.Dark\n    Image(pixels, outOfBoundsPixel)\nend Image\n")),(0,l.kt)("p",null,"Last, we parse both sections of the input with the following method:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'def parseEnhancerAndImage(input: String): (Enhancer, Image) =\n  val enhancerAndImage = input.split("\\n\\n")\n  val enhancer         = Enhancer.parse(enhancerAndImage(0))\n  val image            = Image.parse(enhancerAndImage(1))\n  (enhancer, image)\n')),(0,l.kt)("h2",{id:"image-enhancement-algorithm"},"Image enhancement algorithm"),(0,l.kt)("p",null,"The image enhancement algorithm needs to compute an integer value for every\nlocation of the input image. The integer value is made of 9 bits, whose\nvalue is taken from the state of the 9 pixels around the location (a lit\npixel means ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),", and a dark pixel means ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),")."),(0,l.kt)("p",null,"That 9-bit integer value is then used as an index in the enhancement\nalgorithm string to find the state of the output pixel at that location."),(0,l.kt)("p",null,"We implement the algorithm as a method of the class ",(0,l.kt)("inlineCode",{parentName:"p"},"Enhancer"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"\nclass Enhancer(enhancementString: IndexedSeq[Pixel]):\n\n  def enhance(image: Image): Image =\n    val pixels =\n      for y <- -1 until (image.height + 1)\n      yield\n        for x <- -1 until (image.width + 1)\n        yield enhancementString(locationValue(image, x, y))\n\n    val outOfBoundsPixel =\n      val value = if image.outOfBoundsPixel == Pixel.Dark then 0 else 511\n      enhancementString(value)\n\n    Image(pixels, outOfBoundsPixel)\n  end enhance\n\nend Enhancer\n")),(0,l.kt)("p",null,"Since we look at the 9 pixels around every location, we look at locations\noutside the image rectangle where some of these 9 pixels overlap with the\nrectangle (hence the bounds ",(0,l.kt)("inlineCode",{parentName:"p"},"-1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"height + 1")," for the ",(0,l.kt)("inlineCode",{parentName:"p"},"y")," coordinates)."),(0,l.kt)("p",null,"The 9-bit integer value of each location is computed by an auxiliary method,\n",(0,l.kt)("inlineCode",{parentName:"p"},"locationValue"),", which is shown below."),(0,l.kt)("p",null,"Last, we also compute the \u201cenhancement\u201d of the pixels that are out of the\nbounds of the image rectangle. Since these pixels are all the same, the 9\npixels around any location out of the bounds of the rectangle will always be\neither all lit or all dark. The binary value corresponding to all pixels\ndark is ",(0,l.kt)("inlineCode",{parentName:"p"},"000000000"),", which equals ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),", and the binary value corresponding to\nall pixels lit is ",(0,l.kt)("inlineCode",{parentName:"p"},"111111111"),", which equals ",(0,l.kt)("inlineCode",{parentName:"p"},"511"),"."),(0,l.kt)("p",null,"Here is the implementation of the auxiliary method ",(0,l.kt)("inlineCode",{parentName:"p"},"locationValue"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def locationValue(image: Image, x: Int, y: Int): Int =\n  var result = 0\n  for\n    yy <- (y - 1) to (y + 1)\n    xx <- (x - 1) to (x + 1)\n  do\n    result = result << 1\n    if image.pixel(xx, yy) == Pixel.Lit then\n      result = result | 1\n    end if\n  end for\n  result\nend locationValue\n")),(0,l.kt)("p",null,"We read the 9 pixels around the provided location, starting from the\ntop-left corner, and going to the right. If a pixel is lit, we interpret it\nas a ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),". At every iteration, we shift the previously computed result one\nbit to the left before reading the new bit."),(0,l.kt)("p",null,"To read the pixel value in the image, we use a handy method ",(0,l.kt)("inlineCode",{parentName:"p"},"pixel"),", defined\nin the class ",(0,l.kt)("inlineCode",{parentName:"p"},"Image"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def pixel(x: Int, y: Int): Pixel =\n  if y < 0 || y >= height then outOfBoundsPixel\n  else if x < 0 || x >= width then outOfBoundsPixel\n  else pixels(y)(x)\n")),(0,l.kt)("p",null,"This method implements the fact that the image has an infinite size. It\nchecks the bounds of the location to access, and when the location is out of\nthe bounds of the rectangle image, it returns the ",(0,l.kt)("inlineCode",{parentName:"p"},"outOfBoundsPixel")," color\nof the image."),(0,l.kt)("h2",{id:"solution-of-part-1"},"Solution of part 1"),(0,l.kt)("p",null,"We were asked to apply two times in a row the enhancement algorithm on the\ninput image, and to compute the number of lit pixels in the output image:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val (enhancer, image0) = parseEnhancerAndImage(input)\n  val image1 = enhancer.enhance(image0)\n  val image2 = enhancer.enhance(image1)\n  image2.countLitPixels()\n")),(0,l.kt)("p",null,"The method ",(0,l.kt)("inlineCode",{parentName:"p"},"countLitPixels")," is defined as follows in the class ",(0,l.kt)("inlineCode",{parentName:"p"},"Image"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"class Image(pixels: IndexedSeq[IndexedSeq[Pixel]], outOfBoundsPixel: Pixel):\n  def countLitPixels(): Int =\n    pixels.view.flatten.count(_ == Pixel.Lit)\n")),(0,l.kt)("p",null,"We flatten the rows of pixels into a single collection of pixels, and we\ncount the lit pixels on it. The call to ",(0,l.kt)("inlineCode",{parentName:"p"},"view")," before ",(0,l.kt)("inlineCode",{parentName:"p"},"flatten")," allows us to\ntraverse the rows of pixels without constructing the flattened collection."),(0,l.kt)("h2",{id:"full-code-for-part-1"},"Full code for part 1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val (enhancer, image0) = parseEnhancerAndImage(input)\n  val image1 = enhancer.enhance(image0)\n  val image2 = enhancer.enhance(image1)\n  image2.countLitPixels()\n\ndef parseEnhancerAndImage(input: String): (Enhancer, Image) =\n  val enhancerAndImage = input.split(\"\\n\\n\")\n  val enhancer         = Enhancer.parse(enhancerAndImage(0))\n  val image            = Image.parse(enhancerAndImage(1))\n  (enhancer, image)\n\nenum Pixel:\n  case Lit, Dark\n\nobject Pixel:\n\n  def parse(char: Char): Pixel =\n    char match\n      case '#' => Pixel.Lit\n      case '.' => Pixel.Dark\n\nend Pixel\n\nobject Enhancer:\n\n  def parse(input: String): Enhancer =\n    Enhancer(input.map(Pixel.parse))\n\nend Enhancer\n\nclass Enhancer(enhancementString: IndexedSeq[Pixel]):\n\n  def enhance(image: Image): Image =\n    val pixels =\n      for y <- -1 until (image.height + 1)\n      yield\n        for x <- -1 until (image.width + 1)\n        yield enhancementString(locationValue(image, x, y))\n\n    val outOfBoundsPixel =\n      val value = if image.outOfBoundsPixel == Pixel.Dark then 0 else 511\n      enhancementString(value)\n\n    Image(pixels, outOfBoundsPixel)\n  end enhance\n\n  private def locationValue(image: Image, x: Int, y: Int): Int =\n    var result = 0\n    for\n      yy <- (y - 1) to (y + 1)\n      xx <- (x - 1) to (x + 1)\n    do\n      result = result << 1\n      if image.pixel(xx, yy) == Pixel.Lit then\n        result = result | 1\n      end if\n    end for\n    result\n  end locationValue\n\nend Enhancer\n\nclass Image(pixels: IndexedSeq[IndexedSeq[Pixel]], val outOfBoundsPixel: Pixel):\n\n  require(pixels.map(_.length).distinct.size == 1, \"All the rows must have the same length\")\n\n  val height = pixels.length\n  val width  = pixels(0).length\n\n  def pixel(x: Int, y: Int): Pixel =\n    if y < 0 || y >= height then outOfBoundsPixel\n    else if x < 0 || x >= width then outOfBoundsPixel\n    else pixels(y)(x)\n\n  def countLitPixels(): Int =\n    pixels.view.flatten.count(_ == Pixel.Lit)\n\nend Image\n\nobject Image:\n  def parse(input: String): Image =\n    val pixels =\n      input\n        .linesIterator.map(line => line.map(Pixel.parse))\n        .toIndexedSeq\n    val outOfBoundsPixel = Pixel.Dark\n    Image(pixels, outOfBoundsPixel)\n")),(0,l.kt)("h2",{id:"solution-for-part-2"},"Solution for part 2"),(0,l.kt)("p",null,"In part 2, we had to apply the \u201cenhancement algorithm\u201d 50 times instead\nof just twice:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int =\n  val (enhancer, image) = parseEnhancerAndImage(input)\n  LazyList\n    .iterate(image)(enhancer.enhance)\n    .apply(50)\n    .countLitPixels()\n")),(0,l.kt)("p",null,"We parse the input with the same method as in part1, ",(0,l.kt)("inlineCode",{parentName:"p"},"parseEnhancerAndImage"),"."),(0,l.kt)("p",null,"To apply the enhancer 50 times, we use a ",(0,l.kt)("inlineCode",{parentName:"p"},"LazyList"),". First, we create an\n",(0,l.kt)("em",{parentName:"p"},"infinite")," lazy list whose first element is the parsed input ",(0,l.kt)("inlineCode",{parentName:"p"},"image"),", and\nwhose ",(0,l.kt)("inlineCode",{parentName:"p"},"n + 1")," element is computed by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"enhancer.enhance")," on the\nelement ",(0,l.kt)("inlineCode",{parentName:"p"},"n"),". Then, we compute its 50th element by calling ",(0,l.kt)("inlineCode",{parentName:"p"},".apply(50)"),". As a\nconsequence, only the first 50 elements will be computed at all."),(0,l.kt)("p",null,"Finally, we call ",(0,l.kt)("inlineCode",{parentName:"p"},"countLitPixels()")," on the output image to count its number\nof lit pixels."),(0,l.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,l.kt)("h3",{id:"part-1"},"Part 1"),(0,l.kt)(i.Z,{puzzle:"day20-part1",year:"2021",mdxType:"Solver"}),(0,l.kt)("h3",{id:"part-2"},"Part 2"),(0,l.kt)(i.Z,{puzzle:"day20-part2",year:"2021",mdxType:"Solver"}),(0,l.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,l.kt)("p",null,"You can get this solution locally by cloning the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,l.kt)("p",null,"You can run it with ",(0,l.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ scala-cli 2021 -M day20.part1\nThe solution is: 5301\n$ scala-cli 2021 -M day20.part2\nThe solution is: 19492\n")),(0,l.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day20.scala"},"Solution")," of ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),".")),(0,l.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}d.isMDXComponent=!0}}]);