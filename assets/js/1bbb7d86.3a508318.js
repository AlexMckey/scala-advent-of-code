"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[856],{2679:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(7462),r=(a(7294),a(3905)),i=a(6340);const o={},s="Day 10: Cathode-Ray Tube",l={unversionedId:"2022/puzzles/day10",id:"2022/puzzles/day10",title:"Day 10: Cathode-Ray Tube",description:"code and article by Mewen Crespo (reviewed by Jamie Thompson)",source:"@site/target/mdoc/2022/puzzles/day10.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day10",permalink:"/scala-advent-of-code/2022/puzzles/day10",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day10.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 9: Rope Bridge",permalink:"/scala-advent-of-code/2022/puzzles/day09"},next:{title:"Day 1: Sonar Sweep",permalink:"/scala-advent-of-code/puzzles/day1"}},d={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"day-10-cathode-ray-tube"},"Day 10: Cathode-Ray Tube"),(0,r.kt)("p",null,"code and article by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/MewenCrespo"},"Mewen Crespo")," (reviewed by ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/bishabosha"},"Jamie Thompson"),")"),(0,r.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/10"},"https://adventofcode.com/2022/day/10")),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("p",null,"Today's goal is to simulate the register's values over time. Once this is done, the rest falls in place rather quickly. From the puzzle description, we know there are two commands availaible: noop and addx. This can be implemented with a enum:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"enum Command {\n  case NOOP\n  case ADDX(X: Int)\n}\n")),(0,r.kt)("p",null,"Now, we need to parse this commands from the string. This can be done using a for loop to match each line of the input:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def commandsIterator(input: String): Iterator[Command] = for (line <- input.linesIterator) yield line.strip match {\n  case "noop" => NOOP\n  case s"addx $x" if x.toIntOption.isDefined => ADDX(x.toInt)\n  case _ => throw IllegalArgumentException(s"Invalid command \'$line\'\'")\n}\n')),(0,r.kt)("p",null,"Here you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"linesIterator")," to retrieve the lines (it returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator[String]"),") and mapped every line using a for .. yield .. match comprehension. Note the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"line.strip")," to remove any white space character and the string interpolator ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," for a simple way to parse strings."),(0,r.kt)("p",null,":::Error checking\nAlthought not necessary in this puzzle, it is a good practice to check the validity of the input. Here, we checked that the string matched with ",(0,r.kt)("inlineCode",{parentName:"p"},"$x")," is a valid integer string before entering the second case and returned an error if none of the first cases were matched.\n:::"),(0,r.kt)("p",null,"Now we are ready to compute the registers values. We choose to implement it as an ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator[Int]")," which will return the register's value each cycle at a time. For this, we need to loop throught the commands. If the command is a noop, then the next cycle will have the same value. If the command is a addx x then the next cycle will be the same value and the cycle afterward will be ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," more. There is an issue here: the addx command generates two cycles whereas the noop command generates only one."),(0,r.kt)("p",null,"To circumvent this issue, generate an ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator[List[Int]]")," first which will be flattened afterwards. The first iterator is constructed using the scanLeft method to yield the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val RegisterStartValue = 1\n\ndef registerValuesIterator(input: String): Iterator[Int] = {\n  commandsIterator(input).scanLeft(RegisterStartValue :: Nil) {\n    case (_ :+ value, NOOP) => value :: Nil\n    case (_ :+ value, ADDX(x)) => value :: value + x :: Nil\n  }\n}.flatten\n")),(0,r.kt)("p",null,"Notice the use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"_ :+ value")," pattern to match the last value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"List[Int]")," which, in our case, is the register's value at the start of the last cycle."),(0,r.kt)("h3",{id:"part-1"},"Part 1"),(0,r.kt)("p",null,"In the first part, we are asked to compute the strength at the 20th cycle and then every 40th cycle. This can be done using a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"drop")," (to skip the first 19 cycles), grouped (to group the cycles by 40) and ",(0,r.kt)("inlineCode",{parentName:"p"},"map(_.head)")," (to only take the first cycle of each group of 40). The computation of the strengths is, on the other hand, done using the ",(0,r.kt)("inlineCode",{parentName:"p"},"zipWithIndex")," method and a for ... yield comprehension. This leads to the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def registerStrengthsIterator(input: String): Iterator[Int] = {\n  val it = for ((reg, i) <- registerValuesIterator(input).zipWithIndex) yield (i + 1) * reg\n  it.drop(19).grouped(40).map(_.head)\n}\n")),(0,r.kt)("p",null,"The result of Part 1 is the sum of this iterator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int = registerStrengthsIterator(input).sum\n")),(0,r.kt)("h3",{id:"part-2"},"Part 2"),(0,r.kt)("p",null,"In the second part, we are asked to draw a CRT output. As stated in the puzzle description, the register is interpreted as the position of a the sprite ",(0,r.kt)("inlineCode",{parentName:"p"},"###"),". The CRT iterates throught each line and, if the sprites touches the touches the current position, draws a ",(0,r.kt)("inlineCode",{parentName:"p"},"#"),". Otherwise the CRT draws a ",(0,r.kt)("inlineCode",{parentName:"p"},"."),". The register's cycles are stepped in synced with the CRT."),(0,r.kt)("p",null,"First, the CRT's position is just the cycle's index modulo the CRT's width (40 in our puzzle). Then, the CRT draw the sprite if and only if the register's value is the CRT's position, one more or one less. In other words, if ",(0,r.kt)("inlineCode",{parentName:"p"},"(reg_value - (cycle_id % 40)).abs <= 1"),". Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"zipWithIndex")," method to obtain the cycles' indexes we end up with the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val CRTWidth: Int = 40\n\ndef CRTCharIterator(input: String): Iterator[Char] =\n  for ((reg, crt_pos) <- registerValuesIterator(input).zipWithIndex) yield {\n    if ((reg - (crt_pos % CRTWidth)).abs <= 1) '#' else '.'\n  }\n")),(0,r.kt)("p",null,"Now, concatenate the chars and add new lines at the required places. This is done using the ",(0,r.kt)("inlineCode",{parentName:"p"},"mkString")," methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): String = CRTCharIterator(input).grouped(CRTWidth).map(_.mkString).mkString("\\n")\n')),(0,r.kt)("h2",{id:"final-code"},"Final Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'enum Command {\n  case NOOP\n  case ADDX(X: Int)\n}\n\nexport Command.*\n\ndef commandsIterator(input: String): Iterator[Command] = for (line <- input.linesIterator) yield line.strip match {\n  case "noop" => NOOP\n  case s"addx $x" if x.toIntOption.isDefined => ADDX(x.toInt)\n  case _ => throw IllegalArgumentException(s"Invalid command \'$line\'\'")\n}\n\nval RegisterStartValue = 1\n\ndef registerValuesIterator(input: String): Iterator[Int] = {\n  commandsIterator(input).scanLeft(RegisterStartValue :: Nil) {\n    case (_ :+ value, NOOP) => value :: Nil\n    case (_ :+ value, ADDX(x)) => value :: value + x :: Nil\n  }\n}.flatten\n\ndef registerStrengthsIterator(input: String): Iterator[Int] = {\n  val it = for ((reg, i) <- registerValuesIterator(input).zipWithIndex) yield (i + 1) * reg\n  it.drop(19).grouped(40).map(_.head)\n}\n\ndef part1(input: String): Int = registerStrengthsIterator(input).sum\n\nval CRTWidth: Int = 40\n\ndef CRTCharIterator(input: String): Iterator[Char] =\n  for ((reg, crt_pos) <- registerValuesIterator(input).zipWithIndex) yield {\n    if ((reg - (crt_pos % CRTWidth)).abs <= 1) \'#\' else \'.\'\n  }\n\ndef part2(input: String): String = CRTCharIterator(input).grouped(CRTWidth).map(_.mkString).mkString("\\n")\n')),(0,r.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,r.kt)("h4",{id:"part-1-1"},"Part 1"),(0,r.kt)(i.Z,{puzzle:"day10-part1",year:"2022",mdxType:"Solver"}),(0,r.kt)("h4",{id:"part-2-1"},"Part 2"),(0,r.kt)(i.Z,{puzzle:"day10-part2",year:"2022",mdxType:"Solver"}),(0,r.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day10.scala"},"Solution")," of ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins"))),(0,r.kt)("p",null,"Share your solution to the Scala community by editing this page."))}u.isMDXComponent=!0}}]);