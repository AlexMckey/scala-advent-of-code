"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3047],{1573:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));n(6340);const l={},o="Day 24: Never Tell Me The Odds",s={unversionedId:"2023/puzzles/day24",id:"2023/puzzles/day24",title:"Day 24: Never Tell Me The Odds",description:"by @merlinorg",source:"@site/target/mdoc/2023/puzzles/day24.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day24",permalink:"/scala-advent-of-code/2023/puzzles/day24",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day24.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 23: A Long Walk",permalink:"/scala-advent-of-code/2023/puzzles/day23"},next:{title:"Day 25: Snowverload",permalink:"/scala-advent-of-code/2023/puzzles/day25"}},r={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Summary",id:"summary",level:2},{value:"Model",id:"model",level:2},{value:"Hail",id:"hail",level:3},{value:"2D Hail",id:"2d-hail",level:3},{value:"Parsing",id:"parsing",level:3},{value:"2D Line Intersection",id:"2d-line-intersection",level:2},{value:"Point of Intersection",id:"point-of-intersection",level:3},{value:"Time of Intersection",id:"time-of-intersection",level:3},{value:"Part 1 Solution",id:"part-1-solution",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Mathing It",id:"mathing-it",level:3},{value:"Working It",id:"working-it",level:3},{value:"Shifting Perspective",id:"shifting-perspective",level:4},{value:"Determining the Origin of the Rock",id:"determining-the-origin-of-the-rock",level:3},{value:"Optimizing Our Search Space",id:"optimizing-our-search-space",level:3},{value:"Part 2 Solution",id:"part-2-solution",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:c};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-24-never-tell-me-the-odds"},"Day 24: Never Tell Me The Odds"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/merlinorg"},"@merlinorg")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/24"},"https://adventofcode.com/2023/day/24")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"Day 24 involves calculating the intersections of the lines that some hailstones\ntrace in 2D, and then determining the linear trajectory for a rock in 3D that\nwill intersect the trajectories of all the hailstones in the model."),(0,i.kt)("h2",{id:"model"},"Model"),(0,i.kt)("h3",{id:"hail"},"Hail"),(0,i.kt)("p",null,"A hailstone has an initial location and velocity in 3D space."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Hail(x: Long, y: Long, z: Long, vx: Long, vy: Long, vz: Long)\n")),(0,i.kt)("h3",{id:"2d-hail"},"2D Hail"),(0,i.kt)("p",null,"The first part of this problem asks us to consider just the two-dimensional\nXY trajectory of the hailstone, so we add a model for this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Hail2D(x: Long, y: Long, vx: Long, vy: Long)\n")),(0,i.kt)("p",null,"and then add a method ",(0,i.kt)("inlineCode",{parentName:"p"},"xyProjection")," method to Hail to get a 2D projection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Inside class Hail:\n  def xyProjection: Hail2D = Hail2D(x, y, vx, vy)\n")),(0,i.kt)("h3",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"To parse the input we just pattern match each line. The sample input\nhas some extra whitespace so we need to trim the numbers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parseAll(input: String): Vector[Hail] =\n  input.linesIterator.toVector.map:\n    case s"$x, $y, $z @ $dx, $dy, $dz" =>\n      Hail(x.trim.toLong, y.trim.toLong, z.trim.toLong,\n            dx.trim.toLong, dy.trim.toLong, dz.trim.toLong)\n')),(0,i.kt)("h2",{id:"2d-line-intersection"},"2D Line Intersection"),(0,i.kt)("p",null,"2D line intersection is ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection"},"simple geometry"),". Two infinite lines\nwill always intersect at some point unless they are parallel."),(0,i.kt)("h3",{id:"point-of-intersection"},"Point of Intersection"),(0,i.kt)("p",null,"To help solve the problem, you can represent the trajectory of the hail as a general polynomial\n",(0,i.kt)("em",{parentName:"p"},"ax + by + c = 0")," and use ",(0,i.kt)("a",{parentName:"p",href:"https://www.cuemath.com/geometry/intersection-of-two-lines/"},"an equation"),"\nfor the intersection.\nIf the denominator is zero then the lines are parallel and there is no solution."),(0,i.kt)("p",null,"Add ",(0,i.kt)("inlineCode",{parentName:"p"},"intersect")," to Hail2D as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// inside class Hail2D\n  private val a: BigDecimal = BigDecimal(vy)\n  private val b: BigDecimal = BigDecimal(-vx)\n  private val c: BigDecimal = BigDecimal(vx * y - vy * x)\n\n  def intersect(hail: Hail2D): Option[(BigDecimal, BigDecimal)] =\n    val denominator = a * hail.b - hail.a * b\n    Option.when(denominator != 0):\n      ((b * hail.c - hail.b * c) / denominator,\n       (c * hail.a - hail.c * a) / denominator)\n")),(0,i.kt)("h3",{id:"time-of-intersection"},"Time of Intersection"),(0,i.kt)("p",null,"In addition to knowing where the hailstone trajectories intersect,\nwe need to know when the hailstones arrive at this point. This lets\nus know whether the intersection occurs in the hailstone's future or\npast."),(0,i.kt)("p",null,"Add ",(0,i.kt)("inlineCode",{parentName:"p"},"timeTo")," to Hail2D as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// inside class Hail2D\n  def timeTo(posX: BigDecimal, posY: BigDecimal): BigDecimal =\n    if vx == 0 then (posY - y) / vy else (posX - x) / vx\n")),(0,i.kt)("h2",{id:"part-1-solution"},"Part 1 Solution"),(0,i.kt)("p",null,"Part 1 asks us to count how many pairs of hailstone have a trajectory\nthat intersects in the 2D XY projection, within a given area, in the\nhailstone's future, but not necessarily simultaneously."),(0,i.kt)("p",null,"We iterate through all pairs of hailstones, determining whether their\ntrajectories intersect, and if so if it satisfies the spatial and\ntemporal constraints."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def intersections(\n  hails: Vector[Hail2D],\n  min: Long,\n  max: Long\n): Vector[(Hail2D, Hail2D)] =\n  for\n    (hail0, hail1) <- hails.allPairs\n    (x, y)         <- hail0.intersect(hail1)\n    if x >= min && x <= max && y >= min && y <= max &&\n       hail0.timeTo(x, y) >= 0 && hail1.timeTo(x, y) >= 0\n  yield (hail0, hail1)\n")),(0,i.kt)("p",null,"This takes advantage of an extension method for determining all the\npairs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension [A](self: Vector[A])\n  def allPairs: Vector[(A, A)] = self.tails.toVector.tail.flatMap(self.zip)\n")),(0,i.kt)("p",null,"Our solution is then to just parse the hailstones, project them onto\nthe XY plane and then count the intersections."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Long =\n  val hails = parseAll(input)\n  val hailsXY = hails.map(_.xyProjection)\n  intersections(hailsXY, 200000000000000L, 400000000000000L).size\n")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Part 2 is, at first blush, much more complex. It asks us to determine\nthe location and velocity of a rock that will strike every one of the\nhailstones, meeting each one at some location in time and space."),(0,i.kt)("h3",{id:"mathing-it"},"Mathing It"),(0,i.kt)("p",null,"The mathematician in us just wants to solve this directly. Considering\na rock at ",(0,i.kt)("em",{parentName:"p"},"x, y, z")," with velocity ",(0,i.kt)("em",{parentName:"p"},"vx, vy, vz")," and a hailstone\n",(0,i.kt)("em",{parentName:"p"},"x1, y1, z1, vx1, vy1, vz1"),", the collision will occur at time ",(0,i.kt)("em",{parentName:"p"},"t1"),"\nresulting in three equations in seven variables."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"x + vx.t1 = x1 + vx1.t1, y + vy.t1 = y1 + vy1.t1, z + vy.t1 = z1 + vz1.t1")),(0,i.kt)("p",null,"Considering hailstones 2 and 3, we add six more equations and two\nmore variables, giving us nine equations and nine variables."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"x + vx.t2 = x2 + vx2.t2, y + vy.t2 = y2 + vy2.t2, z + vy.t2 = z2 + vz2.t2")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"x + vx.t3 = x3 + vx3.t3, y + vy.t3 = y3 + vy3.t3, z + vy.t3 = z3 + vz3.t3")),(0,i.kt)("p",null,"These are not linear equations, but any non-unique solution requires a\ncontrived hailstone configuration that we don't really need to consider.\nPlugging these into ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Z3Prover/z3"},"Z3")," or Mathematica\ngives us an exact solution with no more effort. And, indeed,\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/epfl-lara/ScalaZ3"},"ScalaZ3")," wraps Z3 and gives\nus a convenient scala API, as demonstrated by\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/beneyal/aoc-2023/blob/main/src/main/scala/day24.scala"},"@beneyal's solution"),"."),(0,i.kt)("h3",{id:"working-it"},"Working It"),(0,i.kt)("p",null,"For the purpose of this exercise, I did not use Z3. I instead used the\nobservation that from the perspective of the rock (which, from its own\nperspective, is stationary), all the hailstones will appear to be on a\ndirect collision path with it, and all will intersect with that singular\nlocation at some point in time. If we are some observer traveling separately\nfrom, but at the same velocity as the rock, all the hailstones will\nintersect with some single point in space, the location of the rock. So, if\nwe can guess the velocity of the rock, we can then determine its location\nby finding that point where the trajectories intersect. Moreover, we can\nsolve in X and Y alone, by considering these intersections in just 2D\nspace. And this looks an awful lot like part 1."),(0,i.kt)("p",null,"The question that this then raises is, how can we know the velocity of\nthe rock. Looking at the sample data, all the hailstones have absolute\nvelocity components less than 1,000. So what we can do is just guess.\nIf we assume the rock velocity is of the same order of magnitude as the\nhailstones, we can just try every X, Y velocity from -1,000 to 1,000 until\nwe find one where intersections occur."),(0,i.kt)("h4",{id:"shifting-perspective"},"Shifting Perspective"),(0,i.kt)("p",null,"We add a method to shift the velocity of a hailstone to a moving\nobserver's frame of reference."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Inside class Hail2D\n  def deltaV(dvx: Long, dvy: Long): Hail2D =\n    copy(vx = vx - dvx, vy = vy - dvy)\n")),(0,i.kt)("h3",{id:"determining-the-origin-of-the-rock"},"Determining the Origin of the Rock"),(0,i.kt)("p",null,"Then we will take three hailstones and compute their intersection\nfrom the moving observer's perspective. We compute where the first\nhailstone will intersect the second, and where it will intersect\nthe third. If these locations are the same in space, then we have\na solution and, given the time of one of the intersections, we can\ntrace back to locate the origin of the rock."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def findRockOrigin(\n  hails: Vector[Hail2D],\n  vx: Long,\n  vy: Long\n): Option[(Long, Long)] =\n  val hail0 +: hail1 +: hail2 +: _ = hails.map(_.deltaV(vx, vy)): @unchecked\n  for\n    (x0, y0) <- hail0.intersect(hail1)\n    (x1, y1) <- hail0.intersect(hail2)\n    if x0 == x1 && y0 == y1\n    time      = hail0.timeTo(x0, y0)\n  yield (hail0.x + hail0.vx * time.longValue,\n         hail0.y + hail0.vy * time.longValue)\n")),(0,i.kt)("p",null,"Pedantically, there exists the possibility of a false positive,\nwhere the first three hailstones intersect for some velocity other\nthan the ultimate solution, but not the rest. We\ncould extend our test to include all hailstones, not just the third,\nbut this is fairly improbable given the constraints that positions\nand velocities are all integers."),(0,i.kt)("h3",{id:"optimizing-our-search-space"},"Optimizing Our Search Space"),(0,i.kt)("p",null,"A simple search would just search for ",(0,i.kt)("inlineCode",{parentName:"p"},"vx <- -1000 to 1000")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"vy <- -1000 to 1000"),", but if we assume the rock velocity is closer to\nzero then this will be inefficient. Instead, we will generate a spiral\nof initial velocities, starting at (0,0), then (1,0), (1,1),\n(0,1), (-1, 1), (-1, 0), etc, so we can test locations closer to\nzero first."),(0,i.kt)("p",null,"For this, we define a spiral generator FSM that can be used with\n",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator.iterate"),". The code here is longer than it need be because it\nuses no supporting libraries:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Spiral(\n  x: Long, y: Long,\n  dx: Long, dy: Long,\n  count: Long, limit: Long,\n):\n  def next: Spiral =\n    if count > 0 then\n      copy(x = x + dx, y = y + dy, count = count - 1)\n    else if dy == 0 then\n      copy(x = x + dx, y = y + dy, dy = dx, dx = -dy, count = limit)\n    else\n      copy(x = x + dx, y = y + dy, dy = dx, dx = -dy,\n           count = limit + 1, limit = limit + 1)\n  end next\nend Spiral\n\nobject Spiral:\n  final val Start = Spiral(0, 0, 1, 0, 0, 0)\n")),(0,i.kt)("h2",{id:"part-2-solution"},"Part 2 Solution"),(0,i.kt)("p",null,"Our part 2 solution is to then just use the spiral generator to\nproduce candidate rock velocities for which we attempt to\nfind a rock origin. Once we find a solution we know the X and\nY location and velocity of the rock. We can then just repeat\nexactly the same search for an XZ projection of the hailstones\nto find the Z origin of the rock. This search could be optimized\nsince the x velocity is already known, so we only need to test z\ncandidates, but this is less effort."),(0,i.kt)("p",null,"First add a method ",(0,i.kt)("inlineCode",{parentName:"p"},"xzProjection")," method to Hail to get a 2D projection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Inside class Hail:\n  def xzProjection: Hail2D = Hail2D(x, z, vx, vz)\n")),(0,i.kt)("p",null,"Next, add a helper method to find a value in an iterator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// An unruly and lawless find-map-get\nextension [A](self: Iterator[A])\n  def findMap[B](f: A => Option[B]): B = self.flatMap(f).next()\n")),(0,i.kt)("p",null,"Finally solve part 2"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Long =\n  val hails = parseAll(input)\n\n  val hailsXY = hails.map(_.xyProjection)\n  val (x, y)  = Iterator\n    .iterate(Spiral.Start)(_.next)\n    .findMap: spiral =>\n      findRockOrigin(hailsXY, spiral.x, spiral.y)\n\n  val hailsXZ = hails.map(_.xzProjection)\n  val (_, z)  = Iterator\n    .iterate(Spiral.Start)(_.next)\n    .findMap: spiral =>\n      findRockOrigin(hailsXZ, spiral.x, spiral.y)\n\n  x + y + z\nend part2\n")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("p",null,"The complete solution follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case class Hail(x: Long, y: Long, z: Long, vx: Long, vy: Long, vz: Long):\n  def xyProjection: Hail2D = Hail2D(x, y, vx, vy)\n  def xzProjection: Hail2D = Hail2D(x, z, vx, vz)\n\ndef parseAll(input: String): Vector[Hail] =\n  input.linesIterator.toVector.map:\n    case s"$x, $y, $z @ $dx, $dy, $dz" =>\n      Hail(x.trim.toLong, y.trim.toLong, z.trim.toLong,\n            dx.trim.toLong, dy.trim.toLong, dz.trim.toLong)\n\nfinal case class Hail2D(x: Long, y: Long, vx: Long, vy: Long):\n  private val a: BigDecimal = BigDecimal(vy)\n  private val b: BigDecimal = BigDecimal(-vx)\n  private val c: BigDecimal = BigDecimal(vx * y - vy * x)\n\n  def deltaV(dvx: Long, dvy: Long): Hail2D = copy(vx = vx - dvx, vy = vy - dvy)\n\n  // If the paths of these hailstones intersect, return the intersection\n  def intersect(hail: Hail2D): Option[(BigDecimal, BigDecimal)] =\n    val denominator = a * hail.b - hail.a * b\n    Option.when(denominator != 0):\n      ((b * hail.c - hail.b * c) / denominator,\n       (c * hail.a - hail.c * a) / denominator)\n\n  // Return the time at which this hail will intersect the given point\n  def timeTo(posX: BigDecimal, posY: BigDecimal): BigDecimal =\n    if vx == 0 then (posY - y) / vy else (posX - x) / vx\nend Hail2D\n\nextension [A](self: Vector[A])\n  // all non-self element pairs\n  def allPairs: Vector[(A, A)] = self.tails.toVector.tail.flatMap(self.zip)\n\nextension [A](self: Iterator[A])\n  // An unruly and lawless find-map-get\n  def findMap[B](f: A => Option[B]): B = self.flatMap(f).next()\n\ndef intersections(\n  hails: Vector[Hail2D],\n  min: Long,\n  max: Long\n): Vector[(Hail2D, Hail2D)] =\n  for\n    (hail0, hail1) <- hails.allPairs\n    (x, y)         <- hail0.intersect(hail1)\n    if x >= min && x <= max && y >= min && y <= max &&\n       hail0.timeTo(x, y) >= 0 && hail1.timeTo(x, y) >= 0\n  yield (hail0, hail1)\nend intersections\n\ndef part1(input: String): Long =\n  val hails = Hail.parseAll(input)\n  val hailsXY = hails.map(_.xyProjection)\n  intersections(hailsXY, 200000000000000L, 400000000000000L).size\nend part1\n\ndef findRockOrigin(\n  hails: Vector[Hail2D],\n  vx: Long,\n  vy: Long\n): Option[(Long, Long)] =\n  val hail0 +: hail1 +: hail2 +: _ = hails.map(_.deltaV(vx, vy)): @unchecked\n  for\n    (x0, y0) <- hail0.intersect(hail1)\n    (x1, y1) <- hail0.intersect(hail2)\n    if x0 == x1 && y0 == y1\n    time      = hail0.timeTo(x0, y0)\n  yield (hail0.x + hail0.vx * time.longValue,\n         hail0.y + hail0.vy * time.longValue)\nend findRockOrigin\n\nfinal case class Spiral(\n  x: Long, y: Long,\n  dx: Long, dy: Long,\n  count: Long, limit: Long,\n):\n  def next: Spiral =\n    if count > 0 then\n      copy(x = x + dx, y = y + dy, count = count - 1)\n    else if dy == 0 then\n      copy(x = x + dx, y = y + dy, dy = dx, dx = -dy, count = limit)\n    else\n      copy(x = x + dx, y = y + dy, dy = dx, dx = -dy,\n           count = limit + 1, limit = limit + 1)\n  end next\nend Spiral\n\nobject Spiral:\n  final val Start = Spiral(0, 0, 1, 0, 0, 0)\n\ndef part2(input: String): Long =\n  val hails = Hail.parseAll(input)\n\n  val hailsXY = hails.map(_.xyProjection)\n  val (x, y)  = Iterator\n    .iterate(Spiral.Start)(_.next)\n    .findMap: spiral =>\n      findRockOrigin(hailsXY, spiral.x, spiral.y)\n\n  val hailsXZ = hails.map(_.xzProjection)\n  val (_, z)  = Iterator\n    .iterate(Spiral.Start)(_.next)\n    .findMap: spiral =>\n      findRockOrigin(hailsXZ, spiral.x, spiral.y)\n\n  x + y + z\nend part2\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day24.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2023/tree/main/src/main/scala/day24"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}p.isMDXComponent=!0}}]);