"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4760],{7788:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var t=a(7462),o=(a(7294),a(3905)),r=a(6340);const i={},l="Day 21: Monkey Math",s={unversionedId:"2022/puzzles/day21",id:"2022/puzzles/day21",title:"Day 21: Monkey Math",description:"Puzzle description",source:"@site/target/mdoc/2022/puzzles/day21.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day21",permalink:"/scala-advent-of-code/2022/puzzles/day21",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day21.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 20: Grove Positioning System",permalink:"/scala-advent-of-code/2022/puzzles/day20"},next:{title:"Day 22: Monkey Map",permalink:"/scala-advent-of-code/2022/puzzles/day22"}},c={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:p};function u(e){let{components:n,...a}=e;return(0,o.kt)("wrapper",(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-21-monkey-math"},"Day 21: Monkey Math"),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/21"},"https://adventofcode.com/2022/day/21")),(0,o.kt)("h2",{id:"final-code"},"Final Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import annotation.tailrec\nimport Operation.*\n\ndef part1(input: String): Long =\n  resolveRoot(input)\n\ndef part2(input: String): Long =\n  whichValue(input)\n\nenum Operator(val eval: BinOp, val invRight: BinOp, val invLeft: BinOp):\n  case `+` extends Operator(_ + _, _ - _, _ - _)\n  case `-` extends Operator(_ - _, _ + _, (x, y) => y - x)\n  case `*` extends Operator(_ * _, _ / _, _ / _)\n  case `/` extends Operator(_ / _, _ * _, (x, y) => y / x)\n\nenum Operation:\n  case Binary(op: Operator, depA: String, depB: String)\n  case Constant(value: Long)\n\ntype BinOp = (Long, Long) => Long\ntype Resolved = Map[String, Long]\ntype Source = Map[String, Operation]\ntype Substitutions = List[(String, PartialFunction[Operation, Operation])]\n\ndef readAll(input: String): Map[String, Operation] =\n  Map.from(\n    for case s"$name: $action" <- input.linesIterator yield\n      name -> action.match\n        case s"$x $binop $y" =>\n          Binary(Operator.valueOf(binop), x, y)\n        case n =>\n          Constant(n.toLong)\n  )\n\n@tailrec\ndef reachable(names: List[String], source: Source, resolved: Resolved): Resolved = names match\n  case name :: rest =>\n    source.get(name) match\n      case None => resolved // return as name is not reachable\n      case Some(operation) => operation match\n        case Binary(op, x, y) =>\n          (resolved.get(x), resolved.get(y)) match\n            case (Some(a), Some(b)) =>\n              reachable(rest, source, resolved + (name -> op.eval(a, b)))\n            case _ =>\n              reachable(x :: y :: name :: rest, source, resolved)\n        case Constant(value) =>\n          reachable(rest, source, resolved + (name -> value))\n  case Nil =>\n    resolved\nend reachable\n\ndef resolveRoot(input: String): Long =\n  val values = reachable("root" :: Nil, readAll(input), Map.empty)\n  values("root")\n\ndef whichValue(input: String): Long =\n  val source = readAll(input) - "humn"\n\n  @tailrec\n  def binarySearch(name: String, goal: Option[Long], resolved: Resolved): Long =\n\n    def resolve(name: String) =\n      val values = reachable(name :: Nil, source, resolved)\n      values.get(name).map(_ -> values)\n\n    def nextGoal(inv: BinOp, value: Long): Long = goal match\n      case Some(prev) => inv(prev, value)\n      case None => value\n\n    (source.get(name): @unchecked) match\n      case Some(Operation.Binary(op, x, y)) =>\n        ((resolve(x), resolve(y)): @unchecked) match\n          case (Some(xValue -> resolvedX), _) => // x is known, y has a hole\n            binarySearch(y, Some(nextGoal(op.invLeft, xValue)), resolvedX)\n          case (_, Some(yValue -> resolvedY)) => // y is known, x has a hole\n            binarySearch(x, Some(nextGoal(op.invRight, yValue)), resolvedY)\n      case None =>\n        goal.get // hole found\n  end binarySearch\n\n  binarySearch(goal = None, name = "root", resolved = Map.empty)\nend whichValue\n')),(0,o.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,o.kt)("h4",{id:"part-1"},"Part 1"),(0,o.kt)(r.Z,{puzzle:"day21-part1",year:"2022",mdxType:"Solver"}),(0,o.kt)("h4",{id:"part-2"},"Part 2"),(0,o.kt)(r.Z,{puzzle:"day21-part2",year:"2022",mdxType:"Solver"}),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gist.github.com/JavadocMD/083eb9fa6aa921d7669e12768c1f6fc1"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://gist.github.com/JavadocMD"},"Tyler Coles")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day21.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day21"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}u.isMDXComponent=!0}}]);