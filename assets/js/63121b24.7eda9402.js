"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4608],{2828:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var n=a(7462),o=(a(7294),a(3905));a(6340);const i={},l="Day 9: Mirage Maintenance",r={unversionedId:"2023/puzzles/day09",id:"2023/puzzles/day09",title:"Day 9: Mirage Maintenance",description:"by @SethTisue",source:"@site/target/mdoc/2023/puzzles/day09.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day09",permalink:"/scala-advent-of-code/2023/puzzles/day09",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day09.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 8: Haunted Wasteland",permalink:"/scala-advent-of-code/2023/puzzles/day08"},next:{title:"Day 10: Pipe Maze",permalink:"/scala-advent-of-code/2023/puzzles/day10"}},s={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Background",id:"background",level:2},{value:"Core logic",id:"core-logic",level:3},{value:"Parsing",id:"parsing",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],u={toc:p};function c(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-9-mirage-maintenance"},"Day 9: Mirage Maintenance"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/SethTisue"},"@SethTisue")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/9"},"https://adventofcode.com/2023/day/9")),(0,o.kt)("h2",{id:"background"},"Background"),(0,o.kt)("p",null,"This method of predicting the next number in a sequence is an example\nof using ",(0,o.kt)("a",{parentName:"p",href:"https://mathworld.wolfram.com/FiniteDifference.html"},'"finite\ndifferences"'),".\nThe elves are asking us to construct a ",(0,o.kt)("a",{parentName:"p",href:"https://mathworld.wolfram.com/DifferenceTable.html"},'"difference\ntable"'),".\nIt is a special case of the more general method of\n",(0,o.kt)("a",{parentName:"p",href:"https://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html"},'"Lagrange interpolation"'),".\nThe method of differences also gave its name to Charles Babbage's\nfamous mechanical ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Difference_engine"},'"difference engine"'),"."),(0,o.kt)("p",null,"Even if this mathematical background is unfamiliar to you, the method\nis still straightforward to implement."),(0,o.kt)("h3",{id:"core-logic"},"Core logic"),(0,o.kt)("p",null,"The algorithm can naturally be expressed in functional style using\nrecursion.  See the alternate solutions linked below for some other\npossible approaches."),(0,o.kt)("p",null,"The heart of our solution to both parts is this recursive method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def extrapolate(xs: Seq[Int]): Int =\n  if xs.forall(_ == xs.head)\n  then xs.head\n  else\n    xs.last + extrapolate(\n      xs.tail.lazyZip(xs)\n        .map(_ - _)\n        .toSeq)\n")),(0,o.kt)("p",null,"If we are not at the base case, we construct the next row\nof the difference table using ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", extrapolate the next\ndifference, and then add that difference to the number at\nthe end of the current row."),(0,o.kt)("p",null,"At the base case, I've introduced a small optimization. The puzzle\nsuggests stopping once we hit a row of all zeros:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"  if xs.forall(_ == 0)\n  then 0\n  else ...\n")),(0,o.kt)("p",null,"But we can actually stop a step sooner, once we arrive at a row of all\nthe same value, even if that value is nonzero. (If we continued, the\n",(0,o.kt)("em",{parentName:"p"},"next")," row would be all zeros.)"),(0,o.kt)("p",null,"The use of\n",(0,o.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/Seq.html#lazyZip-fffffd84"},(0,o.kt)("inlineCode",{parentName:"a"},"lazyZip")),"\ninstead of regular ",(0,o.kt)("inlineCode",{parentName:"p"},"zip")," is also a small optimization that avoids\nconstructing an intermediate collection."),(0,o.kt)("p",null,"Note that doing ",(0,o.kt)("inlineCode",{parentName:"p"},"xs.tail.lazyZip(xs)")," instead of the more obvious\n",(0,o.kt)("inlineCode",{parentName:"p"},"xs.lazyZip(xs.tail)")," means we don't need to reverse the arguments\nbefore subtracting, allowing use of the ",(0,o.kt)("inlineCode",{parentName:"p"},"_ - _")," shorthand."),(0,o.kt)("p",null,"Note also that both ",(0,o.kt)("inlineCode",{parentName:"p"},"zip")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"lazyZip")," discard any extra values,\nso it doesn't matter that one of the sequences being zipped is one\nshorter."),(0,o.kt)("p",null,"It would be only slightly more awkward to instead use ",(0,o.kt)("inlineCode",{parentName:"p"},"sliding(2)")," to\niterate over successive pairs, as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"xs.sliding(2).map:\n  case Seq(x1, x2) =>\n    x2 - x1\n")),(0,o.kt)("p",null,"Instead of recursion, one could also express the algorithm using an\niterator (with ",(0,o.kt)("inlineCode",{parentName:"p"},"Iterator.unfold"),", as suggested by Stewart Stewart, or\n",(0,o.kt)("inlineCode",{parentName:"p"},"Iterator.iterate"),"), or tail recursion with an accumulator, or an\nimperative loop."),(0,o.kt)("h3",{id:"parsing"},"Parsing"),(0,o.kt)("p",null,"Parsing today's input presents no special challenges:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def parse(input: String): Seq[Seq[Int]] =\n  input.linesIterator\n    .map(_.split(' ').map(_.toInt).toSeq)\n    .toSeq\n")),(0,o.kt)("h3",{id:"part-1"},"Part 1"),(0,o.kt)("p",null,"Now we have all the pieces we need to solve part 1:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  parse(input)\n    .map(extrapolate)\n    .sum\n")),(0,o.kt)("h3",{id:"part-2"},"Part 2"),(0,o.kt)("p",null,"The simplest way to solve part 2 is simply to insert\n",(0,o.kt)("inlineCode",{parentName:"p"},".map(_.reverse)"),", so that we're extrapolating to the left rather than\nto the right:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int =\n  parse(input)\n    .map(_.reverse)  // only this line is new\n    .map(extrapolate)\n    .sum\n")),(0,o.kt)("p",null,'It\'s also possible to solve it without reversing the input, as seen in\nsome of the community solutions linked below.  The problem text\nsuggests "Adding the new values on the left side of each sequence from\nbottom to top", and this suggestion can be turned into code.'),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2023/src/main/scala/Day9.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/master/task09/src/main/scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin"))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);