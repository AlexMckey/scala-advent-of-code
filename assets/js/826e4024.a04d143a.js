"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1377],{1885:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294);const i=e=>{let{children:t}=e;const n=()=>a.Children.map(t,(e=>{const t=void 0===e.props.className?"literate-coding":`${e.props.className} literate-coding`;return a.cloneElement(e,{className:t})}));return a.createElement(n,null)}},581:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var a=n(7462),i=(n(7294),n(3905)),r=n(6340),s=n(1885);const o={},l="Day 17: Clumsy Crucible",d={unversionedId:"2023/puzzles/day17",id:"2023/puzzles/day17",title:"Day 17: Clumsy Crucible",description:"by @stewSquared",source:"@site/target/mdoc/2023/puzzles/day17.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day17",permalink:"/scala-advent-of-code/2023/puzzles/day17",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day17.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 16: The Floor Will Be Lava",permalink:"/scala-advent-of-code/2023/puzzles/day16"},next:{title:"Day 18: Lavaduct Lagoon",permalink:"/scala-advent-of-code/2023/puzzles/day18"}},u={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Framework",id:"framework",level:3},{value:"Search State",id:"search-state",level:3},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Run Part 1",id:"run-part-1",level:4},{value:"Run Part 2",id:"run-part-2",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-17-clumsy-crucible"},"Day 17: Clumsy Crucible"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/stewSquared"},"@stewSquared")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/17"},"https://adventofcode.com/2023/day/17")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"This is a classic search problem with an interesting restriction on state transformations."),(0,i.kt)("p",null,"We will solve this using Dijkstra's Algorithm to find a path through the grid, using the heat loss of each position as our node weights. However, the states in our priority queue will need to include more than just position and accumulated heat loss, since the streak of forward movements in a given direction affects which positions are accessible from a given state."),(0,i.kt)("p",null,"Since the restrictions on state transformations differ in part 1 and part 2, we'll model them separately from the base state transformations."),(0,i.kt)("h3",{id:"framework"},"Framework"),(0,i.kt)("p",null,"First, we will need a ",(0,i.kt)("inlineCode",{parentName:"p"},"Grid")," class to represent the possible positions, and store the heat at each position.\nIt will be represented by a 2D vector:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Grid(grid: Vector[Vector[Int]]):\n  val xRange = grid.head.indices\n  val yRange = grid.indices\n")),(0,i.kt)("p",null,"We can parse the input and store it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Grid")," class. Each line is treated as a row, and each character in the row is treated as a single column, and required to be a digit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def loadGrid(input: String): Grid =\n  Grid:\n    Vector.from:\n      for line <- input.split("\\n")\n      yield line.map(_.asDigit).toVector\n')),(0,i.kt)("p",null,"We can define some accessors to make it more convenient to work with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Grid")," that is available in the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/book/ca-context-parameters.html"},"context"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def grid(using Grid) = summon[Grid].grid\ndef xRange(using Grid) = summon[Grid].xRange\ndef yRange(using Grid) = summon[Grid].yRange\n")),(0,i.kt)("p",null,"Second, for convenience, let's introduce a class for presenting direction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum Dir:\n  case N, S, E, W\n\n  def turnRight = this match\n    case Dir.N => E\n    case Dir.E => S\n    case Dir.S => W\n    case Dir.W => N\n\n  def turnLeft = this match\n    case Dir.N => W\n    case Dir.W => S\n    case Dir.S => E\n    case Dir.E => N\n")),(0,i.kt)("p",null,"Since moving forward, turning left, and turning right are common operations, convenience methods for each are included here."),(0,i.kt)("p",null,"Third, a class for position:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Point(x: Int, y: Int):\n  def inBounds(using Grid) =\n    xRange.contains(x) && yRange.contains(y)\n\n  def heatLoss(using Grid) =\n    if inBounds then grid(y)(x) else 0\n\n  def move(dir: Dir) = dir match\n    case Dir.N => copy(y = y - 1)\n    case Dir.S => copy(y = y + 1)\n    case Dir.E => copy(x = x + 1)\n    case Dir.W => copy(x = x - 1)\n")),(0,i.kt)("p",null,"Here we provide some convenience methods for checking if a point is ",(0,i.kt)("inlineCode",{parentName:"p"},"inBounds")," on the grid,\nand the ",(0,i.kt)("inlineCode",{parentName:"p"},"heatLoss")," of a point on the grid."),(0,i.kt)("h3",{id:"search-state"},"Search State"),(0,i.kt)("p",null,"Now we want to be able to model our state as we're searching. The state will track our position (",(0,i.kt)("inlineCode",{parentName:"p"},"pos"),"). To know what transitions are possible, we need to keep track of our ",(0,i.kt)("inlineCode",{parentName:"p"},"streak")," of movements in a given direction (",(0,i.kt)("inlineCode",{parentName:"p"},"dir"),"). Later, we'll also keep track of the heat lost while getting to a state."),(0,i.kt)(s.Z,{mdxType:"Literate"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class State(pos: Point, dir: Dir, streak: Int):\n")),(0,i.kt)("p",null,"Next let's define some methods for transitioning to new states. We know that we can chose to move forward, turn left, or turn right. For now, we won't consider the restrictions from Part 1 or Part 2 on whether or not you can move forward:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def straight: State =\n    State(pos.move(dir), dir, streak + 1)\n\n  def turnLeft: State =\n    val newDir = dir.turnLeft\n    State(pos.move(newDir), newDir, 1)\n\n  def turnRight: State =\n    val newDir = dir.turnRight\n    State(pos.move(newDir), newDir, 1)\n"))),(0,i.kt)("p",null,"Note that the streak resets to one when we turn right or turn left, since we also move the position forward in that new direction."),(0,i.kt)("h3",{id:"dijkstras-algorithm"},"Dijkstra's Algorithm"),(0,i.kt)("p",null,"Finally, let's lay the groundwork for an implementation of Dijkstra's algorithm."),(0,i.kt)("p",null,"Since our valid state transformations vary between part 1 and part 2, let's parameterize our search method by a function:"),(0,i.kt)(s.Z,{mdxType:"Literate"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import collection.mutable.{PriorityQueue, Map}\n\ntype StateTransform = Grid ?=> State => List[State]\n\ndef search(next: StateTransform)(using Grid): Int =\n")),(0,i.kt)("p",null,"The algorithm uses Map to track the minimum total heat loss for each state, and a Priority Queue prioritizing by this heatloss to choose the next state to visit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  val minHeatLoss = Map.empty[State, Int]\n\n  given Ordering[State] = Ordering.by(minHeatLoss)\n  val pq = PriorityQueue.empty[State].reverse\n\n  var visiting = State(Point(0, 0), Dir.E, 0)\n  minHeatLoss(visiting) = 0\n")),(0,i.kt)("p",null,"As we generate new states to add to the priority Queue, we need to make sure not to add suboptimal states. The first time we visit any state, it will be with a minimum possible cost, because we're visiting this new state from an adjacent minimum heatloss state in our priority queue.\nSo any state we've already visited will be discarded. This is what our loop will look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  val end = Point(xRange.max, yRange.max)\n  while visiting.pos != end do\n    val states = next(visiting).filterNot(minHeatLoss.contains)\n    states.foreach: s =>\n      minHeatLoss(s) = minHeatLoss(visiting) + s.pos.heatLoss\n      pq.enqueue(s)\n    visiting = pq.dequeue()\n\n  minHeatLoss(visiting)\n"))),(0,i.kt)("p",null,"Notice how ",(0,i.kt)("inlineCode",{parentName:"p"},"minHeatLoss")," is always updated to the minimum of the state we're visiting from plus the incremental heatloss of the new state we're adding to the queue."),(0,i.kt)("p",null,"We can then provide a framework for calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"search")," function using the input with ",(0,i.kt)("inlineCode",{parentName:"p"},"solve"),".\nIt parses the input to a ",(0,i.kt)("inlineCode",{parentName:"p"},"Grid"),", defining it as a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/book/ca-context-parameters.html"},"given instance"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def solve(input: String, next: StateTransform): Int =\n  given Grid = loadGrid(input)\n  search(next)\n")),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"Now we need to model our state transformation restrictions for Part 1. We can typically move straight, left, and right, but we need to make sure our streak while moving straight never exceeds 3:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Inside case class State:\n  def nextStates(using Grid): List[State] =\n    List(straight, turnLeft, turnRight).filter: s =>\n      s.pos.inBounds && s.streak <= 3\n")),(0,i.kt)("p",null,"This will only ever filter out the forward movement, since moving to the left or right resets the streak to 1."),(0,i.kt)("p",null,"We can then call ",(0,i.kt)("inlineCode",{parentName:"p"},"solve")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"nextStates")," from our entry point for ",(0,i.kt)("inlineCode",{parentName:"p"},"part1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  solve(input, _.nextStates)\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Part 2 is similar, but our streak limit increases to 10.\nFurthermore, while the streak is less than four, only a forward movement is possible:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Inside case class State:\n  def nextStates2(using Grid): List[State] =\n    if streak < 4 then List(straight)\n    else List(straight, turnLeft, turnRight).filter: s =>\n      s.pos.inBounds && s.streak <= 10\n")),(0,i.kt)("p",null,"And we call solve with ",(0,i.kt)("inlineCode",{parentName:"p"},"nextStates2")," to solve ",(0,i.kt)("inlineCode",{parentName:"p"},"part2"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int =\n  solve(input, _.nextStates2)\n")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import collection.mutable.{PriorityQueue, Map}\n\ndef part1(input: String): Int =\n  solve(input, _.nextStates)\n\ndef part2(input: String): Int =\n  solve(input, _.nextStates2)\n\ndef loadGrid(input: String): Grid =\n  Grid:\n    Vector.from:\n      for line <- input.split("\\n")\n      yield line.map(_.asDigit).toVector\n\ncase class Grid(grid: Vector[Vector[Int]]):\n  val xRange = grid.head.indices\n  val yRange = grid.indices\n\nenum Dir:\n  case N, S, E, W\n\n  def turnRight = this match\n    case Dir.N => E\n    case Dir.E => S\n    case Dir.S => W\n    case Dir.W => N\n\n  def turnLeft = this match\n    case Dir.N => W\n    case Dir.W => S\n    case Dir.S => E\n    case Dir.E => N\n\ndef grid(using Grid) = summon[Grid].grid\ndef xRange(using Grid) = summon[Grid].xRange\ndef yRange(using Grid) = summon[Grid].yRange\n\ncase class Point(x: Int, y: Int):\n  def inBounds(using Grid) =\n    xRange.contains(x) && yRange.contains(y)\n\n  def heatLoss(using Grid) =\n    if inBounds then grid(y)(x) else 0\n\n  def move(dir: Dir) = dir match\n    case Dir.N => copy(y = y - 1)\n    case Dir.S => copy(y = y + 1)\n    case Dir.E => copy(x = x + 1)\n    case Dir.W => copy(x = x - 1)\n\ncase class State(pos: Point, dir: Dir, streak: Int):\n  def straight: State =\n    State(pos.move(dir), dir, streak + 1)\n\n  def turnLeft: State =\n    val newDir = dir.turnLeft\n    State(pos.move(newDir), newDir, 1)\n\n  def turnRight: State =\n    val newDir = dir.turnRight\n    State(pos.move(newDir), newDir, 1)\n\n  def nextStates(using Grid): List[State] =\n    List(straight, turnLeft, turnRight).filter: s =>\n      s.pos.inBounds && s.streak <= 3\n\n  def nextStates2(using Grid): List[State] =\n    if streak < 4 then List(straight)\n    else List(straight, turnLeft, turnRight).filter: s =>\n      s.pos.inBounds && s.streak <= 10\n\ntype StateTransform = Grid ?=> State => List[State]\n\ndef solve(input: String, next: StateTransform): Int =\n  given Grid = loadGrid(input)\n  search(next)\n\ndef search(next: StateTransform)(using Grid): Int =\n\n  val minHeatLoss = Map.empty[State, Int]\n\n  given Ordering[State] = Ordering.by(minHeatLoss)\n  val pq = PriorityQueue.empty[State].reverse\n\n  var visiting = State(Point(0, 0), Dir.E, 0)\n  minHeatLoss(visiting) = 0\n\n  val end = Point(xRange.max, yRange.max)\n  while visiting.pos != end do\n    val states = next(visiting).filterNot(minHeatLoss.contains)\n    states.foreach: s =>\n      minHeatLoss(s) = minHeatLoss(visiting) + s.pos.heatLoss\n      pq.enqueue(s)\n    visiting = pq.dequeue()\n\n  minHeatLoss(visiting)\n')),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"run-part-1"},"Run Part 1"),(0,i.kt)(r.Z,{puzzle:"day17-part1",year:"2023",mdxType:"Solver"}),(0,i.kt)("h4",{id:"run-part-2"},"Run Part 2"),(0,i.kt)(r.Z,{puzzle:"day17-part2",year:"2023",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/stewSquared/advent-of-code/blob/master/src/main/scala/2023/Day17.worksheet.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/stewSquared"},"stewSquared")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2023/blob/main/src/main/scala/Day17.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/"},"merlin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day17.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}m.isMDXComponent=!0}}]);