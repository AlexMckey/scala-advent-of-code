"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[119],{3941:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return d},default:function(){return m}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),l=t(5623),s=["components"],r={},c="Day 10: Syntax Scoring",p={unversionedId:"puzzles/day10",id:"puzzles/day10",isDocsHomePage:!1,title:"Day 10: Syntax Scoring",description:"by @VincenzoBaz",source:"@site/target/mdoc/puzzles/day10.md",sourceDirName:"puzzles",slug:"/puzzles/day10",permalink:"/scala-advent-of-code/puzzles/day10",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day10.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 9: Smoke Basin",permalink:"/scala-advent-of-code/puzzles/day9"},next:{title:"Day 11",permalink:"/scala-advent-of-code/puzzles/day11"}},d=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution overview",id:"solution-overview",children:[],level:2},{value:"Line checking algorithm",id:"line-checking-algorithm",children:[],level:2},{value:"Solution of Part 1",id:"solution-of-part-1",children:[],level:2},{value:"Solution of Part 2",id:"solution-of-part-2",children:[],level:2},{value:"Run it locally",id:"run-it-locally",children:[],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],h={toc:d};function m(e){var n=e.components,t=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-10-syntax-scoring"},"Day 10: Syntax Scoring"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/VincenzoBaz"},"@VincenzoBaz")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/10"},"https://adventofcode.com/2021/day/10")),(0,o.kt)("h2",{id:"solution-overview"},"Solution overview"),(0,o.kt)("p",null,"Day 10 focuses on detecting unabalanced markers in the navigation system of the\nsubmarine. The possible markers are ",(0,o.kt)("inlineCode",{parentName:"p"},"()[]{}<>"),".  The input contains several\nlines, our task is to check whether each line is balanced, incomplete or\ninvalid."),(0,o.kt)("p",null,"I propose a solution centered around the algorithm that verifies each line and\nthat will be used in both part 1 and part 2."),(0,o.kt)("p",null,"An input is represented by a ",(0,o.kt)("inlineCode",{parentName:"p"},"LazyList[List[Symbol]]")," where each ",(0,o.kt)("inlineCode",{parentName:"p"},"List[Symbol]"),"\nis a line of the input.\nSymbols are defined by the kind (parenthesis, bracket, brace or diamond) and\nthe direction (open or close):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"enum Direction:\n  case Open, Close\n\nenum Kind:\n  case Parenthesis, Bracket, Brace, Diamond\n\ncase class Symbol(kind: Kind, direction: Direction):\n  def isOpen: Boolean = direction == Direction.Open\n")),(0,o.kt)("p",null,"In this encoding, ",(0,o.kt)("inlineCode",{parentName:"p"},"{")," is represented by ",(0,o.kt)("inlineCode",{parentName:"p"},"Symbol(Brace, Open)"),"."),(0,o.kt)("p",null,"The function that verifies a line produces a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"CheckResult")," which\nencapsulates the possible results of the check:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Ok")," if the input is valid"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Incomplete(pending)")," if the line finishes leaving some markers open. For\nexample then line ",(0,o.kt)("inlineCode",{parentName:"li"},"[")," is incomplete and will result in ",(0,o.kt)("inlineCode",{parentName:"li"},"Incomplete(List(Symbol(Bracket, Open)))")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IllegalClosing(expected, found)")," if a line contains a symbol closed by a\nsymbol whose kind is not correct. For example ",(0,o.kt)("inlineCode",{parentName:"li"},"[}")," is corrupted and will result in\n",(0,o.kt)("inlineCode",{parentName:"li"},"IllegalClosing(Some(Symbol(Bracket, Close)), Symbol(Brace, Close))"))),(0,o.kt)("p",null,"An ",(0,o.kt)("inlineCode",{parentName:"p"},"enum")," is used to encode this hierarchy:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"enum CheckResult:\n  case Ok\n  case IllegalClosing(expected: Option[Symbol], found: Symbol)\n  case Incomplete(pending: List[Symbol])\n")),(0,o.kt)("h2",{id:"line-checking-algorithm"},"Line checking algorithm"),(0,o.kt)("p",null,"The algorithm is implemented in the tail-recursive function ",(0,o.kt)("inlineCode",{parentName:"p"},"iter")," nested in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"checkChunks")," function.  It consumes one character at a time, retrieving it from\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," list.  It also maintains a stack (LIFO) of pending markers. I use\n",(0,o.kt)("inlineCode",{parentName:"p"},"List")," as a stack relying on pattern matching against ",(0,o.kt)("inlineCode",{parentName:"p"},"head :: tail")," to pop or\npush elements on the stack."),(0,o.kt)("p",null,"Consider the base case: when ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," is empty (",(0,o.kt)("inlineCode",{parentName:"p"},"Nil"),") then the algorithm reached the end\nof the line. In this situation, the result is ",(0,o.kt)("inlineCode",{parentName:"p"},"Ok")," if there are no unmatched markers (when the ",(0,o.kt)("inlineCode",{parentName:"p"},"pending")," stack is empty). Otherwise the line is incomplete:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"      case Nil =>\n        if pending.isEmpty then CheckResult.Ok\n        else CheckResult.Incomplete(pending)\n")),(0,o.kt)("p",null,"When ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," contains at least one symbol, we pop it from the list.\nIf the symbol is an open marker (",(0,o.kt)("inlineCode",{parentName:"p"},"direction")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"Open"),") then we push it\non the ",(0,o.kt)("inlineCode",{parentName:"p"},"pending")," stack and we continue iterating over the rest of the row."),(0,o.kt)("p",null,"Otherwise, when the new symbol is a closing marker, we need to check if it\nmatches the top of the ",(0,o.kt)("inlineCode",{parentName:"p"},"pending")," stack. Therefore if this stack is empty or if\nthe top of the stack has a different ",(0,o.kt)("inlineCode",{parentName:"p"},"kind")," (for example it is brace and the new\nsymbol is a bracket) then we can stop and declare the line as corrupted\n(returning a ",(0,o.kt)("inlineCode",{parentName:"p"},"IllegalClosing"),").  If the line is not corrupted, then the symbol\ncloses the marker opened by the top of the stack: we can remove the top of the\nstack and continue with the rest of the input."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"      case nextChar :: remainingChars =>\n        // a new opening marker: push it on pending and continue analysing the row\n        if nextChar.isOpen then iter(nextChar :: pending, remainingChars)\n        else pending match\n          // pending is empty: nextChar closes a marker that was not opened\n          case Nil => CheckResult.IllegalClosing(None, nextChar)\n          case lastOpened :: previouslyOpened =>\n            // nextChar closes the marker opened by lastOpened, we can continue after popping\n            // the top of the stack.\n            if lastOpened.kind == nextChar.kind then iter(previouslyOpened, remainingChars)\n            // nextChar closes a marker that was not opened by the top of the stack: error\n            else CheckResult.IllegalClosing(Some(lastOpened), nextChar)\n")),(0,o.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,o.kt)("p",null,"To solve the first part, I analyze all the lines in the input and retain the\ncorrupted ones.  As the symbol causing corruption is maintained inside the\n",(0,o.kt)("inlineCode",{parentName:"p"},"IllegalClosing")," object, I can compute the score of each mistake and add them\nup."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"extension (illegalClosing: CheckResult.IllegalClosing)\n  def score: Int =\n    import Kind.*\n    illegalClosing.found.kind match\n      case Parenthesis => 3\n      case Bracket => 57\n      case Brace => 1197\n      case Diamond => 25137\n\ndef part1(input: String): Int =\n  val rows: LazyList[List[Symbol]] =\n    input.linesIterator\n      .to(LazyList)\n      .map(parseRow)\n\n  rows.map(checkChunks)\n    .collect { case illegal: CheckResult.IllegalClosing => illegal.score }\n    .sum\n")),(0,o.kt)(l.Z,{puzzle:"day10-part1",mdxType:"Solver"}),(0,o.kt)("h2",{id:"solution-of-part-2"},"Solution of Part 2"),(0,o.kt)("p",null,"In the second part, we focus on incomplete lines.  For each line, I use an\niteration accumulator ",(0,o.kt)("inlineCode",{parentName:"p"},"currentScore")," initialized to ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and I iterate over each\nmissing symbol, at each step I multiply the accumulator by ",(0,o.kt)("inlineCode",{parentName:"p"},"5")," and add the score\ncorresponding to the missing symbol."),(0,o.kt)("p",null,"I know what symbol is missing from the input because ",(0,o.kt)("inlineCode",{parentName:"p"},"CheckResult.Incomplete"),"\ncontains all the symbols opening a marker which is not closed. Therefore missing\nsymbols can be obtained by iterating over the ",(0,o.kt)("inlineCode",{parentName:"p"},"pending")," stack from top to\nbottom:"),(0,o.kt)("p",null,"This iteration is performed by ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"extension (incomplete: CheckResult.Incomplete)\n  def score: BigInt =\n    incomplete.pending.foldLeft(BigInt(0)) { (currentScore, symbol) =>\n      val points = symbol.kind match\n        case Parenthesis => 1\n        case Bracket => 2\n        case Brace => 3\n        case Diamond => 4\n\n      currentScore * 5 + points\n    }\n")),(0,o.kt)("p",null,"Once I have the scores of all incomplete lines, I sort the scores and retrieve\nthe element in the middle:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): BigInt =\n  val rows: LazyList[List[Symbol]] =\n    input.linesIterator\n      .to(LazyList)\n      .map(parseRow)\n\n  val scores =\n    rows.map(checkChunks)\n      .collect { case incomplete: CheckResult.Incomplete => incomplete.score }\n      .toVector\n      .sorted\n\n  scores(scores.length / 2)\n")),(0,o.kt)(l.Z,{puzzle:"day10-part2",mdxType:"Solver"}),(0,o.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,o.kt)("p",null,"You can get this solution locally by cloning the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd advent-of-code\n")),(0,o.kt)("p",null,"You can run it with ",(0,o.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ scala-cli src -M day10.part1\nThe solution is 367059\n$ scala-cli src -M day10.part2\nThe solution is 1952146692\n")),(0,o.kt)("p",null,"You can replace the content of the ",(0,o.kt)("inlineCode",{parentName:"p"},"input/day10")," file with your own input from\n",(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/10"},"adventofcode.com")," to get your own\nsolution."),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page."))}m.isMDXComponent=!0}}]);