"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[14],{564:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return d},toc:function(){return h},default:function(){return c}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),l=n(5623),r=["components"],s={},p="Day 17: Trick Shot",d={unversionedId:"puzzles/day17",id:"puzzles/day17",isDocsHomePage:!1,title:"Day 17: Trick Shot",description:"by @bishabosha",source:"@site/target/mdoc/puzzles/day17.md",sourceDirName:"puzzles",slug:"/puzzles/day17",permalink:"/scala-advent-of-code/puzzles/day17",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day17.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 16: Packet Decoder",permalink:"/scala-advent-of-code/puzzles/day16"},next:{title:"Day 18: Snailfish",permalink:"/scala-advent-of-code/puzzles/day18"}},h=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution of Part 1",id:"solution-of-part-1",children:[{value:"Modelling The Domain",id:"modelling-the-domain",children:[{value:"A Moving Probe",id:"a-moving-probe",children:[],level:4},{value:"A Target Area",id:"a-target-area",children:[],level:4}],level:3},{value:"Reasoning about the Problem",id:"reasoning-about-the-problem",children:[{value:"Simulating a trajectory",id:"simulating-a-trajectory",children:[{value:"Checking Collisions",id:"checking-collisions",children:[],level:5},{value:"Has the Probe Moved Beyond the Target?",id:"has-the-probe-moved-beyond-the-target",children:[],level:5},{value:"Running the Simulation",id:"running-the-simulation",children:[],level:5}],level:4},{value:"Checking all Possible Trajectories",id:"checking-all-possible-trajectories",children:[{value:"Lower <code>x</code> Bound",id:"lower-x-bound",children:[],level:5},{value:"Lower <code>y</code> Bound",id:"lower-y-bound",children:[],level:5},{value:"Upper <code>x</code> Bound",id:"upper-x-bound",children:[],level:5},{value:"Upper <code>y</code> Bound",id:"upper-y-bound",children:[],level:5},{value:"Generating all Maximum Heights",id:"generating-all-maximum-heights",children:[],level:5}],level:4}],level:3},{value:"Computing the Solution",id:"computing-the-solution",children:[{value:"Parsing the Input",id:"parsing-the-input",children:[],level:4},{value:"Running the Solution",id:"running-the-solution",children:[],level:4}],level:3}],level:2},{value:"Solution of Part 2",id:"solution-of-part-2",children:[{value:"Updating Our Search Space",id:"updating-our-search-space",children:[],level:3},{value:"Computing the Solution",id:"computing-the-solution-1",children:[],level:3}],level:2},{value:"Final Code",id:"final-code",children:[],level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",children:[{value:"Part 1",id:"part-1",children:[],level:4},{value:"Part 2",id:"part-2",children:[],level:4}],level:2},{value:"Run it locally",id:"run-it-locally",children:[],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],u={toc:h};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-17-trick-shot"},"Day 17: Trick Shot"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/bishabosha"},"@bishabosha")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/17"},"https://adventofcode.com/2021/day/17")),(0,o.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,o.kt)("h3",{id:"modelling-the-domain"},"Modelling The Domain"),(0,o.kt)("h4",{id:"a-moving-probe"},"A Moving Probe"),(0,o.kt)("p",null,"The problem asks us to consider the trajectory of a projectile ",(0,o.kt)("em",{parentName:"p"},"probe"),"\nwhich has both a ",(0,o.kt)("em",{parentName:"p"},"position")," and a ",(0,o.kt)("em",{parentName:"p"},"velocity"),". Both positions and velocities\nhave two directions, ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),", with integer values. We model them\nwith case classes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Position(x: Int, y: Int)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Velocity(x: Int, y: Int)\n")),(0,o.kt)("p",null,"and then the probe is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Probe(position: Position, velocity: Velocity)\n")),(0,o.kt)("p",null,"We also find out that a probe always has an initial position of ",(0,o.kt)("inlineCode",{parentName:"p"},"0,0"),", so\nwe model that also:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val initial = Position(x = 0, y = 0)\n")),(0,o.kt)("p",null,"We are also told about the projectile motion of the probe - it moves\nin discrete steps, which we implement as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"on each step we create a new probe with a new position and a new velocity,"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," of the new position is the sum of ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," of the old position and ",(0,o.kt)("inlineCode",{parentName:"li"},"x"),"\nof the old velocity,"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," of the new position is the sum of ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," of the old position and ",(0,o.kt)("inlineCode",{parentName:"li"},"y"),"\nof the old velocity,"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," of the new velocity is given by subtracting the sign (",(0,o.kt)("inlineCode",{parentName:"li"},"-1"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"0"),"\nor ",(0,o.kt)("inlineCode",{parentName:"li"},"1"),") of the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," of the old velocity from itself (drag slows down the\nprojectile),"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," of the new velocity is given by subtracting ",(0,o.kt)("inlineCode",{parentName:"li"},"1")," from the ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," of\nthe old velocity (due to gravity).")),(0,o.kt)("p",null,"The code is written as such:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def step(probe: Probe): Probe =\n  val Probe(pos, vel) = probe\n  Probe(\n    Position(x = pos.x + vel.x, y = pos.y + vel.y),\n    Velocity(x = vel.x - vel.x.sign, y = vel.y - 1)\n  )\n")),(0,o.kt)("h4",{id:"a-target-area"},"A Target Area"),(0,o.kt)("p",null,"Next we are told that a successful launch trajectory causes the probe\nto be within a target area after at least one of its steps. The area is\ndefined by the points within a given range in the ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," directions.\nWe can model a target area by a case class with two ranges:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Target(xs: Range, ys: Range)\n")),(0,o.kt)("h3",{id:"reasoning-about-the-problem"},"Reasoning about the Problem"),(0,o.kt)("p",null,'We are told to first identify the initial velocity of trajectories that will\nhit the target area exactly, meaning that after a given step, the probe will\nbe exactly within the target area; and that we must disregard trajectories\nthat "overshoot", i.e., that pass through the entire target area in a single step.'),(0,o.kt)("p",null,"We are also told to find the maximum height (",(0,o.kt)("inlineCode",{parentName:"p"},"y")," position) reached out of\nall valid trajectories."),(0,o.kt)("h4",{id:"simulating-a-trajectory"},"Simulating a trajectory"),(0,o.kt)("p",null,"For this problem we simulate a probe moving along a trajectory, i.e.,\niterate every step of the trajectory until the probe either collides with\nthe target or has moved beyond it. And at each step we record if the\ncurrent height of the probe is higher than before."),(0,o.kt)("h5",{id:"checking-collisions"},"Checking Collisions"),(0,o.kt)("p",null,"To identify if the probe collides with the target, we check that its\n",(0,o.kt)("inlineCode",{parentName:"p"},"x")," position is within the ",(0,o.kt)("inlineCode",{parentName:"p"},"xs")," range of the target and also that its\n",(0,o.kt)("inlineCode",{parentName:"p"},"y")," position is within the ",(0,o.kt)("inlineCode",{parentName:"p"},"ys")," range of the target:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def collides(probe: Probe, target: Target): Boolean =\n  val Probe(pos, _) = probe\n  val Target(xs, ys) = target\n  xs.contains(pos.x) && ys.contains(pos.y)\n")),(0,o.kt)("h5",{id:"has-the-probe-moved-beyond-the-target"},"Has the Probe Moved Beyond the Target?"),(0,o.kt)("p",null,"We can check that the probe has moved beyond the target by considering\nsituations for each direction:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"for the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," direction:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," velocity is ",(0,o.kt)("inlineCode",{parentName:"li"},"0")," and the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," position of the probe is less than\nthe minimum ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," position of the target,"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," position of the probe is greater than the maximum ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," position\nof the target."))),(0,o.kt)("li",{parentName:"ul"},"for the ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," direction:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," velocity is less than ",(0,o.kt)("inlineCode",{parentName:"li"},"0")," and the\n",(0,o.kt)("inlineCode",{parentName:"li"},"y")," position of the probe is less than the minimum ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," position of the\ntarget.")))),(0,o.kt)("p",null,"The code to compute this is given as such:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def beyond(probe: Probe, target: Target): Boolean =\n  val Probe(pos, vel) = probe\n  val Target(xs, ys) = target\n  val beyondX = (vel.x == 0 && pos.x < xs.min) || pos.x > xs.max\n  val beyondY = vel.y < 0 && pos.y < ys.min\n  beyondX || beyondY\n")),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The above conditions make the assumptions that the ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," velocity is never\nnegative, and that the target is always in the positive ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," direction.\nThey are also informed by the fact that the probe eventually always\nhas negative velocity (due to gravity)."))),(0,o.kt)("h5",{id:"running-the-simulation"},"Running the Simulation"),(0,o.kt)("p",null,"We can use our two conditions to now simulate the trajectory of a probe:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We begin with an initial ",(0,o.kt)("inlineCode",{parentName:"li"},"probe"),", and an initial maximum height ",(0,o.kt)("inlineCode",{parentName:"li"},"maxY")," of\n",(0,o.kt)("inlineCode",{parentName:"li"},"0"),","),(0,o.kt)("li",{parentName:"ul"},"We then iterate these values - on each iteration, we apply\n",(0,o.kt)("inlineCode",{parentName:"li"},"step")," to the probe, and replace ",(0,o.kt)("inlineCode",{parentName:"li"},"maxY")," by the maximum of ",(0,o.kt)("inlineCode",{parentName:"li"},"maxY")," and\nthe ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," position of the current probe,"),(0,o.kt)("li",{parentName:"ul"},"we ignore any iteration step where the ",(0,o.kt)("inlineCode",{parentName:"li"},"probe")," does not collide\nwith, or go beyond the target, i.e., the probe is still on a valid\ntrajectory,"),(0,o.kt)("li",{parentName:"ul"},"we then find the first iteration that is not ignored, meaning that at\nthat step the probe must have either collided with the target, or gone\nbeyond it."),(0,o.kt)("li",{parentName:"ul"},"we then extract the ",(0,o.kt)("inlineCode",{parentName:"li"},"maxY")," of that iteration, provided that the ",(0,o.kt)("inlineCode",{parentName:"li"},"probe"),"\ncollided with the target.")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"simulate")," implements the rules above, taking parameters\n",(0,o.kt)("inlineCode",{parentName:"p"},"probe")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target"),", and returning an optional value -\n",(0,o.kt)("inlineCode",{parentName:"p"},"Some(maxY)")," if the trajectory reaches the target, and ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," if it went\nbeyond:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def simulate(probe: Probe, target: Target): Option[Int] =\n  LazyList\n    .iterate((probe, 0))((probe, maxY) => (step(probe), maxY `max` probe.position.y))\n    .dropWhile((probe, _) => !collides(probe, target) && !beyond(probe, target))\n    .headOption\n    .collect { case (probe, maxY) if collides(probe, target) => maxY }\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The above code uses ",(0,o.kt)("inlineCode",{parentName:"p"},"LazyList.iterate"),": it creates an infinite sequence\nof steps, applied in sequence to an initial value, where each step is\nevaluated on-demand. Next we call ",(0,o.kt)("inlineCode",{parentName:"p"},"dropWhile"),", acting like a condition\nof a while loop - it limits the size of our sequence because we know\nthat eventually one of the conditions will be broken.\nWe then call ",(0,o.kt)("inlineCode",{parentName:"p"},"headOption")," to get an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," wrapping the first element\nwe are interested in. Finally ",(0,o.kt)("inlineCode",{parentName:"p"},"collect")," allows us to inspect ",(0,o.kt)("inlineCode",{parentName:"p"},"probe"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"maxY"),", and keep ",(0,o.kt)("inlineCode",{parentName:"p"},"maxY")," when ",(0,o.kt)("inlineCode",{parentName:"p"},"probe")," matches the condition we want,\notherwise if the condition is not met ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," will be returned.")),(0,o.kt)("h4",{id:"checking-all-possible-trajectories"},"Checking all Possible Trajectories"),(0,o.kt)("p",null,"So far we have seen how to simulate the trajectory of a single\nprobe. We need to find the best possible height reached by all\ntrajectories - meaning that we need to generate some initial\nvelocities for the probe."),(0,o.kt)("p",null,"We can use some knowledge to help us reduce the search space for\npossible velocities."),(0,o.kt)("h5",{id:"lower-x-bound"},"Lower ",(0,o.kt)("inlineCode",{parentName:"h5"},"x")," Bound"),(0,o.kt)("p",null,"First, we assume that the target will always be in a positive direction\nfrom the probe's initial direction, and that the probe's ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," velocity will\nonly get closer to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", so we do not need to consider\nnegative ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," velocities."),(0,o.kt)("h5",{id:"lower-y-bound"},"Lower ",(0,o.kt)("inlineCode",{parentName:"h5"},"y")," Bound"),(0,o.kt)("p",null,"Second, we know that the problem requires us to find the highest positive\nheight reached by the probe, and that the probe's ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," velocity can only\nfall once in motion. So we do not need to consider negative ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"\nvelocities."),(0,o.kt)("p",null,"That gives us a lower bound of ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," for both of the  ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," velocities, what\nabout the upper bounds for these velocities?"),(0,o.kt)("h5",{id:"upper-x-bound"},"Upper ",(0,o.kt)("inlineCode",{parentName:"h5"},"x")," Bound"),(0,o.kt)("p",null,"We know that a trajectory is invalid if it goes beyond the target in a\nsingle step, so the largest single step that the probe can move in the ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),"\ndirection (from its initial position) is the distance of the furthest edge\nof the target, giving our upper ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," velocity bound:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val upperBoundX = target.xs.max\n")),(0,o.kt)("h5",{id:"upper-y-bound"},"Upper ",(0,o.kt)("inlineCode",{parentName:"h5"},"y")," Bound"),(0,o.kt)("p",null,"For the ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," direction, we know that when a probe launches with an initial\npositive ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," velocity, e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"y0"),", after some steps its ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," velocity will eventually\nfall below zero and the probe will cross the x axis (i.e. the probe's ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," position is ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),").\nAt this point the probe's ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," velocity will be equal to ",(0,o.kt)("inlineCode",{parentName:"p"},"(y0 + 1) * -1"),".\nIf we assume that the target will always be below the x axis, and that at the point of crossing\nthe x axis, the ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," velocity upper bound should reach the\nfurthest edge of the target in one step, then we get the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val upperBoundY = -target.ys.min - 1\n")),(0,o.kt)("h5",{id:"generating-all-maximum-heights"},"Generating all Maximum Heights"),(0,o.kt)("p",null,"To proceed we create a function ",(0,o.kt)("inlineCode",{parentName:"p"},"allMaxHeights")," to return a sequence\nof possible maximum heights, one for each valid initial velocity. It\nruns the simulation on each possible velocity within the bounds we\ndefined:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def allMaxHeights(target: Target): Seq[Int] =\n  val Target(xs, ys) = target\n  val upperBoundX = xs.max\n  val upperBoundY = -ys.min - 1\n  for\n    vx <- 0 to upperBoundX\n    vy <- 0 to upperBoundY\n    maxy <- simulate(Probe(initial, Velocity(vx, vy)), target)\n  yield\n    maxy\n")),(0,o.kt)("h3",{id:"computing-the-solution"},"Computing the Solution"),(0,o.kt)("h4",{id:"parsing-the-input"},"Parsing the Input"),(0,o.kt)("p",null,"The input for this problem is a single line, possibly ending in\na new line char. e.g."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'"target area: x=20..30, y=-10..-5\\n"\n')),(0,o.kt)("p",null,"From this input we extract two ",(0,o.kt)("inlineCode",{parentName:"p"},"Range")," values by pattern matching."),(0,o.kt)("p",null,"Values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"PartialFunction[A, B]")," can be used as extractors in\npattern matching, and as we are parsing strings, let's make a type alias\n",(0,o.kt)("inlineCode",{parentName:"p"},"Parser[A]")," to communicate our intent:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"type Parser[A] = PartialFunction[String, A]\n")),(0,o.kt)("p",null,"First, let us make a parser for ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," values. We use a regex to check\nfor a numeric string, and then call ",(0,o.kt)("inlineCode",{parentName:"p"},"toInt")," on the string if it matches:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val IntOf: Parser[Int] =\n  case s if s.matches(raw"-?\\d+") => s.toInt\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"the ",(0,o.kt)("inlineCode",{parentName:"p"},"raw")," string interpolator allows us to use regex strings without\nescaping backslash '\\'")),(0,o.kt)("p",null,"We can then use our ",(0,o.kt)("inlineCode",{parentName:"p"},"IntOf")," parser to parse a single range value.\nWe use the ",(0,o.kt)("inlineCode",{parentName:"p"},"s")," interpolator to pattern match on strings and extract\nparts from them. E.g. in the following code we extract before and\nafter ",(0,o.kt)("inlineCode",{parentName:"p"},"..")," in a string and then assert that they match ",(0,o.kt)("inlineCode",{parentName:"p"},"IntOf"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val RangeOf: Parser[Range] =\n  case s"${IntOf(begin)}..${IntOf(end)}" => begin to end\n')),(0,o.kt)("p",null,"We can finally use our ",(0,o.kt)("inlineCode",{parentName:"p"},"RangeOf")," parser to parse the input:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val Input: Parser[Target] =\n  case s"target area: x=${RangeOf(xs)}, y=${RangeOf(ys)}" => Target(xs, ys)\n')),(0,o.kt)("h4",{id:"running-the-solution"},"Running the Solution"),(0,o.kt)("p",null,"Finally we can compute the solution. First we trim our input (to remove\nunnecessary whitespace from either end).\nNext, we apply ",(0,o.kt)("inlineCode",{parentName:"p"},"Input")," on our trimmed input string, (which may throw\n",(0,o.kt)("inlineCode",{parentName:"p"},"MatchError")," if our input was invalid) and pass the resulting target to\n",(0,o.kt)("inlineCode",{parentName:"p"},"allMaxHeights"),", returning the sequence of possible maximum heights.\nWe then call ",(0,o.kt)("inlineCode",{parentName:"p"},"max")," on the sequence to get the highest:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String) =\n  allMaxHeights(Input(input.trim)).max\n")),(0,o.kt)("h2",{id:"solution-of-part-2"},"Solution of Part 2"),(0,o.kt)("h3",{id:"updating-our-search-space"},"Updating Our Search Space"),(0,o.kt)("p",null,"The problem for part 2 instead asks us to count the number of all\npossible paths that reach the target area. In this case we proceed\nas before, but must also consider the possible initial negative ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"\nvelocities. These have an upper bound equal to the furthest ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"\nedge of the target (to travel to the furthest edge in one step)."),(0,o.kt)("p",null,"We adapt ",(0,o.kt)("inlineCode",{parentName:"p"},"allMaxHeights")," with this new rule:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def allMaxHeights(target: Target)(positiveOnly: Boolean): Seq[Int] =\n  val Target(xs, ys) = target\n  val upperBoundX = xs.max\n  val upperBoundY = -ys.min -1\n  val lowerBoundY = if positiveOnly then 0 else ys.min\n  for\n    vx <- 0 to upperBoundX\n    vy <- lowerBoundY to upperBoundY\n    maxy <- simulate(Probe(initial, Velocity(vx, vy)), target)\n  yield\n    maxy\n")),(0,o.kt)("h3",{id:"computing-the-solution-1"},"Computing the Solution"),(0,o.kt)("p",null,"As our input has not changed, we can update part 1 and give the code for\npart 2 as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String) =\n  allMaxHeights(Input(input.trim))(positiveOnly = true).max\n\ndef part2(input: String) =\n  allMaxHeights(Input(input.trim))(positiveOnly = false).size\n")),(0,o.kt)("p",null,"Notice that in part 2 we only need the number of possible max heights,\nrather than find the highest."),(0,o.kt)("h2",{id:"final-code"},"Final Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'case class Target(xs: Range, ys: Range)\n\ncase class Velocity(x: Int, y: Int)\n\ncase class Position(x: Int, y: Int)\n\nval initial = Position(x = 0, y = 0)\n\ncase class Probe(position: Position, velocity: Velocity)\n\ndef step(probe: Probe): Probe =\n  val Probe(Position(px, py), Velocity(vx, vy)) = probe\n  Probe(Position(px + vx, py + vy), Velocity(vx - vx.sign, vy - 1))\n\ndef collides(probe: Probe, target: Target): Boolean =\n  val Probe(Position(px, py), _) = probe\n  val Target(xs, ys) = target\n  xs.contains(px) && ys.contains(py)\n\ndef beyond(probe: Probe, target: Target): Boolean =\n  val Probe(Position(px, py), Velocity(vx, vy)) = probe\n  val Target(xs, ys) = target\n  val beyondX = (vx == 0 && px < xs.min) || px > xs.max\n  val beyondY = vy < 0 && py < ys.min\n  beyondX || beyondY\n\ndef simulate(probe: Probe, target: Target): Option[Int] =\n  LazyList\n    .iterate((probe, 0))((probe, maxY) => (step(probe), maxY `max` probe.position.y))\n    .dropWhile((probe, _) => !collides(probe, target) && !beyond(probe, target))\n    .headOption\n    .collect { case (probe, maxY) if collides(probe, target) => maxY }\n\ndef allMaxHeights(target: Target)(positiveOnly: Boolean): Seq[Int] =\n  val upperBoundX = target.xs.max\n  val upperBoundY = target.ys.min.abs\n  val lowerBoundY = if positiveOnly then 0 else -upperBoundY\n  for\n    vx <- 0 to upperBoundX\n    vy <- lowerBoundY to upperBoundY\n    maxy <- simulate(Probe(initial, Velocity(vx, vy)), target)\n  yield\n    maxy\n\ntype Parser[A] = PartialFunction[String, A]\n\nval IntOf: Parser[Int] =\n  case s if s.matches(raw"-?\\d+") => s.toInt\n\nval RangeOf: Parser[Range] =\n  case s"${IntOf(begin)}..${IntOf(end)}" => begin to end\n\nval Input: Parser[Target] =\n  case s"target area: x=${RangeOf(xs)}, y=${RangeOf(ys)}" => Target(xs, ys)\n\ndef part1(input: String) =\n  allMaxHeights(Input(input.trim))(positiveOnly = true).max\n\ndef part2(input: String) =\n  allMaxHeights(Input(input.trim))(positiveOnly = false).size\n')),(0,o.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,o.kt)("h4",{id:"part-1"},"Part 1"),(0,o.kt)(l.Z,{puzzle:"day17-part1",mdxType:"Solver"}),(0,o.kt)("h4",{id:"part-2"},"Part 2"),(0,o.kt)(l.Z,{puzzle:"day17-part2",mdxType:"Solver"}),(0,o.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,o.kt)("p",null,"You can get this solution locally by cloning the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd advent-of-code\n")),(0,o.kt)("p",null,"You can run it with ",(0,o.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ scala-cli src -M day17.part1\nThe answer is: 4851\n\n$ scala-cli src -M day17.part2\nThe answer is: 1739\n")),(0,o.kt)("p",null,"You can replace the content of the ",(0,o.kt)("inlineCode",{parentName:"p"},"input/day14")," file with your own input from ",(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/14"},"adventofcode.com")," to get your own solution."),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day17/Day17.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day17.scala"},"Solution")," of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),".")),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page."))}c.isMDXComponent=!0}}]);