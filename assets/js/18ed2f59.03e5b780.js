"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[204],{4962:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return d},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return m},default:function(){return u}});var i=n(7462),a=n(3366),l=(n(7294),n(3905)),o=n(5623),r=["components"],d={},s="Day 8: Seven Segment Search",p={unversionedId:"puzzles/day8",id:"puzzles/day8",isDocsHomePage:!1,title:"Day 8: Seven Segment Search",description:"by @bishabosha",source:"@site/target/mdoc/puzzles/day8.md",sourceDirName:"puzzles",slug:"/puzzles/day8",permalink:"/scala-advent-of-code/puzzles/day8",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day8.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 7: The Treachery of Whales",permalink:"/scala-advent-of-code/puzzles/day7"},next:{title:"Day 9: Smoke Basin",permalink:"/scala-advent-of-code/puzzles/day9"}},m=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution of Part 1",id:"solution-of-part-1",children:[{value:"Modelling the Domain",id:"modelling-the-domain",children:[{value:"<code>Segment</code>",id:"segment",children:[],level:4},{value:"<code>Digit</code>",id:"digit",children:[],level:4},{value:"Segment Strings, aka <code>Segments</code>",id:"segment-strings-aka-segments",children:[],level:4}],level:3},{value:"Finding A Unique <code>Digit</code> from <code>Segments</code>",id:"finding-a-unique-digit-from-segments",children:[],level:3},{value:"Parsing the input",id:"parsing-the-input",children:[{value:"Parsing <code>Segments</code>",id:"parsing-segments",children:[],level:4},{value:"Parsing the input file",id:"parsing-the-input-file",children:[],level:4}],level:3},{value:"Computing the Solution",id:"computing-the-solution",children:[],level:3},{value:"Final Code",id:"final-code",children:[],level:3}],level:2},{value:"Solution of Part 2",id:"solution-of-part-2",children:[{value:"Modelling the Domain",id:"modelling-the-domain-1",children:[],level:3},{value:"Cryptography and Decoding",id:"cryptography-and-decoding",children:[],level:3},{value:"Discovering the Encoded Digits",id:"discovering-the-encoded-digits",children:[],level:3},{value:"Creating Our Subsitution Map",id:"creating-our-subsitution-map",children:[{value:"The Encoded Digits",id:"the-encoded-digits",children:[],level:4},{value:"Unique Encoded Digits Map",id:"unique-encoded-digits-map",children:[],level:4},{value:"Lookup Encoded Digit by a Subset of Segments",id:"lookup-encoded-digit-by-a-subset-of-segments",children:[],level:4},{value:"5 and 6 Segment Sections",id:"5-and-6-segment-sections",children:[],level:4},{value:"Decoding the Encoded Digits",id:"decoding-the-encoded-digits",children:[],level:4},{value:"Mapping from Encoded Digits to Digits",id:"mapping-from-encoded-digits-to-digits",children:[],level:4},{value:"Putting it all Together",id:"putting-it-all-together",children:[],level:4}],level:3},{value:"Parsing the Input",id:"parsing-the-input-1",children:[],level:3},{value:"Computing the Solution",id:"computing-the-solution-1",children:[{value:"Decoding Each Display",id:"decoding-each-display",children:[],level:4},{value:"Converting <code>Seq[Digit]</code> to <code>Int</code>",id:"converting-seqdigit-to-int",children:[],level:4},{value:"Final Result",id:"final-result",children:[],level:4}],level:3},{value:"Final Code",id:"final-code-1",children:[],level:3}],level:2},{value:"Run it locally",id:"run-it-locally",children:[],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],g={toc:m};function u(e){var t=e.components,n=(0,a.Z)(e,r);return(0,l.kt)("wrapper",(0,i.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"day-8-seven-segment-search"},"Day 8: Seven Segment Search"),(0,l.kt)("p",null,"by ",(0,l.kt)("a",{parentName:"p",href:"https://twitter.com/bishabosha"},"@bishabosha")),(0,l.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/8"},"https://adventofcode.com/2021/day/8")),(0,l.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,l.kt)("h3",{id:"modelling-the-domain"},"Modelling the Domain"),(0,l.kt)("p",null,"First we will model our problem so that we can parse the input into our model."),(0,l.kt)("p",null,"Let's look at the representation of display digits from the problem: we see that\nthere are a fixed number of possible digits for a display, and that each digit is made by activating\nsome segments, where there are a fixed number of possible segments:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  0:      1:      2:      3:      4:\n aaaa    ....    aaaa    aaaa    ....\nb    c  .    c  .    c  .    c  b    c\nb    c  .    c  .    c  .    c  b    c\n ....    ....    dddd    dddd    dddd\ne    f  .    f  e    .  .    f  .    f\ne    f  .    f  e    .  .    f  .    f\n gggg    ....    gggg    gggg    ....\n\n  5:      6:      7:      8:      9:\n aaaa    aaaa    aaaa    aaaa    aaaa\nb    .  b    .  .    c  b    c  b    c\nb    .  b    .  .    c  b    c  b    c\n dddd    dddd    ....    dddd    dddd\n.    f  e    f  .    f  e    f  .    f\n.    f  e    f  .    f  e    f  .    f\n gggg    gggg    ....    gggg    gggg\n")),(0,l.kt)("h4",{id:"segment"},(0,l.kt)("inlineCode",{parentName:"h4"},"Segment")),(0,l.kt)("p",null,"As there are a fixed range of possible display ",(0,l.kt)("em",{parentName:"p"},"segments"),":\n",(0,l.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"c"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"e"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"g"),", we will model them with an enumeration."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"An enumeration is used to define a type consisting of a set of named values.\nRead ",(0,l.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/reference/enums/enums.html"},"the official documentation"),"\nfor more details.")),(0,l.kt)("p",null,"Our enumeration ",(0,l.kt)("inlineCode",{parentName:"p"},"Segment")," looks like the following:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"enum Segment:\n  case A, B, C, D, E, F, G\n")),(0,l.kt)("h4",{id:"digit"},(0,l.kt)("inlineCode",{parentName:"h4"},"Digit")),(0,l.kt)("p",null,"Next, we will model the possible ",(0,l.kt)("em",{parentName:"p"},"digits")," of a display. Again, there are a fixed number of them\nso we will use an enumeration."),(0,l.kt)("p",null,"A ",(0,l.kt)("em",{parentName:"p"},"digit")," is made by lighting a number of ",(0,l.kt)("em",{parentName:"p"},"segments"),", so we will associate each digit with\nthe segments required to light it, we can do this by adding a parameter to ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"enum Digit(val segments: Segment*):\n  case Zero extends Digit(A, B, C, E, F, G)\n  case One extends Digit(C, F)\n  case Two extends Digit(A, C, D, E, G)\n  case Three extends Digit(A, C, D, F, G)\n  case Four extends Digit(B, C, D, F)\n  case Five extends Digit(A, B, D, F, G)\n  case Six extends Digit(A, B, D, E, F, G)\n  case Seven extends Digit(A, C, F)\n  case Eight extends Digit(A, B, C, D, E, F, G)\n  case Nine extends Digit(A, B, C, D, F, G)\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the above ",(0,l.kt)("inlineCode",{parentName:"p"},"case One extends Digit(C, F)")," defines a ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"One")," which has segments ",(0,l.kt)("inlineCode",{parentName:"p"},"C")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"F"),".")),(0,l.kt)("h4",{id:"segment-strings-aka-segments"},"Segment Strings, aka ",(0,l.kt)("inlineCode",{parentName:"h4"},"Segments")),(0,l.kt)("p",null,"In the input we see many sequences of strings, such as ",(0,l.kt)("inlineCode",{parentName:"p"},'"fdcagb"'),", which we will call\n",(0,l.kt)("em",{parentName:"p"},"segment strings"),". We can think of a segment string as a set of characters\nthat represent the segments lit in a single digit of a display.\nThese segments are not necessarily the correct configuration for viewing by humans."),(0,l.kt)("p",null,"We will model a segment string in Scala by values of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Set[Segment]"),", which we will\nsimplify with a type alias ",(0,l.kt)("inlineCode",{parentName:"p"},"Segments"),", defined in the companion object of\n",(0,l.kt)("inlineCode",{parentName:"p"},"Segment"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object Segment:\n  type Segments = Set[Segment]\n")),(0,l.kt)("h3",{id:"finding-a-unique-digit-from-segments"},"Finding A Unique ",(0,l.kt)("inlineCode",{parentName:"h3"},"Digit")," from ",(0,l.kt)("inlineCode",{parentName:"h3"},"Segments")),(0,l.kt)("p",null,"The problem asks us to find segment strings that correspond to the digits with a unique number of segments."),(0,l.kt)("p",null,"If we group the digits by the number of segments they have, we can see the following picture:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"No. Segments"),(0,l.kt)("th",{parentName:"tr",align:null},"Digits"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"{ ",(0,l.kt)("inlineCode",{parentName:"td"},"One")," }")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"{ ",(0,l.kt)("inlineCode",{parentName:"td"},"Seven")," }")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"4"),(0,l.kt)("td",{parentName:"tr",align:null},"{ ",(0,l.kt)("inlineCode",{parentName:"td"},"Four")," }")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"5"),(0,l.kt)("td",{parentName:"tr",align:null},"{ ",(0,l.kt)("inlineCode",{parentName:"td"},"Two")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"Three")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"Five")," }")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"6"),(0,l.kt)("td",{parentName:"tr",align:null},"{ ",(0,l.kt)("inlineCode",{parentName:"td"},"Zero")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"Six")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"Nine")," }")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"7"),(0,l.kt)("td",{parentName:"tr",align:null},"{ ",(0,l.kt)("inlineCode",{parentName:"td"},"Eight")," }")))),(0,l.kt)("p",null,"We can build the table above with the following code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val bySizeLookup: Map[Int, Seq[Digit]] =\n  Digit.values.toIndexedSeq.groupBy(_.segments.size)\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the above, we can access all ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit")," values with the built in ",(0,l.kt)("inlineCode",{parentName:"p"},"values")," method of the companion,\nhere we have converted it to a ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq")," for convenience.")),(0,l.kt)("p",null,"However we are only interested in the entries where the segment count is linked\nto a single digit. We can remove the entries with more than one digit, and map each key to a single digit\nwith a ",(0,l.kt)("inlineCode",{parentName:"p"},"collect")," call:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val uniqueLookup: Map[Int, Digit] =\n  bySizeLookup.collect { case k -> Seq(d) => k -> d }\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'You can think of the above as "',(0,l.kt)("em",{parentName:"p"},"keep all entries where ",(0,l.kt)("inlineCode",{parentName:"em"},"k")," is mapped to a singleton sequence, and map ",(0,l.kt)("inlineCode",{parentName:"em"},"k")," instead"),"\n",(0,l.kt)("em",{parentName:"p"},"to that single element ",(0,l.kt)("inlineCode",{parentName:"em"},"d"),'."'))),(0,l.kt)("p",null,"The content of ",(0,l.kt)("inlineCode",{parentName:"p"},"uniqueLookup")," looks like the following:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"Map(2 -> One, 3 -> Seven, 4 -> Four, 7 -> Eight)\n")),(0,l.kt)("p",null,"For our problem, we need to lookup a ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit")," from a segment string, which we will implement\nin the companion of ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),", with a method ",(0,l.kt)("inlineCode",{parentName:"p"},"lookupUnique"),". The method takes a segment string\n(of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Segments"),"), and returns an ",(0,l.kt)("inlineCode",{parentName:"p"},"Option[Digit]"),"."),(0,l.kt)("p",null,"To implement this, we call ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," on\n",(0,l.kt)("inlineCode",{parentName:"p"},"uniqueLookup")," with the size of the segment string, which returns an ",(0,l.kt)("inlineCode",{parentName:"p"},"Option[Digit]"),", depending\non whether the key was present."),(0,l.kt)("p",null,"Here is the final companion of ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit")," (where ",(0,l.kt)("inlineCode",{parentName:"p"},"uniqueLookup")," inlines the definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"bySizeLookup"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object Digit:\n\n  val index: IndexedSeq[Digit] = values.toIndexedSeq\n\n  private val uniqueLookup: Map[Int, Digit] =\n    index.groupBy(_.segments.size).collect { case k -> Seq(d) => k -> d }\n\n  def lookupUnique(segments: Segments): Option[Digit] =\n    uniqueLookup.get(segments.size)\n")),(0,l.kt)("h3",{id:"parsing-the-input"},"Parsing the input"),(0,l.kt)("h4",{id:"parsing-segments"},"Parsing ",(0,l.kt)("inlineCode",{parentName:"h4"},"Segments")),(0,l.kt)("p",null,"We will parse each segment string into ",(0,l.kt)("inlineCode",{parentName:"p"},"Segments")," aka a ",(0,l.kt)("inlineCode",{parentName:"p"},"Set[Segment]"),"."),(0,l.kt)("p",null,"First, we add a ",(0,l.kt)("inlineCode",{parentName:"p"},"char")," field to our ",(0,l.kt)("inlineCode",{parentName:"p"},"Segment")," enum: its computed by making the first character of ",(0,l.kt)("inlineCode",{parentName:"p"},"toString")," lower-case:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"enum Segment:\n  case A, B, C, D, E, F, G\n\n  val char = toString.head.toLower\n")),(0,l.kt)("p",null,"Next within ",(0,l.kt)("inlineCode",{parentName:"p"},"Segment"),"'s companion object we define:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a reverse map ",(0,l.kt)("inlineCode",{parentName:"li"},"fromChar"),", which can lookup any ",(0,l.kt)("inlineCode",{parentName:"li"},"Segment"),"\nwith a matching ",(0,l.kt)("inlineCode",{parentName:"li"},"char")," field."),(0,l.kt)("li",{parentName:"ul"},"a method ",(0,l.kt)("inlineCode",{parentName:"li"},"parseSegments")," which takes a segment string (typed as ",(0,l.kt)("inlineCode",{parentName:"li"},"String"),")\nand converts it to a ",(0,l.kt)("inlineCode",{parentName:"li"},"Set[Segment]"),", by looking up the corresponding\n",(0,l.kt)("inlineCode",{parentName:"li"},"Segment")," of each character of the string, using ",(0,l.kt)("inlineCode",{parentName:"li"},"fromChar"),".")),(0,l.kt)("p",null,"The final companion object to ",(0,l.kt)("inlineCode",{parentName:"p"},"Segment")," can be seen below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object Segment:\n  type Segments = Set[Segment]\n\n  val fromChar: Map[Char, Segment] = values.map(s => s.char -> s).toMap\n\n  def parseSegments(s: String): Segments =\n    s.map(fromChar).toSet\n")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"Please note that in ",(0,l.kt)("inlineCode",{parentName:"p"},"parseSegments")," I am assuming that ",(0,l.kt)("inlineCode",{parentName:"p"},"fromChar")," will contain each character of the input\nstring ",(0,l.kt)("inlineCode",{parentName:"p"},"s"),", which is only safe with correct input. With invalid input it will throw ",(0,l.kt)("inlineCode",{parentName:"p"},"NoSuchElementException"),"."),(0,l.kt)("p",{parentName:"div"},"To be more explicit with error handling, we could wrap ",(0,l.kt)("inlineCode",{parentName:"p"},"parseSegments")," with a ",(0,l.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/util/Try.html"},"Try"),"."))),(0,l.kt)("h4",{id:"parsing-the-input-file"},"Parsing the input file"),(0,l.kt)("p",null,"For part 1 we only need to read the four digit display section of each line, we can parse this from\na line with the following function ",(0,l.kt)("inlineCode",{parentName:"p"},"getDisplay"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def getDisplay(line: String): String = line.split('|')(1).trim\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Above, we call ",(0,l.kt)("inlineCode",{parentName:"p"},"line.split('|')"),", which will make an ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," of the two halves of the line: before and after ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),".\nWe are only interested in the second half, so we access the element at index ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),", and then call ",(0,l.kt)("inlineCode",{parentName:"p"},"trim")," to remove\nleading/terminating spaces.")),(0,l.kt)("p",null,"After using ",(0,l.kt)("inlineCode",{parentName:"p"},"getDisplay")," we will have a string ",(0,l.kt)("inlineCode",{parentName:"p"},"display"),", e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},'"fdgacbe cefdb cefbgd gcbe"'),".\nNext we call ",(0,l.kt)("inlineCode",{parentName:"p"},"display.split(' ')"),", to get a sequence of segment strings, e.g.\n",(0,l.kt)("inlineCode",{parentName:"p"},'Array("fdgacbe", "cefdb", "cefbgd", "gcbe")'),"."),(0,l.kt)("h3",{id:"computing-the-solution"},"Computing the Solution"),(0,l.kt)("p",null,"Finally we want to lookup a possible unique digit for each segment string."),(0,l.kt)("p",null,"We will create a helper function ",(0,l.kt)("inlineCode",{parentName:"p"},"parseUniqueDigit")," which first parses a segment string as\n",(0,l.kt)("inlineCode",{parentName:"p"},"Segments")," and then looks up a unique ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def parseUniqueDigit(s: String): Option[Digit] =\n  Digit.lookupUnique(Segment.parseSegments(s))\n")),(0,l.kt)("p",null,"Then, to compute the final result we will proceed as follows, for each line get the display output ",(0,l.kt)("inlineCode",{parentName:"p"},"display"),",\nthen for each display find each encoded digit ",(0,l.kt)("inlineCode",{parentName:"p"},"segments"),", for each encoded digit lookup a possible digit that uniquely\nmatches. Then get the size of the resulting unique digits:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// `input` is the input file as a String\nval uniqueDigits: Iterator[Digit] =\n  for\n    display <- input.linesIterator.map(getDisplay)\n    segments <- display.split(" ")\n    uniqueDigit <- parseUniqueDigit(segments)\n  yield\n    uniqueDigit\n\nuniqueDigits.size\n')),(0,l.kt)("h3",{id:"final-code"},"Final Code"),(0,l.kt)("p",null,"The final code for part one is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import Segment.*\n\nenum Segment:\n  case A, B, C, D, E, F, G\n\n  val char = toString.head.toLower\n\nobject Segment:\n  type Segments = Set[Segment]\n\n  val fromChar: Map[Char, Segment] = values.map(s => s.char -> s).toMap\n\n  def parseSegments(s: String): Segments =\n    s.map(fromChar).toSet\n\nend Segment\n\nenum Digit(val segments: Segment*):\n  case Zero extends Digit(A, B, C, E, F, G)\n  case One extends Digit(C, F)\n  case Two extends Digit(A, C, D, E, G)\n  case Three extends Digit(A, C, D, F, G)\n  case Four extends Digit(B, C, D, F)\n  case Five extends Digit(A, B, D, F, G)\n  case Six extends Digit(A, B, D, E, F, G)\n  case Seven extends Digit(A, C, F)\n  case Eight extends Digit(A, B, C, D, E, F, G)\n  case Nine extends Digit(A, B, C, D, F, G)\n\nobject Digit:\n\n  val index: IndexedSeq[Digit] = values.toIndexedSeq\n\n  private val uniqueLookup: Map[Int, Digit] =\n    index.groupBy(_.segments.size).collect { case k -> Seq(d) => k -> d }\n\n  def lookupUnique(segments: Segments): Option[Digit] =\n    uniqueLookup.get(segments.size)\n\nend Digit\n\ndef part1(input: String): Int =\n\n  def getDisplay(line: String): String = line.split('|')(1).trim\n\n  def parseUniqueDigit(s: String): Option[Digit] =\n    Digit.lookupUnique(Segment.parseSegments(s))\n\n  val uniqueDigits: Iterator[Digit] =\n    for\n      display <- input.linesIterator.map(getDisplay)\n      segments <- display.split(\" \")\n      uniqueDigit <- parseUniqueDigit(segments)\n    yield\n      uniqueDigit\n\n  uniqueDigits.size\nend part1\n")),(0,l.kt)(o.Z,{puzzle:"day8-part1",mdxType:"Solver"}),(0,l.kt)("h2",{id:"solution-of-part-2"},"Solution of Part 2"),(0,l.kt)("h3",{id:"modelling-the-domain-1"},"Modelling the Domain"),(0,l.kt)("p",null,"For part 2 we can reuse all data structures from part 1."),(0,l.kt)("h3",{id:"cryptography-and-decoding"},"Cryptography and Decoding"),(0,l.kt)("p",null,"In part 2 we are asked to decode each four digit display to an integer number. The problem is that each display\nis wired incorrectly, so while the signals to the display are for a correct digit, the observable output is different."),(0,l.kt)("p",null,"We know that the configuration of wires is stable, so for each display we are given a list of the 10 possible visible\noutput signals of the display (one for each digit)."),(0,l.kt)("p",null,"This problem is identical to a substitution cipher, where the encoded alphabet is the mismatch of wires to segments,\nand words are output signals (aka encoded digits). We can rediscover the original alphabet by recognising words\n(aka finding how each digit has been encoded)."),(0,l.kt)("p",null,"To solve the problem, we will take the list of 10 unique output signals (the 10 possible digits) and produce\na dictionary of these associated to their decoded forms (aka a map of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Map[Segments, Digits]"),")."),(0,l.kt)("h3",{id:"discovering-the-encoded-digits"},"Discovering the Encoded Digits"),(0,l.kt)("p",null,"In part 1 we discovered how to identify ",(0,l.kt)("inlineCode",{parentName:"p"},"One"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Four"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Seven")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Eight")," from encoded digits\nbecause their encoded forms ",(0,l.kt)("inlineCode",{parentName:"p"},"one"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"four"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"seven")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"eight")," are composed of a unique number of\nsegments. After finding those digits, we are left with six more digits to discover:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"those with 5 segments: { ",(0,l.kt)("inlineCode",{parentName:"li"},"two")," , ",(0,l.kt)("inlineCode",{parentName:"li"},"three")," , ",(0,l.kt)("inlineCode",{parentName:"li"},"five")," }"),(0,l.kt)("li",{parentName:"ul"},"those with 6 segments: { ",(0,l.kt)("inlineCode",{parentName:"li"},"zero")," , ",(0,l.kt)("inlineCode",{parentName:"li"},"six")," , ",(0,l.kt)("inlineCode",{parentName:"li"},"nine")," }")),(0,l.kt)("p",null,"To help us, lets look again at the valid configurations of segments for digits:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  0:      1:      2:      3:      4:\n aaaa    ....    aaaa    aaaa    ....\nb    c  .    c  .    c  .    c  b    c\nb    c  .    c  .    c  .    c  b    c\n ....    ....    dddd    dddd    dddd\ne    f  .    f  e    .  .    f  .    f\ne    f  .    f  e    .  .    f  .    f\n gggg    ....    gggg    gggg    ....\n\n  5:      6:      7:      8:      9:\n aaaa    aaaa    aaaa    aaaa    aaaa\nb    .  b    .  .    c  b    c  b    c\nb    .  b    .  .    c  b    c  b    c\n dddd    dddd    ....    dddd    dddd\n.    f  e    f  .    f  e    f  .    f\n.    f  e    f  .    f  e    f  .    f\n gggg    gggg    ....    gggg    gggg\n")),(0,l.kt)("p",null,"You might notice that some of the digits fit within another. For example, ",(0,l.kt)("inlineCode",{parentName:"p"},"One")," overlaps with\nall of ",(0,l.kt)("inlineCode",{parentName:"p"},"Zero"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Three"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Four"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Seven"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Eight"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"Nine"),"."),(0,l.kt)("p",null,"We can formalise this by saying the set of segments for ",(0,l.kt)("inlineCode",{parentName:"p"},"One")," is a\nsubset of the segments for each of those other digits."),(0,l.kt)("p",null,"If we are trying to identify the encoded digits ",(0,l.kt)("inlineCode",{parentName:"p"},"zero"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"three")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"nine")," however, we can't use ",(0,l.kt)("inlineCode",{parentName:"p"},"one")," to identify\nthem without some extra steps, as ",(0,l.kt)("inlineCode",{parentName:"p"},"one")," is a subset of all of those encoded digits."),(0,l.kt)("p",null,"To help us, we can instead use the number of segments in each encoded digit:\n",(0,l.kt)("inlineCode",{parentName:"p"},"zero")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"nine")," both have 6 segments, but ",(0,l.kt)("inlineCode",{parentName:"p"},"three")," has 5 segments. We can then conclude\nthat out of the encoded digits with 5 segments, ",(0,l.kt)("inlineCode",{parentName:"p"},"three")," can be discovered by finding\nthe unique element where ",(0,l.kt)("inlineCode",{parentName:"p"},"one")," is a subset."),(0,l.kt)("p",null,"Once we have discovered ",(0,l.kt)("inlineCode",{parentName:"p"},"three"),", that leaves only { ",(0,l.kt)("inlineCode",{parentName:"p"},"two")," , ",(0,l.kt)("inlineCode",{parentName:"p"},"five")," } to discover out of those with 5 segments."),(0,l.kt)("p",null,"We can continue in this fashion to discover all the remaining encoded digits, formalised in this table below:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Step"),(0,l.kt)("th",{parentName:"tr",align:null},"Encoded Digit"),(0,l.kt)("th",{parentName:"tr",align:null},"Rule"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"one")),(0,l.kt)("td",{parentName:"tr",align:null},"the encoded digit with the same number of segments as ",(0,l.kt)("inlineCode",{parentName:"td"},"One"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"four")),(0,l.kt)("td",{parentName:"tr",align:null},"the encoded digit with the same number of segments as ",(0,l.kt)("inlineCode",{parentName:"td"},"Four"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"seven")),(0,l.kt)("td",{parentName:"tr",align:null},"the encoded digit with the same number of segments as ",(0,l.kt)("inlineCode",{parentName:"td"},"Seven"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"eight")),(0,l.kt)("td",{parentName:"tr",align:null},"the encoded digit with the same number of segments as ",(0,l.kt)("inlineCode",{parentName:"td"},"Eight"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"three")),(0,l.kt)("td",{parentName:"tr",align:null},"unique encoded digit from { ",(0,l.kt)("inlineCode",{parentName:"td"},"two")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"three")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"five")," } where ",(0,l.kt)("inlineCode",{parentName:"td"},"one")," is a subset")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"nine")),(0,l.kt)("td",{parentName:"tr",align:null},"unique encoded digit from { ",(0,l.kt)("inlineCode",{parentName:"td"},"zero")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"six")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"nine")," } where ",(0,l.kt)("inlineCode",{parentName:"td"},"three")," is a subset")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zero")),(0,l.kt)("td",{parentName:"tr",align:null},"unique encoded digit from { ",(0,l.kt)("inlineCode",{parentName:"td"},"zero")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"six")," } where ",(0,l.kt)("inlineCode",{parentName:"td"},"seven")," is a subset")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"five")),(0,l.kt)("td",{parentName:"tr",align:null},"unique encoded digit from { ",(0,l.kt)("inlineCode",{parentName:"td"},"two")," , ",(0,l.kt)("inlineCode",{parentName:"td"},"five")," } where (",(0,l.kt)("inlineCode",{parentName:"td"},"four")," ",(0,l.kt)("inlineCode",{parentName:"td"},"\\")," ",(0,l.kt)("inlineCode",{parentName:"td"},"one"),") is a subset")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"4"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"two")),(0,l.kt)("td",{parentName:"tr",align:null},"remaining encoded digit from { ",(0,l.kt)("inlineCode",{parentName:"td"},"two")," }")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"4"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"six")),(0,l.kt)("td",{parentName:"tr",align:null},"remaining encoded digit from { ",(0,l.kt)("inlineCode",{parentName:"td"},"six")," }")))),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"In the above table (",(0,l.kt)("inlineCode",{parentName:"p"},"four")," ",(0,l.kt)("inlineCode",{parentName:"p"},"\\")," ",(0,l.kt)("inlineCode",{parentName:"p"},"one"),") means the ",(0,l.kt)("em",{parentName:"p"},"set difference"),", i.e. the set of segments formed from\nremoving segments of ",(0,l.kt)("inlineCode",{parentName:"p"},"one")," from segments of ",(0,l.kt)("inlineCode",{parentName:"p"},"four"),"."))),(0,l.kt)("p",null,"Once we have discovered all the encoded digits, we build a dictionary by associating each encoded digit to\nthe original digit."),(0,l.kt)("h3",{id:"creating-our-subsitution-map"},"Creating Our Subsitution Map"),(0,l.kt)("p",null,"We will implement our discovery rules with a few helpers."),(0,l.kt)("h4",{id:"the-encoded-digits"},"The Encoded Digits"),(0,l.kt)("p",null,"First, we will refer to our list of 10 encoded digits by the value ",(0,l.kt)("inlineCode",{parentName:"p"},"cipher"),", of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[Segments]"),"."),(0,l.kt)("h4",{id:"unique-encoded-digits-map"},"Unique Encoded Digits Map"),(0,l.kt)("p",null,"We will build a map ",(0,l.kt)("inlineCode",{parentName:"p"},"uniques")," from ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit")," to the encoded digits with unique segments size,\nreusing ",(0,l.kt)("inlineCode",{parentName:"p"},"lookupUnique")," from part 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val uniques: Map[Digit, Segments] =\n  Map.from(\n    for\n      segments <- cipher\n      digit <- Digit.lookupUnique(segments)\n    yield\n      digit -> segments\n  )\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Above, we apply ",(0,l.kt)("inlineCode",{parentName:"p"},"Map.from")," to a sequence of key value pairs (formed by ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," ",(0,l.kt)("inlineCode",{parentName:"p"},"->")," ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),"). The values are formed by\ntaking each encoded digit, passing it to ",(0,l.kt)("inlineCode",{parentName:"p"},"lookupUnique"),", and if the encoded digit corresponds to a unique digit,\nthen pair the valid digit with the encoded digit.")),(0,l.kt)("h4",{id:"lookup-encoded-digit-by-a-subset-of-segments"},"Lookup Encoded Digit by a Subset of Segments"),(0,l.kt)("p",null,"Next we need to be able to use a set of segments to select a unique encoded digit from a list, and return the\nremaining encoded digits."),(0,l.kt)("p",null,"We will do this by creating a function ",(0,l.kt)("inlineCode",{parentName:"p"},"lookup")," which takes a list of encoded digits\n(",(0,l.kt)("inlineCode",{parentName:"p"},"section"),") and a discriminator segment set (",(0,l.kt)("inlineCode",{parentName:"p"},"withSegments"),").\nIt produces a pair where the left element is the selected encoded digit, and the right element is the\nremaining encoded digits:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def lookup(section: Seq[Segments], withSegments: Segments): (Segments, Seq[Segments]) =\n  val (Seq(uniqueMatch), remaining) = section.partition(withSegments.subsetOf)\n  (uniqueMatch, remaining)\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Above we call ",(0,l.kt)("inlineCode",{parentName:"p"},"section.partition(withSegments.subsetOf)")," to create a pair of lists, the left is encoded digits\nof ",(0,l.kt)("inlineCode",{parentName:"p"},"section")," that ",(0,l.kt)("inlineCode",{parentName:"p"},"withSegments")," is a subset of, and the right are encoded digits where it is not.\nWe expect to find only one unique match for ",(0,l.kt)("inlineCode",{parentName:"p"},"withSegments"),", so we also assert that a singleton\nlist is returned on the left.")),(0,l.kt)("h4",{id:"5-and-6-segment-sections"},"5 and 6 Segment Sections"),(0,l.kt)("p",null,"We will create sections of encoded digits of size 5 and size 6:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val ofSizeFive = cipher.filter(encoded => encoded.sizeIs == 5)\nval ofSizeSix = cipher.filter(encoded => encoded.sizeIs == 6)\n")),(0,l.kt)("h4",{id:"decoding-the-encoded-digits"},"Decoding the Encoded Digits"),(0,l.kt)("p",null,"We can now proceed to implement our rules and discover each encoded digit:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import Digit.*\n\nval one = uniques(One)\nval four = uniques(Four)\nval seven = uniques(Seven)\nval eight = uniques(Eight)\nval (three, remainingFives) = lookup(ofSizeFive, withSegments = one)\nval (nine, remainingSixes) = lookup(ofSizeSix, withSegments = three)\nval (zero, Seq(six)) = lookup(remainingSixes, withSegments = seven)\nval (five, Seq(two)) = lookup(remainingFives, withSegments = four &~ one)\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In Scala ",(0,l.kt)("inlineCode",{parentName:"p"},"&~")," is the set difference operator. We also lookup (",(0,l.kt)("inlineCode",{parentName:"p"},"zero")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"six"),") and (",(0,l.kt)("inlineCode",{parentName:"p"},"five")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"two"),")\nin one step, as we know that ",(0,l.kt)("inlineCode",{parentName:"p"},"six")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"two")," are the only possible elements of the remaining lists."),(0,l.kt)("p",{parentName:"blockquote"},"We also create new lists, (i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"remainingFives")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"remainingSixes"),") instead of reusing the originals\n(",(0,l.kt)("inlineCode",{parentName:"p"},"ofSizeFive"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ofSizeSix"),") because we cannot remove elements from lists after their creation.")),(0,l.kt)("h4",{id:"mapping-from-encoded-digits-to-digits"},"Mapping from Encoded Digits to Digits"),(0,l.kt)("p",null,"We can now map from the encoded digits to the original digits by associating each encoded digit with the original:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val decode: Map[Segments, Digit] =\n  Seq(zero, one, two, three, four, five, six, seven, eight, nine)\n    .zip(Digit.index)\n    .toMap\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the above, we create a map by first putting the encoded digits in order, we then ",(0,l.kt)("inlineCode",{parentName:"p"},"zip")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit.index"),",\ncreating a list of key-value pairs of encoded digit to ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),". Finally we can call ",(0,l.kt)("inlineCode",{parentName:"p"},".toMap")," which creates a lookup\ntable from the list of pairs."),(0,l.kt)("p",{parentName:"blockquote"},"Recall that ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq(1, 2, 3).zip(Seq('a', 'b', 'c'))")," results in ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq((1, 'a'), (2, 'b'), (3, 'c'))"),".\nSo we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"zip")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit.index")," because it is an ordered sequence of ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),".")),(0,l.kt)("h4",{id:"putting-it-all-together"},"Putting it all Together"),(0,l.kt)("p",null,"We can then put all the parts for decoding the digits into one function ",(0,l.kt)("inlineCode",{parentName:"p"},"substitutions")," (seen in the final code),\nwith a single argument ",(0,l.kt)("inlineCode",{parentName:"p"},"cipher")," (the list of 10 encoded digits) and returning the ",(0,l.kt)("inlineCode",{parentName:"p"},"decode")," map."),(0,l.kt)("h3",{id:"parsing-the-input-1"},"Parsing the Input"),(0,l.kt)("p",null,"To parse the inputs this time, we will split each line by ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),", and then convert each half of the line\nto a sequence of segment strings by splitting each half on ",(0,l.kt)("inlineCode",{parentName:"p"},"' '"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def parseSegmentsSeq(segments: String): Seq[Segments] =\n  segments.trim.split(\" \").toSeq.map(Segment.parseSegments)\n\ndef splitParts(line: String): (Seq[Segments], Seq[Segments]) =\n  val Array(cipher, plaintext) = line.split('|').map(parseSegmentsSeq)\n  (cipher, plaintext)\n")),(0,l.kt)("h3",{id:"computing-the-solution-1"},"Computing the Solution"),(0,l.kt)("h4",{id:"decoding-each-display"},"Decoding Each Display"),(0,l.kt)("p",null,"To decode each display, first we parse the input into our problems, i.e.\na sequence of pairs where the left element is the 10 encoded digits ",(0,l.kt)("inlineCode",{parentName:"p"},"cipher"),", and the right element is the display of\n4 encoded digits ",(0,l.kt)("inlineCode",{parentName:"p"},"plaintext"),"."),(0,l.kt)("p",null,"Then for each problem, we can then\ncreate the substitution map by applying ",(0,l.kt)("inlineCode",{parentName:"p"},"substitutions")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"cipher"),", then we can\nuse the substitution map on each encoded digit of ",(0,l.kt)("inlineCode",{parentName:"p"},"plaintext")," to convert it to a ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),"."),(0,l.kt)("p",null,"We are then left with ",(0,l.kt)("inlineCode",{parentName:"p"},"solutions"),", which is a list of decoded displays, where each display is a ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq[Digit]"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val problems = input.linesIterator.map(splitParts)\n\nval solutions = problems.map((cipher, plaintext) =>\n  plaintext.map(substitutions(cipher))\n)\n")),(0,l.kt)("h4",{id:"converting-seqdigit-to-int"},"Converting ",(0,l.kt)("inlineCode",{parentName:"h4"},"Seq[Digit]")," to ",(0,l.kt)("inlineCode",{parentName:"h4"},"Int")),(0,l.kt)("p",null,"The problem wants us to sum the total of all digit displays after decoding.\nEach display has 4 digits, so after decoding the digits we will have a sequence of 4 ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit"),"."),(0,l.kt)("p",null,"To convert a sequence of ",(0,l.kt)("inlineCode",{parentName:"p"},"Digit")," to an integer value, we can convert each digit to its corresponding integer\nrepresentation by calling ",(0,l.kt)("inlineCode",{parentName:"p"},".ordinal"),", and then we can accumulate a sum by (from the left),\nmultiplying the current total by 10 for each new digit, and then adding the current digit:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def digitsToInt(digits: Seq[Digit]): Int =\n  digits.foldLeft(0)((acc, d) => acc * 10 + d.ordinal)\n")),(0,l.kt)("h4",{id:"final-result"},"Final Result"),(0,l.kt)("p",null,"Finally, we use our ",(0,l.kt)("inlineCode",{parentName:"p"},"digitsToInt")," function to convert each solution to an integer value, and sum the result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"solutions.map(digitsToInt).sum\n")),(0,l.kt)("h3",{id:"final-code-1"},"Final Code"),(0,l.kt)("p",null,"The final code for part 2 can be appended to the code of part 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import Digit.*\n\ndef part2(input: String): Int =\n\n  def parseSegmentsSeq(segments: String): Seq[Segments] =\n    segments.trim.split(\" \").toSeq.map(Segment.parseSegments)\n\n  def splitParts(line: String): (Seq[Segments], Seq[Segments]) =\n    val Array(cipher, plaintext) = line.split('|').map(parseSegmentsSeq)\n    (cipher, plaintext)\n\n  def digitsToInt(digits: Seq[Digit]): Int =\n    digits.foldLeft(0)((acc, d) => acc * 10 + d.ordinal)\n\n  val problems = input.linesIterator.map(splitParts)\n\n  val solutions = problems.map((cipher, plaintext) =>\n    plaintext.map(substitutions(cipher))\n  )\n\n  solutions.map(digitsToInt).sum\n\nend part2\n\ndef substitutions(cipher: Seq[Segments]): Map[Segments, Digit] =\n\n  def lookup(section: Seq[Segments], withSegments: Segments): (Segments, Seq[Segments]) =\n    val (Seq(uniqueMatch), remaining) = section.partition(withSegments.subsetOf)\n    (uniqueMatch, remaining)\n\n  val uniques: Map[Digit, Segments] =\n    Map.from(\n      for\n        segments <- cipher\n        digit <- Digit.lookupUnique(segments)\n      yield\n        digit -> segments\n    )\n\n  val ofSizeFive = cipher.filter(_.sizeIs == 5)\n  val ofSizeSix = cipher.filter(_.sizeIs == 6)\n\n  val one = uniques(One)\n  val four = uniques(Four)\n  val seven = uniques(Seven)\n  val eight = uniques(Eight)\n  val (three, remainingFives) = lookup(ofSizeFive, withSegments = one)\n  val (nine, remainingSixes) = lookup(ofSizeSix, withSegments = three)\n  val (zero, Seq(six)) = lookup(remainingSixes, withSegments = seven)\n  val (five, Seq(two)) = lookup(remainingFives, withSegments = four &~ one)\n\n  val decode: Map[Segments, Digit] =\n    Seq(zero, one, two, three, four, five, six, seven, eight, nine)\n      .zip(Digit.index)\n      .toMap\n\n  decode\nend substitutions\n")),(0,l.kt)(o.Z,{puzzle:"day8-part2",mdxType:"Solver"}),(0,l.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,l.kt)("p",null,"You can get this solution locally by cloning the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd advent-of-code\n")),(0,l.kt)("p",null,"You can run it with ",(0,l.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ scala-cli src -M day8.part1\nThe solution is 521\n\n$ scala-cli src -M day8.part2\nThe solution is 1016804\n")),(0,l.kt)("p",null,"You can replace the content of the ",(0,l.kt)("inlineCode",{parentName:"p"},"input/day8")," file with your own input from ",(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/8"},"adventofcode.com")," to get your own solution."),(0,l.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/tOverney/AdventOfCode2021/blob/main/src/main/scala/ch/overney/aoc/day8/"},"Solution")," of ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/tOverney"},"@tOverney"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day08/Day08.scala"},"Solution")," of ",(0,l.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),".")),(0,l.kt)("p",null,"Share your solution to the Scala community by editing this page."))}u.isMDXComponent=!0}}]);