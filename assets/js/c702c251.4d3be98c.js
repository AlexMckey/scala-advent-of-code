"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8960],{6970:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));n(6340);const i={},o="Day 5: If You Give A Seed A Fertilizer",s={unversionedId:"2023/puzzles/day05",id:"2023/puzzles/day05",title:"Day 5: If You Give A Seed A Fertilizer",description:"by @g.berezin and @bishabosha",source:"@site/target/mdoc/2023/puzzles/day05.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day05",permalink:"/scala-advent-of-code/2023/puzzles/day05",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day05.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 4: Scratchcards",permalink:"/scala-advent-of-code/2023/puzzles/day04"},next:{title:"Day 6: Wait For It",permalink:"/scala-advent-of-code/2023/puzzles/day06"}},l={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Data Structures",id:"data-structures",level:3},{value:"Parts 1 and 2",id:"parts-1-and-2",level:3},{value:"Parsing",id:"parsing",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"day-5-if-you-give-a-seed-a-fertilizer"},"Day 5: If You Give A Seed A Fertilizer"),(0,r.kt)("p",null,"by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GrigoriiBerezin"},"@g.berezin")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")),(0,r.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/5"},"https://adventofcode.com/2023/day/5")),(0,r.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,r.kt)("h3",{id:"data-structures"},"Data Structures"),(0,r.kt)("p",null,"First and foremost, the data must be parsed from the file into the following classes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A data structure representing the pairing of a resource kind and the range it occupies:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// in the first task you can use the same model but set `end = start`\nfinal case class Resource(\n  start: Long, end: Long, kind: ResourceKind)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An enumeration for storing the kind of resource:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"enum ResourceKind:\n  case Seed, Soil, Fertilizer, Water,\n    Light, Temperature, Humidity, Location\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A schema for converting from one resource type to another:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"final case class ResourceMap(\n  from: ResourceKind,\n  to: ResourceKind,\n  properties: Seq[Property] // sorted by `sourceStart`\n)\n\nfinal case class Property(\n    destinationStart: Long,\n    sourceStart: Long,\n    rangeLength: Long\n  ):\n\n  lazy val sourceEnd: Long = sourceStart + rangeLength - 1\nend Property\n")),(0,r.kt)("h3",{id:"parts-1-and-2"},"Parts 1 and 2"),(0,r.kt)("p",null,"It helps to consider parts 1 and 2 together when explaining the solution.\nIn part 1, you are required to convert each ",(0,r.kt)("inlineCode",{parentName:"p"},"Seed")," to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Location"),", using a chain of ",(0,r.kt)("inlineCode",{parentName:"p"},"ResourceMap"),".\nIn most inputs you likely have about 20 seeds to consider, so this is not an expensive operation.\nHowever in the second half of the solution, you must actually consider 10 ranges of seeds, where each range can be billions of elements long, so it is not practical to consider individual seeds."),(0,r.kt)("p",null,"Considering the number of seeds in the input data, so you should manipulate the resources in the form of intervals, and when passing through the ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," of a ",(0,r.kt)("inlineCode",{parentName:"p"},"ResourceMap"),", you divide an input resource interval into semi-intervals depending on how the interval intersects with an individual ",(0,r.kt)("inlineCode",{parentName:"p"},"Property"),"."),(0,r.kt)("p",null,"Conveniently for part 1, a single seed can be considered as an interval with one element, so we can reuse the same code for both parts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"type ParseSeeds = String => Seq[Resource]\n\ndef calculate(seeds: Seq[Resource], maps: Seq[ResourceMap]): Long = ???\n\ndef solution(input: String, parse: ParseSeeds): Long =\n  val lines = input.linesIterator.toSeq\n  val seeds = lines.headOption.map(parse).getOrElse(Seq.empty)\n  val maps = ResourceMap.buildFromLines(lines)\n  calculate(seeds, maps)\n\ndef part1(input: String): Long =\n  solution(input, Seeds.parseWithoutRange)\n\ndef part2(input: String): Long =\n  solution(input, Seeds.parse)\n")),(0,r.kt)("p",null,"The calculation proceeds as follows, iterate through the initial seeds,\nand for each seed interval (typed as ",(0,r.kt)("inlineCode",{parentName:"p"},"Resource"),"), iterate, passing the interval through the\nresource map for its ",(0,r.kt)("inlineCode",{parentName:"p"},"kind"),", potentially splitting into several new intervals.\nIf after an iteration the resource is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Location"),", then stop."),(0,r.kt)("p",null,"Once all the valid location intervals are found, find the interval with the smallest ",(0,r.kt)("inlineCode",{parentName:"p"},"start"),"\nand return it as the answer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def calculate(seeds: Seq[Resource], maps: Seq[ResourceMap]): Long =\n  def inner(resource: Resource): Seq[Resource] =\n    if resource.kind == ResourceKind.Location then\n      Seq(resource) // We have reached the end!\n    else\n      val map = maps.find(_.from == resource.kind).get\n      findNext(resource, map).flatMap(inner)\n  seeds.flatMap(inner).minBy(_.start).start\nend calculate\n")),(0,r.kt)("p",null,"The next interesting calculation is sending an individual ",(0,r.kt)("inlineCode",{parentName:"p"},"Resource")," interval through a ",(0,r.kt)("inlineCode",{parentName:"p"},"ResourceMap"),".\nIn our representation, the ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," are sorted by their ",(0,r.kt)("inlineCode",{parentName:"p"},"sourceStart"),".\nFrom an initial interval, we can then iterate through the ",(0,r.kt)("inlineCode",{parentName:"p"},"properties"),", attempting to\nfind any sub-interval that overlaps with its range."),(0,r.kt)("p",null,"There is a special case for the first property - the interval might actually be ",(0,r.kt)("inlineCode",{parentName:"p"},"under")," the range,\ni.e. some part of it is before the initial property. In this case we should create a new sub-interval\nthat just before the ",(0,r.kt)("inlineCode",{parentName:"p"},"sourceStart")," that is sent directly to the next resource kind."),(0,r.kt)("p",null,"There may be overlap with the property, in this case, we need to create a sub-interval of\njust the intersection with that property, and convert the start to the appropriate offset from the\n",(0,r.kt)("inlineCode",{parentName:"p"},"destinationStart"),"."),(0,r.kt)("p",null,"Often, there is part of the interval that is ",(0,r.kt)("inlineCode",{parentName:"p"},"above")," the end of the current property range.\nIn this case we must make a new sub-interval that begins after the end of the property range."),(0,r.kt)("p",null,"If we do find an ",(0,r.kt)("inlineCode",{parentName:"p"},"above")," sub-interval, then we need to check that against the next ",(0,r.kt)("inlineCode",{parentName:"p"},"Property"),".\nOtherwise then we can shortcut the computation and not check any of the following properties."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def findNext(resource: Resource, map: ResourceMap): Seq[Resource] =\n  val ResourceMap(from, to, properties) = map\n  val (newResources, explore) =\n    val initial = (Seq.empty[Resource], Option(resource))\n    properties.foldLeft(initial) {\n      case ((acc, Some(explore)), prop) =>\n        val Resource(start, end, _) = explore\n        val propStart = prop.sourceStart\n        val propEnd = prop.sourceEnd\n        val underRange = Option.when(start < propStart)(\n          Resource(start, Math.min(propStart - 1, end), to)\n        )\n        val overlaps =\n          start >= propStart && start <= propEnd\n          || end >= propStart && end <= propEnd\n          || start <= propStart && end >= propEnd\n        val inRange = Option.when(overlaps) {\n          val delay = prop.destinationStart - propStart\n          Resource(\n            Math.max(start, propStart) + delay,\n            Math.min(end, propEnd) + delay,\n            to\n          )\n        }\n        val aboveRange = Option.when(end > propEnd)(\n          Resource(Math.max(start, propEnd + 1), end, to)\n        )\n        (Seq(underRange, inRange, acc).flatten, aboveRange)\n      case ((acc, None), _) => (acc, None)\n    }\n  Seq(newResources, explore).flatten\nend findNext\n")),(0,r.kt)("h3",{id:"parsing"},"Parsing"),(0,r.kt)("p",null,"In this section we list the code to parse the input into ",(0,r.kt)("inlineCode",{parentName:"p"},"ResourceMap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Resource"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object ResourceMap:\n  // parse resource maps from lines\n  def buildFromLines(lines: Seq[String]): Seq[ResourceMap] =\n    def isRangeLine(line: String) =\n      line.forall(ch => ch.isDigit || ch.isSpaceChar)\n    lines.filter(line =>\n      !line.isBlank &&\n      (line.endsWith("map:") || isRangeLine(line))\n    ).foldLeft(Seq.empty[(String, Seq[String])]) {\n      case (acc, line) if line.endsWith("map:") =>\n        (line, Seq.empty) +: acc\n      case (Seq((definition, properties), last*), line) =>\n        (definition, line +: properties) +: last\n    }\n    .flatMap(build)\n\n  def build(map: String, ranges: Seq[String]): Option[ResourceMap] =\n    val mapRow = map.replace("map:", "").trim.split("-to-")\n    val properties = ranges\n      .map(line => line.split(" ").flatMap(_.toLongOption))\n      .collect:\n        case Array(startFrom, startTo, range) =>\n          Property(startFrom, startTo, range)\n    def resourceKindOf(optStr: Option[String]) =\n      optStr.map(_.capitalize).map(ResourceKind.valueOf)\n    for\n      from <- resourceKindOf(mapRow.headOption)\n      to <- resourceKindOf(mapRow.lastOption)\n    yield\n      ResourceMap(from, to, properties.sortBy(_.sourceStart))\nend ResourceMap\n\nobject Seeds:\n  private def parseSeedsRaw(line: String): Seq[Long] =\n    if !line.startsWith("seeds:") then Seq.empty[Long]\n    else\n      line.replace("seeds:", "")\n        .trim\n        .split(" ")\n        .flatMap(_.toLongOption)\n\n  // parse seeds without range\n  def parseWithoutRange(line: String): Seq[Resource] =\n    parseSeedsRaw(line).map: start =>\n      Resource(start, start, ResourceKind.Seed)\n\n  // parse seeds with range\n  def parse(line: String): Seq[Resource] =\n    parseSeedsRaw(line)\n      .grouped(2)\n      .map { case Seq(start, length) =>\n        Resource(start, start + length - 1, ResourceKind.Seed)\n      }\n      .toSeq\nend Seeds\n')),(0,r.kt)("h2",{id:"final-code"},"Final Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'final case class Resource(\n  start: Long, end: Long, kind: ResourceKind)\n\nenum ResourceKind:\n  case Seed, Soil, Fertilizer, Water,\n    Light, Temperature, Humidity, Location\n\nfinal case class ResourceMap(\n  from: ResourceKind,\n  to: ResourceKind,\n  properties: Seq[Property]\n)\n\nfinal case class Property(\n    destinationStart: Long,\n    sourceStart: Long,\n    rangeLength: Long\n  ):\n\n  lazy val sourceEnd: Long = sourceStart + rangeLength - 1\nend Property\n\ndef findNext(resource: Resource, map: ResourceMap): Seq[Resource] =\n  val ResourceMap(from, to, properties) = map\n  val (newResources, explore) =\n    val initial = (Seq.empty[Resource], Option(resource))\n    properties.foldLeft(initial) {\n      case ((acc, Some(explore)), prop) =>\n        val Resource(start, end, _) = explore\n        val propStart = prop.sourceStart\n        val propEnd = prop.sourceEnd\n        val underRange = Option.when(start < propStart)(\n          Resource(start, Math.min(propStart - 1, end), to)\n        )\n        val overlaps =\n          start >= propStart && start <= propEnd\n          || end >= propStart && end <= propEnd\n          || start <= propStart && end >= propEnd\n        val inRange = Option.when(overlaps) {\n          val delay = prop.destinationStart - propStart\n          Resource(\n            Math.max(start, propStart) + delay,\n            Math.min(end, propEnd) + delay,\n            to\n          )\n        }\n        val aboveRange = Option.when(end > propEnd)(\n          Resource(Math.max(start, propEnd + 1), end, to)\n        )\n        (Seq(underRange, inRange, acc).flatten, aboveRange)\n      case ((acc, None), _) => (acc, None)\n    }\n  Seq(newResources, explore).flatten\nend findNext\n\nobject ResourceMap:\n  // parse resource maps from lines\n  def buildFromLines(lines: Seq[String]): Seq[ResourceMap] =\n    def isRangeLine(line: String) =\n      line.forall(ch => ch.isDigit || ch.isSpaceChar)\n    lines.filter(line =>\n      !line.isBlank &&\n      (line.endsWith("map:") || isRangeLine(line))\n    ).foldLeft(Seq.empty[(String, Seq[String])]) {\n      case (acc, line) if line.endsWith("map:") =>\n        (line, Seq.empty) +: acc\n      case (Seq((definition, properties), last*), line) =>\n        (definition, line +: properties) +: last\n    }\n    .flatMap(build)\n\n  def build(map: String, ranges: Seq[String]): Option[ResourceMap] =\n    val mapRow = map.replace("map:", "").trim.split("-to-")\n    val properties = ranges\n      .map(line => line.split(" ").flatMap(_.toLongOption))\n      .collect:\n        case Array(startFrom, startTo, range) =>\n          Property(startFrom, startTo, range)\n    def resourceKindOf(optStr: Option[String]) =\n      optStr.map(_.capitalize).map(ResourceKind.valueOf)\n    for\n      from <- resourceKindOf(mapRow.headOption)\n      to <- resourceKindOf(mapRow.lastOption)\n    yield\n      ResourceMap(from, to, properties.sortBy(_.sourceStart))\nend ResourceMap\n\nobject Seeds:\n  private def parseSeedsRaw(line: String): Seq[Long] =\n    if !line.startsWith("seeds:") then Seq.empty[Long]\n    else\n      line.replace("seeds:", "")\n        .trim\n        .split(" ")\n        .flatMap(_.toLongOption)\n\n  // parse seeds without range\n  def parseWithoutRange(line: String): Seq[Resource] =\n    parseSeedsRaw(line).map: start =>\n      Resource(start, start, ResourceKind.Seed)\n\n  // parse seeds with range\n  def parse(line: String): Seq[Resource] =\n    parseSeedsRaw(line)\n      .grouped(2)\n      .map { case Seq(start, length) =>\n        Resource(start, start + length - 1, ResourceKind.Seed)\n      }\n      .toSeq\nend Seeds\n\ndef calculate(seeds: Seq[Resource], maps: Seq[ResourceMap]): Long =\n  def inner(resource: Resource): Seq[Resource] =\n    if resource.kind == ResourceKind.Location then\n      Seq(resource)\n    else\n      val map = maps.find(_.from == resource.kind).get\n      findNext(resource, map).flatMap(inner)\n  seeds.flatMap(inner).minBy(_.start).start\nend calculate\n\ntype ParseSeeds = String => Seq[Resource]\n\ndef solution(input: String, parse: ParseSeeds): Long =\n  val lines = input.linesIterator.toSeq\n  val seeds = lines.headOption.map(parse).getOrElse(Seq.empty)\n  val maps = ResourceMap.buildFromLines(lines)\n  calculate(seeds, maps)\n\ndef part1(input: String): Long =\n  solution(input, Seeds.parseWithoutRange)\n\ndef part2(input: String): Long =\n  solution(input, Seeds.parse)\n')),(0,r.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,r.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/alexandru/advent-of-code/blob/main/scala3/2023/src/main/scala/day5.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/alexandru/"},"Alexandru Nedelcu")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2023/day5/Day5.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh/aoc-2023/blob/main/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh"},"Thanh Le")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/mpilquist/aoc/blob/main/2023/day5.sc"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/mpilquist"},"Michael Pilquist")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/05.worksheet.sc#L164"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2023/blob/main/2023-day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day5.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/kbielefe/advent-of-code/blob/71476c0b5509b9ae1c05a0b74665dba0c7f29dc2/2023/src/main/scala/5.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/kbielefe/"},"Karl Bielefeldt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/nryabykh/aoc2023/blob/master/src/main/scala/aoc2023/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/nryabykh"},"Nikolai Ryabih")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/advent-of-code/blob/main/2023/05/part2.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/"},"Raymond Dodge")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/RemcoSchrijver/advent-of-code/blob/main/2023/src/day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/RemcoSchrijver"},"Remco Schrijver")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/blob/master/task05_scala3/src/main/scala/Task05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/marconilanna/advent-of-code/blob/master/2023/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/marconilanna"},"Marconi Lanna")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2023/blob/main/day05/fertilizer.sc"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2023/blob/main/src/main/scala/solutions/day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins"))),(0,r.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}u.isMDXComponent=!0}}]);