"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1022],{1032:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));n(6340);const l={},r="Day 13: Point of Incidence",o={unversionedId:"2023/puzzles/day13",id:"2023/puzzles/day13",title:"Day 13: Point of Incidence",description:"by @adpi2",source:"@site/target/mdoc/2023/puzzles/day13.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day13",permalink:"/scala-advent-of-code/2023/puzzles/day13",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day13.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 12: Hot Springs",permalink:"/scala-advent-of-code/2023/puzzles/day12"},next:{title:"Day 14: Parabolic Reflector Dish",permalink:"/scala-advent-of-code/2023/puzzles/day14"}},p={},s=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Parsing of the input",id:"parsing-of-the-input",level:2},{value:"Part 1: detecting pure reflection",id:"part-1-detecting-pure-reflection",level:2},{value:"Part 2: detecting the reflection with a unique smudge",id:"part-2-detecting-the-reflection-with-a-unique-smudge",level:2},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],u={toc:s};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-13-point-of-incidence"},"Day 13: Point of Incidence"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/adpi2"},"@adpi2")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/13"},"https://adventofcode.com/2023/day/13")),(0,i.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Convert the input to a sequence of patterns."),(0,i.kt)("li",{parentName:"ul"},"Iterate over each pattern to detect its reflection. If there is no reflection on a pattern we try to find it in the transposition of the pattern."),(0,i.kt)("li",{parentName:"ul"},"Sum up all the reflection numbers.")),(0,i.kt)("h2",{id:"parsing-of-the-input"},"Parsing of the input"),(0,i.kt)("p",null,"We defines the model of the problem using type aliases:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Tile = '.' | '#'\ntype Line = Seq[Tile]\ntype Pattern = Seq[Line]\n")),(0,i.kt)("p",null,"To parse the input we split the full input by empty lines, (expressed with the regex ",(0,i.kt)("inlineCode",{parentName:"p"},"\\R\\R"),", which works multiplatform).\nThis gives a sequence of strings representing the patterns. Then split each pattern by a new line (regex ",(0,i.kt)("inlineCode",{parentName:"p"},"\\R"),"). Then for\neach line we assert that all the characters are valid tiles."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parseInput(input: String): Seq[Pattern] =\n  val patterns = input.split(raw"\\R\\R").toSeq\n  patterns.map: patternStr =>\n    patternStr.split(raw"\\R").toSeq.map: lineStr =>\n      lineStr.collect[Tile] { case tile: Tile => tile }\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"In Scala we tend to prefer a declarative style. An alternative imperative option would be to iterate over each line,\naccumulating lines into a buffer as we encounter them, and then at each empty line transfer all the accumulated lines as a group to a separate pattern buffer.")),(0,i.kt)("h2",{id:"part-1-detecting-pure-reflection"},"Part 1: detecting pure reflection"),(0,i.kt)("p",null,"To detect the reflection line in a pattern:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We iterate over the index of the lines from 1 to the size of the pattern"),(0,i.kt)("li",{parentName:"ul"},"We split the patterns in two at the given index"),(0,i.kt)("li",{parentName:"ul"},"We invert the first part, zip it with the second part and compare line by line.")),(0,i.kt)("p",null,"The resulting code is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def findReflection(pattern: Pattern): Option[Int] =\n  (1 until pattern.size).find: i =>\n    val (leftPart, rightPart) = pattern.splitAt(i)\n    leftPart.reverse.zip(rightPart).forall(_ == _)\n")),(0,i.kt)("p",null,"If we cannot find a line of reflection, then we transpose the pattern and try to find a column of reflection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"findReflection(pattern).map(100 * _).orElse(findReflection(pattern.transpose))\n")),(0,i.kt)("h2",{id:"part-2-detecting-the-reflection-with-a-unique-smudge"},"Part 2: detecting the reflection with a unique smudge"),(0,i.kt)("p",null,"The second part is almost identical to the first part. But, instead of comparing the lines based on equality, we count the number of different characters. We keep the index of the line or column which contains only a single smudge."),(0,i.kt)("p",null,"The inner part of ",(0,i.kt)("inlineCode",{parentName:"p"},"findReflection")," becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val (leftPart, rightPart) = pattern.splitAt(i)\nval smudges = leftPart.reverse\n  .zip(rightPart)\n  .map((l1, l2) => l1.zip(l2).count(_ != _))\n  .sum\nsmudges == 1\n")),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Tile = '.' | '#'\ntype Line = Seq[Tile]\ntype Pattern = Seq[Line]\n\ndef part1(input: String): Int =\n  parseInput(input)\n    .flatMap: pattern =>\n      findReflection(pattern).map(100 * _).orElse(findReflection(pattern.transpose))\n    .sum\n\ndef part2(input: String) =\n  parseInput(input)\n    .flatMap: pattern =>\n      findReflectionWithSmudge(pattern).map(100 * _)\n        .orElse(findReflectionWithSmudge(pattern.transpose))\n    .sum\n\ndef parseInput(input: String): Seq[Pattern] =\n  val patterns = input.split(raw\"\\R\\R\").toSeq\n  patterns.map: patternStr =>\n    patternStr.split(raw\"\\R\").toSeq.map: lineStr =>\n      lineStr.collect[Tile] { case tile: Tile => tile }\n\ndef findReflection(pattern: Pattern): Option[Int] =\n  (1 until pattern.size).find: i =>\n    val (leftPart, rightPart) = pattern.splitAt(i)\n    leftPart.reverse.zip(rightPart).forall(_ == _)\n\ndef findReflectionWithSmudge(pattern: Pattern): Option[Int] =\n  (1 until pattern.size).find: i =>\n    val (leftPart, rightPart) = pattern.splitAt(i)\n    val smudges = leftPart.reverse\n      .zip(rightPart)\n      .map((l1, l2) => l1.zip(l2).count(_ != _))\n      .sum\n    smudges == 1\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/13.worksheet.sc#L156"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day13.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2023/blob/main/day13/point-of-incidence.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2023/blob/main/src/main/scala/Day13.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/"},"merlin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/master/task13/src/main/scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2023/blob/main/2023-day13.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page."))}c.isMDXComponent=!0}}]);