"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1220],{5961:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>d,toc:()=>o});var t=a(7462),i=(a(7294),a(3905));a(6340);const r={},l="Day 7: Camel Cards",d={unversionedId:"2023/puzzles/day07",id:"2023/puzzles/day07",title:"Day 7: Camel Cards",description:"Puzzle description",source:"@site/target/mdoc/2023/puzzles/day07.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day07",permalink:"/scala-advent-of-code/2023/puzzles/day07",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day07.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 6: Wait For It",permalink:"/scala-advent-of-code/2023/puzzles/day06"},next:{title:"Day 1: Calorie Counting",permalink:"/scala-advent-of-code/2022/puzzles/day01"}},s={},o=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Part 1 Solution",id:"part-1-solution",level:2},{value:"Domain",id:"domain",level:3},{value:"Comparison",id:"comparison",level:3},{value:"Calculating the winnings",id:"calculating-the-winnings",level:3},{value:"Part 2 Solution",id:"part-2-solution",level:2},{value:"Rules",id:"rules",level:3},{value:"Comparison",id:"comparison-1",level:3},{value:"Calculating the winnings",id:"calculating-the-winnings-1",level:3},{value:"Complete Code",id:"complete-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:o};function p(e){let{components:n,...a}=e;return(0,i.kt)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-7-camel-cards"},"Day 7: Camel Cards"),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/7"},"https://adventofcode.com/2023/day/7")),(0,i.kt)("p",null,"The problem, in its essence, is a simplified version of the classic poker problem where you are required to compare poker hands according to certain rules."),(0,i.kt)("h2",{id:"part-1-solution"},"Part 1 Solution"),(0,i.kt)("p",null,"The problem, in its essence, is a simplified version of the classic poker problem where you are required to compare poker hands according to certain rules."),(0,i.kt)("h3",{id:"domain"},"Domain"),(0,i.kt)("p",null,"We'll start by defining the domain of the problem:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Card = Char\ntype Hand = String\ncase class Bet(hand: Hand, bid: Int)\nenum HandType:\n  case HighCard, OnePair, TwoPair, ThreeOfAKind, FullHouse, FourOfAKind, FiveOfAKind\n")),(0,i.kt)("p",null,"We can then define the constructors to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Bid")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"HandType"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Bet:\n  def apply(s: String): Bet = Bet(s.take(5), s.drop(6).toInt)\n\nobject HandType:\n  def apply(hand: Hand): HandType =\n    val cardCounts: List[Int] =\n      hand.groupBy(identity).values.toList.map(_.length).sorted.reverse\n\n    cardGroups match\n      case 5 :: _ => HandType.FiveOfAKind\n      case 4 :: _ => HandType.FourOfAKind\n      case 3 :: 2 :: Nil => HandType.FullHouse\n      case 3 :: _ => HandType.ThreeOfAKind\n      case 2 :: 2 :: _ => HandType.TwoPair\n      case 2 :: _ => HandType.OnePair\n      case _ => HandType.HighCard\n  end apply\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Bet")," is created from a ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," of a format ",(0,i.kt)("inlineCode",{parentName:"p"},"5678A 364")," - that is, the hand and the bid amount."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"HandType")," is a bit more complicated: it is calculated from ",(0,i.kt)("inlineCode",{parentName:"p"},"Hand")," - a string of a format ",(0,i.kt)("inlineCode",{parentName:"p"},"5678A")," - according to the rules specified in the challenge. Since the essence of hand scoring lies in how many occurrences of a given card there are in the hand, we utilize Scala's declarative collection capabilities to group the cards and calculate their occurrences. We can then use a ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," expression to look for the occurrences patterns as specified in the challenge, in descending order of value."),(0,i.kt)("h3",{id:"comparison"},"Comparison"),(0,i.kt)("p",null,"The objective of the challenge is to sort bids and calculate the final winnings. Let's address the sorting part. Scala collections are good enough at sorting, so we don't need to implement the sorting proper. But for Scala to do its job, it needs to know the ordering function of the elements. We need to define how to compare bids one to another:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val ranks = "23456789TJQKA"\ngiven cardOrdering: Ordering[Card] = Ordering.by(ranks.indexOf(_))\ngiven handOrdering: Ordering[Hand] = (h1: Hand, h2: Hand) =>\n  val h1Type = HandType(h1)\n  val h2Type = HandType(h2)\n  if h1Type != h2Type then h1Type.ordinal - h2Type.ordinal\n  else h1.zip(h2).find(_ != _).map( (c1, c2) => cardOrdering.compare(c1, c2) ).getOrElse(0)\ngiven betOrdering: Ordering[Bet] = Ordering.by(_.hand)\n')),(0,i.kt)("p",null,"We define three orderings: one for cards, one for hands, and one for bets."),(0,i.kt)("p",null,"The card ordering is simple: we compare the cards according to their rank. The hand ordering is implemented according to the spec of the challenge: we first compare the hand types, and if they are equal, we compare the individual cards of the hands."),(0,i.kt)("p",null,"The bet ordering is then defined in terms of hand ordering."),(0,i.kt)("h3",{id:"calculating-the-winnings"},"Calculating the winnings"),(0,i.kt)("p",null,"Given the work we've done so far, calculating the winnings is a matter of sorting the bids and calculating the winnings for each bid:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def calculateWinnings(bets: List[Bet]): Int =\n  bets.sorted.zipWithIndex.map { case (bet, index) => bet.bid * (index + 1) }.sum\n\ndef readInputFromFile(fileName: String): List[Bet] =\n  val bufferedSource = io.Source.fromFile(fileName)\n  val bids = bufferedSource.getLines.toList.map(Bet(_))\n  bufferedSource.close\n  bids\n\n@main def main =\n  val bids = readInputFromFile("poker.txt")\n  println(calculateWinnings(bids))\n')),(0,i.kt)("p",null,"We read the bids from the input file, sort them, and calculate the winnings for each bid. The result is then printed to the console."),(0,i.kt)("h2",{id:"part-2-solution"},"Part 2 Solution"),(0,i.kt)("p",null,"The second part of the challenge changes the meaning of the ",(0,i.kt)("inlineCode",{parentName:"p"},"J")," card. Now it's a Joker, which can be used as any card to produce the best hand possible. In practice, it means determining the prevailing card of the hand and becoming that card: such is the winning strategy of using the Joker. Another change in the rules is that now ",(0,i.kt)("inlineCode",{parentName:"p"},"J")," is the weakest card when used in tiebreaking comparisons."),(0,i.kt)("p",null,"We can re-use most of the logic of the Part 1 solution. To do so, we need to do two things: abstract the rules into a separate entity and change the hand scoring logic to take the rules into account."),(0,i.kt)("h3",{id:"rules"},"Rules"),(0,i.kt)("p",null,"We define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Rules")," trait that encapsulates the rules of the game and implement it for both cases:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'trait Rules:\n  val rankValues: String\n  val wildcard: Option[Card]\n\nval standardRules = new Rules:\n  val rankValues = "23456789TJQKA"\n  val wildcard = None\n\nval jokerRules = new Rules:\n  val rankValues = "J23456789TQKA"\n  val wildcard = Some(\'J\')\n')),(0,i.kt)("h3",{id:"comparison-1"},"Comparison"),(0,i.kt)("p",null,"We then need to change the hand type estimation logic to take the rules into account:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object HandType:\n  def apply(hand: Hand)(using rules: Rules): HandType =\n    val cardCounts: Map[Card, Int] =\n      hand.groupBy(identity).mapValues(_.length).toMap\n\n    val cardGroups: List[Int] = rules.wildcard match\n      case Some(card) if cardCounts.keySet.contains(card) =>\n        val wildcardCount = cardCounts(card)\n        val cardGroupsNoWildcard = cardCounts.removed(card).values.toList.sorted.reverse\n        cardGroupsNoWildcard match\n          case Nil => List(wildcardCount)\n          case _ => cardGroupsNoWildcard.head + wildcardCount :: cardGroupsNoWildcard.tail\n      case _ => cardCounts.values.toList.sorted.reverse\n\n    cardGroups match\n      case 5 :: _ => HandType.FiveOfAKind\n      case 4 :: _ => HandType.FourOfAKind\n      case 3 :: 2 :: Nil => HandType.FullHouse\n      case 3 :: _ => HandType.ThreeOfAKind\n      case 2 :: 2 :: _ => HandType.TwoPair\n      case 2 :: _ => HandType.OnePair\n      case _ => HandType.HighCard\n  end apply\nend HandType\n")),(0,i.kt)("p",null,"The logic is the same as in the Part 1 solution, except that now we need to take the wildcard into account. If the wildcard is present in the hand, we need to calculate the hand type as if the wildcard was not present, and then add the wildcard count to the largest group of cards. If the wildcard is not present, we calculate the hand type as before. We also handle the case when the hand is composed entirely of wildcards."),(0,i.kt)("p",null,"We then need to change the card comparison logic to also depend on the rules:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"given cardOrdering(using rules: Rules): Ordering[Card] = Ordering.by(rules.rankValues.indexOf(_))\n")),(0,i.kt)("p",null,"The rest of the orderings stay the same, except we need to make them also depend on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Rules")," as they all use ",(0,i.kt)("inlineCode",{parentName:"p"},"cardOrdering")," in some way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"given handOrdering(using Rules): Ordering[Hand] = (h1: Hand, h2: Hand) =>\n  val h1Type = HandType(h1)\n  val h2Type = HandType(h2)\n  if h1Type != h2Type then h1Type.ordinal - h2Type.ordinal\n  else h1.zip(h2).find(_ != _).map( (c1, c2) => cardOrdering.compare(c1, c2) ).getOrElse(0)\ngiven betOrdering(using Rules): Ordering[Bet] = Ordering.by(_.hand)\n")),(0,i.kt)("h3",{id:"calculating-the-winnings-1"},"Calculating the winnings"),(0,i.kt)("p",null,"Finally, we can calculate the winnings as before while specifying the rules under which to do the calculation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'@main def part2 =\n  val bids = readInputFromFile("poker.txt")\n  println(calculateWinnings(bids)(using jokerRules))\n')),(0,i.kt)("h2",{id:"complete-code"},"Complete Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'//> using scala "3.3.1"\n\ntype Card = Char\ntype Hand = String\n\ncase class Bet(hand: Hand, bid: Int)\nobject Bet:\n  def apply(s: String): Bet = Bet(s.take(5), s.drop(6).toInt)\n\nenum HandType:\n  case HighCard, OnePair, TwoPair, ThreeOfAKind, FullHouse, FourOfAKind, FiveOfAKind\nobject HandType:\n  def apply(hand: Hand)(using rules: Rules): HandType =\n    val cardCounts: Map[Card, Int] =\n      hand.groupBy(identity).mapValues(_.length).toMap\n\n    val cardGroups: List[Int] = rules.wildcard match\n      case Some(card) if cardCounts.keySet.contains(card) =>\n        val wildcardCount = cardCounts(card)\n        val cardGroupsNoWildcard = cardCounts.removed(card).values.toList.sorted.reverse\n        cardGroupsNoWildcard match\n          case Nil => List(wildcardCount)\n          case _ => cardGroupsNoWildcard.head + wildcardCount :: cardGroupsNoWildcard.tail\n      case _ => cardCounts.values.toList.sorted.reverse\n\n    cardGroups match\n      case 5 :: _ => HandType.FiveOfAKind\n      case 4 :: _ => HandType.FourOfAKind\n      case 3 :: 2 :: Nil => HandType.FullHouse\n      case 3 :: _ => HandType.ThreeOfAKind\n      case 2 :: 2 :: _ => HandType.TwoPair\n      case 2 :: _ => HandType.OnePair\n      case _ => HandType.HighCard\n  end apply\nend HandType\n\ntrait Rules:\n  val rankValues: String\n  val wildcard: Option[Card]\n\nval standardRules = new Rules:\n  val rankValues = "23456789TJQKA"\n  val wildcard = None\n\nval jokerRules = new Rules:\n  val rankValues = "J23456789TQKA"\n  val wildcard = Some(\'J\')\n\n\ngiven cardOrdering(using rules: Rules): Ordering[Card] = Ordering.by(rules.rankValues.indexOf(_))\ngiven handOrdering(using Rules): Ordering[Hand] = (h1: Hand, h2: Hand) =>\n  val h1Type = HandType(h1)\n  val h2Type = HandType(h2)\n  if h1Type != h2Type then h1Type.ordinal - h2Type.ordinal\n  else h1.zip(h2).find(_ != _).map( (c1, c2) => cardOrdering.compare(c1, c2) ).getOrElse(0)\ngiven betOrdering(using Rules): Ordering[Bet] = Ordering.by(_.hand)\n\ndef calculateWinnings(bets: List[Bet])(using Rules): Int =\n  bets.sorted.zipWithIndex.map { case (bet, index) => bet.bid * (index + 1) }.sum\n\ndef parse(input: String): List[Bet] =\n  input.linesIterator.toList.map(Bet(_))\n\ndef part1(input: String) =\n  val bids = parse(input)\n  println(calculateWinnings(bids)(using standardRules))\n\ndef part2(input: String) =\n  val bids = parse(input)\n  println(calculateWinnings(bids)(using jokerRules))\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/07.worksheet.sc#L132"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2023/blob/main/src/main/scala/solutions/day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh/aoc-2023/blob/main/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/lenguyenthanh"},"Thanh Le")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2023/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}p.isMDXComponent=!0}}]);