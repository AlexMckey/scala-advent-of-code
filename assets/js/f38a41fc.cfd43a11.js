"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3116],{1885:(e,t,n)=>{n.d(t,{Z:()=>a});var i=n(7294);const a=e=>{let{children:t}=e;const n=()=>i.Children.map(t,(e=>{const t=void 0===e.props.className?"literate-coding":`${e.props.className} literate-coding`;return i.cloneElement(e,{className:t})}));return i.createElement(n,null)}},7169:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>k,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905)),r=(n(6340),n(1885));const o={},s="Day 22: Sand Slabs",l={unversionedId:"2023/puzzles/day22",id:"2023/puzzles/day22",title:"Day 22: Sand Slabs",description:"by Pawe\u0142 Cembaluk",source:"@site/target/mdoc/2023/puzzles/day22.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day22",permalink:"/scala-advent-of-code/2023/puzzles/day22",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day22.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 21: Step Counter",permalink:"/scala-advent-of-code/2023/puzzles/day21"},next:{title:"Day 23: A Long Walk",permalink:"/scala-advent-of-code/2023/puzzles/day23"}},c={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Model",id:"model",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Parsing the input",id:"parsing-the-input",level:3},{value:"Brick methods",id:"brick-methods",level:3},{value:"Dropping groups of bricks",id:"dropping-groups-of-bricks",level:3},{value:"Determining the disintegrable bricks",id:"determining-the-disintegrable-bricks",level:3},{value:"Part 2",id:"part-2",level:2},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:p};function k(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"day-22-sand-slabs"},"Day 22: Sand Slabs"),(0,a.kt)("p",null,"by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,a.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/22"},"https://adventofcode.com/2023/day/22")),(0,a.kt)("h2",{id:"model"},"Model"),(0,a.kt)("p",null,"Before delving into the solution, let's familiarize ourselves with the representation of bricks.. We have two case\nclasses: ",(0,a.kt)("inlineCode",{parentName:"p"},"Coordinate")," to denote a point in the three-dimensional space, and ",(0,a.kt)("inlineCode",{parentName:"p"},"Brick")," to define a brick with starting and\nending coordinates."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Coordinate(x: Int, y: Int, z: Int)\n\ncase class Brick(start: Coordinate, end: Coordinate)\n")),(0,a.kt)("h2",{id:"part-1"},"Part 1"),(0,a.kt)("h3",{id:"parsing-the-input"},"Parsing the input"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"parse")," method employs pattern matching and string interpolation to extract starting and ending coordinates from a\nmulti-line string representation of bricks. It iterates over each line, deconstructs it into coordinate values using\npattern matching, and constructs a sequence of ",(0,a.kt)("inlineCode",{parentName:"p"},"Brick")," objects with the parsed coordinates."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def parse(input: String): Seq[Brick] =\n  for\n    s\"$x1,$y1,$z1~$x2,$y2,$z2\" <- input.split('\\n')\n  yield\n    val start = Coordinate(x1.toInt, y1.toInt, z1.toInt)\n    val end = Coordinate(x2.toInt, y2.toInt, z2.toInt)\n    Brick(start, end)\n")),(0,a.kt)("h3",{id:"brick-methods"},"Brick methods"),(0,a.kt)("p",null,"There are two fundamental operations on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Brick"),"s that form the backbone of our solution: moving the brick down, and\ndetermining whether the brick collides with another one."),(0,a.kt)("p",null,"To facilitate the movement of bricks downward, the ",(0,a.kt)("inlineCode",{parentName:"p"},"moveDown")," method is employed. This operation involves adjusting the\n",(0,a.kt)("inlineCode",{parentName:"p"},"z")," value of the brick's coordinates."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"lazy val moveDown: Brick =\n  copy(\n    start = start.copy(z = start.z - 1),\n    end = end.copy(z = end.z - 1)\n  )\n")),(0,a.kt)("p",null,"Another vital operation involves determining whether two bricks collide with each other. 3D collision is analogous to\n1D collision, so let's start with that."),(0,a.kt)("p",null,"1D line segments on X axis collide with each other when:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"maxX >= otherMinX && otherMaxX >= minX\n")),(0,a.kt)("p",null,"We are not guaranteed the order of coordinates, so we have to determine min values and max values ourselves. Let's\nexpress it as a method on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Brick"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def xOverlaps(other: Brick) = {\n  val minX = start.x min end.x\n  val maxX = start.x max end.x\n  val otherMinX = other.start.x min other.end.x\n  val otherMaxX = other.start.x max other.end.x\n  maxX >= otherMinX && otherMaxX >= minX\n}\n")),(0,a.kt)("p",null,"To extend this to a 3D collision, we apply the same logic for the ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"z")," axes. To avoid code repetition, we\nintroduce an ",(0,a.kt)("inlineCode",{parentName:"p"},"axis: Coordinate => Int")," extractor that extracts a coordinate value from a ",(0,a.kt)("inlineCode",{parentName:"p"},"Brick"),". The updated method is\nas follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def axisOverlaps(other: Brick)(axis: Coordinate => Int) = {\n  val min = axis(start) min axis(end)\n  val max = axis(start) max axis(end)\n  val otherMin = axis(other.start) min axis(other.end)\n  val otherMax = axis(other.start) max axis(other.end)\n  max >= otherMin && otherMax >= min\n}\n")),(0,a.kt)("p",null,"Now, to determine a 3D collision, we create a method that uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"axisOverlaps")," defined above for each axis:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def collidesWith(other: Brick): Boolean =\n  axisOverlaps(other)(_.x) &&\n    axisOverlaps(other)(_.y) &&\n    axisOverlaps(other)(_.z)\n")),(0,a.kt)("h3",{id:"dropping-groups-of-bricks"},"Dropping groups of bricks"),(0,a.kt)("p",null,"As the input is a snapshot of falling bricks, we must first drop them all to a stationary position."),(0,a.kt)("p",null,"First, define a way to check if a brick has collided with the ground, determined with a simple check on the ",(0,a.kt)("inlineCode",{parentName:"p"},"z")," axis:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def collidesWithGround(brick: Brick): Boolean =\n  brick.start.z == 0 || brick.end.z == 0\n")),(0,a.kt)("p",null,"Next, since we will determine the collisions at this point, we'll create a ",(0,a.kt)("inlineCode",{parentName:"p"},"Map")," that will associate each brick with the bricks supporting it."),(0,a.kt)("p",null,"Let's define the ",(0,a.kt)("inlineCode",{parentName:"p"},"dropBricks")," function that can do this:"),(0,a.kt)(r.Z,{mdxType:"Literate"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"import scala.collection.mutable\n\ndef dropBricks(bricks: Seq[Brick]): Map[Brick, Set[Brick]] = {\n")),(0,a.kt)("p",null,"First, sort the bricks by the ",(0,a.kt)("inlineCode",{parentName:"p"},"z")," axis to handle the falling order. This is necessary because the input doesn't\nguarantee the order of the bricks:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  val bricksByZAsc = bricks.sortBy(brick => (brick.start.z) min (brick.end.z))\n")),(0,a.kt)("p",null,"Next, initialize the ",(0,a.kt)("inlineCode",{parentName:"p"},"Stack")," of bricks to drop and the ",(0,a.kt)("inlineCode",{parentName:"p"},"Map")," of already dropped ones:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  val remainingBricks = mutable.Stack.from(bricksByZAsc)\n  val droppedBricks = mutable.Map[Brick, Set[Brick]]()\n")),(0,a.kt)("p",null,"Then, loop over the remaining bricks with ",(0,a.kt)("inlineCode",{parentName:"p"},"while (remainingBricks.nonEmpty)"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  while (remainingBricks.nonEmpty) {\n")),(0,a.kt)("p",null,"On each iteration, simulate the fall of a single brick:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"    val brick = remainingBricks.pop()\n    val brickMovedDown = brick.moveDown\n")),(0,a.kt)("p",null,"First, determine if there are any colliding bricks from the currently known ",(0,a.kt)("inlineCode",{parentName:"p"},"droppedBricks"),". We can produce this as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Set"),", with contents determined using the previously defined ",(0,a.kt)("inlineCode",{parentName:"p"},"Brick#collidesWith")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"    val collidingBricks =\n      droppedBricks.keys.filter(brickMovedDown.collidesWith).toSet\n")),(0,a.kt)("p",null,'Now, determine whether the brick is stationary. "Stationary" means that it either collides with the ground or another\nbrick. If it is stationary, put it into the ',(0,a.kt)("inlineCode",{parentName:"p"},"droppedBricks")," along with the dropped bricks that collide with it. If not,\nput it back into the ",(0,a.kt)("inlineCode",{parentName:"p"},"remainingBricks")," to move it further down in the next step:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"    if (collidesWithGround(brickMovedDown) || collidingBricks.nonEmpty)\n      droppedBricks.put(brick, collidingBricks)\n    else\n      remainingBricks.push(brickMovedDown)\n  }\n")),(0,a.kt)("p",null,"After all the bricks finish falling, return the ",(0,a.kt)("inlineCode",{parentName:"p"},"droppedBricks")," by converting to an immutable ",(0,a.kt)("inlineCode",{parentName:"p"},"Map"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  droppedBricks.toMap\n}\n"))),(0,a.kt)("h3",{id:"determining-the-disintegrable-bricks"},"Determining the disintegrable bricks"),(0,a.kt)("p",null,"Now, let's get back to the core challenge. We want to figure out how many bricks we can safely disintegrate. A brick is\nconsidered disintegrable if it's not the sole support for another brick. Using our map that outlines which bricks\nsupport others, we can easily identify the opposite \u2013 bricks that we cannot disintegrate. All remaining bricks are safe\nfor disintegration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def getDisintegrableBricks(brickToSupportingBricks: Map[Brick, Set[Brick]]): Set[Brick] = {\n  val nonDisintegrableBricks = brickToSupportingBricks.values.collect {\n    case supporting if supporting.sizeIs == 1\n      supporting.head // the only brick that holds the brick above\n  }.toSet\n  brickToSupportingBricks.keySet diff nonDisintegrableBricks\n}\n")),(0,a.kt)("p",null,"Bringing it all together, we get the solution for ",(0,a.kt)("strong",{parentName:"p"},"Part 1"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part1(input: String): Int = {\n  val bricks = parse(input)\n  val brickToSupportingBricks = dropBricks(bricks)\n  val disintegrableBricks = getDisintegrableBricks(brickToSupportingBricks)\n  disintegrableBricks.size\n}\n")),(0,a.kt)("h2",{id:"part-2"},"Part 2"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Part 2")," builds upon the code from ",(0,a.kt)("strong",{parentName:"p"},"Part 1")," with the introduction of a new functionality: calculating the total\nnumber of bricks that will fall after the removal of a specific brick. To accomplish this, we'll define the\n",(0,a.kt)("inlineCode",{parentName:"p"},"countFallingChain")," function. We'll utilize ",(0,a.kt)("inlineCode",{parentName:"p"},"brickToSupportingBricks")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"brick")," as function arguments."),(0,a.kt)(r.Z,{mdxType:"Literate"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def countFallingChain(brickToSupportingBricks: Map[Brick, Set[Brick]])(brick: Brick): Int = {\n")),(0,a.kt)("p",null,"Initially, we set up the collection of ",(0,a.kt)("inlineCode",{parentName:"p"},"disintegratedBricks"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"remainingBricks")," to check, and a flag to determine the\ncompletion of the chain reaction:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  val disintegratedBricks = mutable.Set[Brick](brick)\n  var remainingBricks = brickToSupportingBricks.removed(brick)\n  var isChainReactionFinished = false\n")),(0,a.kt)("p",null,"Next, loop while the chain reaction is not finished"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  while (!isChainReactionFinished) {\n")),(0,a.kt)("p",null,"In each iteration of the loop, we identify the bricks that have fallen (considered disintegrated) and those that remain untouched:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"    val (newDisintegratedBricks, newRemainingBricks) = remainingBricks\n      .partition { (_, supportingBricks) =>\n        supportingBricks.nonEmpty && supportingBricks.subsetOf(disintegratedBricks)\n      }\n")),(0,a.kt)("p",null,"If no bricks have fallen, indicating the completion of the chain reaction, we conclude the process. Otherwise, we add\nall the fallen bricks to ",(0,a.kt)("inlineCode",{parentName:"p"},"disintegratedBricks")," and update ",(0,a.kt)("inlineCode",{parentName:"p"},"remainingBricks")," for further checking:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"    if (newDisintegratedBricks.isEmpty)\n      isChainReactionFinished = true\n    else\n      disintegratedBricks.addAll(newDisintegratedBricks.keySet)\n      remainingBricks = newRemainingBricks\n  }\n")),(0,a.kt)("p",null,"Finally, after the chain reaction is complete, we return the count of disintegrated bricks, excluding the initial one:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  disintegratedBricks.size - 1 // don't include the initial brick\n}\n"))),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"countFallingChain")," defined, we can utilize it to calculate the falling chain for each brick:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val fallingChainCounts = brickToSupportingBricks.keys.toList.map(\n  countFallingChain(brickToSupportingBricks)\n)\n")),(0,a.kt)("p",null,"It's important to highlight the use of ",(0,a.kt)("inlineCode",{parentName:"p"},".toList")," in this context. The ",(0,a.kt)("inlineCode",{parentName:"p"},"keys")," method returns an ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterable"),", which is\na ",(0,a.kt)("inlineCode",{parentName:"p"},"Set")," underneath. By converting it to a list, we ensure that each count is preserved independently. Without this\nconversion, if multiple bricks have the same falling chain count, some counts may be lost."),(0,a.kt)("p",null,"By combining these individual chain counts and summing them up, we arrive at the answer for ",(0,a.kt)("strong",{parentName:"p"},"Part 2"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part2(input: String): Int = {\n  val bricks = parse(input)\n  val brickToSupportingBricks = dropBricks(bricks)\n  val fallingChainCounts = brickToSupportingBricks.keys.toList.map(\n    countFallingChain(brickToSupportingBricks)\n  )\n  fallingChainCounts.sum\n}\n")),(0,a.kt)("h2",{id:"final-code"},"Final code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Coordinate(x: Int, y: Int, z: Int)\n\ncase class Brick(start: Coordinate, end: Coordinate) {\n\n  lazy val moveDown: Brick =\n    copy(\n      start = start.copy(z = start.z - 1),\n      end = end.copy(z = end.z - 1)\n    )\n\n  def collidesWith(other: Brick): Boolean =\n    axisOverlaps(other)(_.x) &&\n      axisOverlaps(other)(_.y) &&\n      axisOverlaps(other)(_.z)\n\n  private def axisOverlaps(other: Brick)(axis: Coordinate => Int) = {\n    val min = axis(start) min axis(end)\n    val max = axis(start) max axis(end)\n    val otherMin = axis(other.start) min axis(other.end)\n    val otherMax = axis(other.start) max axis(other.end)\n    max >= otherMin && otherMax >= min\n  }\n}\n\ndef parse(input: String): Seq[Brick] =\n  for s\"$x1,$y1,$z1~$x2,$y2,$z2\" <- input.split('\\n')\n    yield\n      val start = Coordinate(x1.toInt, y1.toInt, z1.toInt)\n      val end = Coordinate(x2.toInt, y2.toInt, z2.toInt)\n      Brick(start, end)\n\nimport scala.collection.mutable\n\ndef dropBricks(bricks: Seq[Brick]): Map[Brick, Set[Brick]] = {\n  val bricksByZAsc = bricks.sortBy(brick => (brick.start.z) min (brick.end.z))\n  val remainingBricks = mutable.Stack.from(bricksByZAsc)\n  val droppedBricks = mutable.Map[Brick, Set[Brick]]()\n\n  while (remainingBricks.nonEmpty) {\n    val brick = remainingBricks.pop()\n    val brickMovedDown = brick.moveDown\n    val collidingBricks =\n      droppedBricks.keys.filter(brickMovedDown.collidesWith).toSet\n    if (collidesWithGround(brickMovedDown) || collidingBricks.nonEmpty)\n      droppedBricks.put(brick, collidingBricks)\n    else\n      remainingBricks.push(brickMovedDown)\n  }\n\n  droppedBricks.toMap\n}\n\ndef collidesWithGround(brick: Brick): Boolean =\n  brick.start.z == 0 || brick.end.z == 0\n\ndef getDisintegrableBricks(brickToSupportingBricks: Map[Brick, Set[Brick]]): Set[Brick] = {\n  val nonDisintegrableBricks = brickToSupportingBricks.values.collect {\n    case supporting if supporting.sizeIs == 1 =>\n      supporting.head // the only brick that holds the brick above\n  }.toSet\n  brickToSupportingBricks.keySet diff nonDisintegrableBricks\n}\n\ndef part1(input: String): Int = {\n  val bricks = parse(input)\n  val brickToSupportingBricks = dropBricks(bricks)\n  val disintegrableBricks = getDisintegrableBricks(brickToSupportingBricks)\n  disintegrableBricks.size\n}\n\ndef countFallingChain(brickToSupportingBricks: Map[Brick, Set[Brick]])(brick: Brick): Int = {\n  val disintegratedBricks = mutable.Set[Brick](brick)\n  var remainingBricks = brickToSupportingBricks.removed(brick)\n  var isChainReactionFinished = false\n\n  while (!isChainReactionFinished) {\n    val (newDisintegratedBricks, newRemainingBricks) = remainingBricks\n      .partition { (_, supportingBricks) =>\n        supportingBricks.nonEmpty && supportingBricks.subsetOf(\n          disintegratedBricks\n        )\n      }\n    if (newDisintegratedBricks.isEmpty)\n      isChainReactionFinished = true\n    else\n      disintegratedBricks.addAll(newDisintegratedBricks.keySet)\n      remainingBricks = newRemainingBricks\n  }\n\n  disintegratedBricks.size - 1 // don't include the initial brick\n}\n\ndef part2(input: String): Int = {\n  val bricks = parse(input)\n  val brickToSupportingBricks = dropBricks(bricks)\n  val fallingChainCounts = brickToSupportingBricks.keys.toList.map(\n    countFallingChain(brickToSupportingBricks)\n  )\n  fallingChainCounts.sum\n}\n")),(0,a.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day22.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/advent-of-code/blob/main/2023/22/day22.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/"},"Raymond Dodge"))),(0,a.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}k.isMDXComponent=!0}}]);