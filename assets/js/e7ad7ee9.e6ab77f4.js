"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3360],{6640:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>r});var a=n(7462),o=(n(7294),n(3905));n(6340);const i={},s="Day 18: Boiling Boulders",l={unversionedId:"2022/puzzles/day18",id:"2022/puzzles/day18",title:"Day 18: Boiling Boulders",description:"Puzzle description",source:"@site/target/mdoc/2022/puzzles/day18.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day18",permalink:"/scala-advent-of-code/2022/puzzles/day18",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day18.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 17: Pyroclastic Flow",permalink:"/scala-advent-of-code/2022/puzzles/day17"},next:{title:"Day 19: Not Enough Minerals",permalink:"/scala-advent-of-code/2022/puzzles/day19"}},c={},r=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:r};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-18-boiling-boulders"},"Day 18: Boiling Boulders"),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/18"},"https://adventofcode.com/2022/day/18")),(0,o.kt)("h2",{id:"solution"},"Solution"),(0,o.kt)("h3",{id:"part-1"},"Part 1"),(0,o.kt)("p",null,"To solve the first part, we can first count the total number of cubes and multiply this by six (as a cube has six sides), and then subtract the number of sides which are connected. "),(0,o.kt)("p",null,"As this requires checking if two cubes are adjacent, let's first define a function which we can use to determine cubes adjacent to a given cube:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def adjacent(x: Int, y: Int, z: Int): Set[(Int, Int, Int)] = {\n  Set(\n    (x + 1, y, z),\n    (x - 1, y, z),\n    (x, y + 1, z),\n    (x, y - 1, z),\n    (x, y, z + 1),\n    (x, y, z - 1)\n  )\n}\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Note that since cubes are given to be 1\u2a091\u2a091, they can be represented as a single integral ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y, z)")," coordinate which makes up the input for the ",(0,o.kt)("inlineCode",{parentName:"p"},"adjacent")," function.  Then two cubes are adjacent (one of each of their sides touch) if and only if exactly one of their ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y, z)")," components differ by one, and the rest by zero.")),(0,o.kt)("p",null,"Now given our cubes, we can implement our strategy with a ",(0,o.kt)("inlineCode",{parentName:"p"},"fold"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def sides(cubes: Set[(Int, Int, Int)]): Int = {\n  cubes.foldLeft(0) { case (total, (x, y, z)) =>\n    val adj = adjacent(x, y, z)\n    val numAdjacent = adj.filter(cubes).size\n    total + 6 - numAdjacent\n  }\n}\n")),(0,o.kt)("p",null,"We use a ",(0,o.kt)("inlineCode",{parentName:"p"},"Set")," for fast ",(0,o.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/overviews/collections-2.13/performance-characteristics.html"},"fast")," membership lookups which we need to determine which adjacent spaces for a given cube contain other cubes."),(0,o.kt)("h3",{id:"part-2"},"Part 2"),(0,o.kt)("p",null,"The second part is a bit more tricky.  Lets introduce some nomenclature: we'll say a 1\u2a091\u2a091 empty space is on the ",(0,o.kt)("em",{parentName:"p"},"interior")," if it lies in an air pocket, else we'll say the space is on the ",(0,o.kt)("em",{parentName:"p"},"exterior"),"."),(0,o.kt)("p",null,"A useful observation is that if we consider empty spaces which have a ",(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/18"},"taxicab")," distance of at most two from any cube, and join these spaces into ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Component_(graph_theory)"},"connected components"),", then the connected components we are left with form distinct air pockets in addition to one component containing empty spaces on the exterior."),(0,o.kt)("p",null,"This component can always be identified since the space with the largest ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," component will always lie in it.  So we can determine empty spaces in the interior adjacent to cubes like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def interior(cubes: Set[(Int, Int, Int)]): Set[(Int, Int, Int)] = {\n  val allAdj = cubes.flatMap((x, y, z) => adjacent(x, y, z).filterNot(cubes))\n  val sts = allAdj.map { case adj @ (x, y, z) =>\n    adjacent(x, y, z).filterNot(cubes) + adj\n  }\n  def cc(sts: List[Set[(Int, Int, Int)]]): List[Set[(Int, Int, Int)]] = {\n    sts match {\n      case Nil => Nil\n      case set :: rst =>\n        val (matching, other) = rst.partition(s => s.intersect(set).nonEmpty)\n        val joined = matching.foldLeft(set)(_ ++ _)\n        if (matching.nonEmpty) cc(joined :: other) else joined :: cc(other)\n    }\n  }\n  val conn = cc(sts.toList)\n  val exterior = conn.maxBy(_.maxBy(_(0)))\n  conn.filterNot(_ == exterior).foldLeft(Set())(_ ++ _)\n}\n")),(0,o.kt)("p",null,"Where the nested function ",(0,o.kt)("inlineCode",{parentName:"p"},"cc")," is used to generate a list of connected components.  We can now slightly modify our ",(0,o.kt)("inlineCode",{parentName:"p"},"sides")," function to complete part two:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def sidesNoPockets(cubes: Set[(Int, Int, Int)]): Int = {\n  val int = interior(cubes)\n  val allAdj = cubes.flatMap(adjacent)\n  allAdj.foldLeft(sides(cubes)) { case (total, (x, y, z)) =>\n    val adj = adjacent(x, y, z)\n    if (int((x, y, z))) total - adj.filter(cubes).size else total\n  }\n}\n")),(0,o.kt)("p",null,"Let's put this all together:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String): Int = sides(cubes(input))\ndef part2(input: String): Int = sidesNoPockets(cubes(input))\n\ndef cubes(input: String): Set[(Int, Int, Int)] =\n  val cubesIt = input.linesIterator.collect {\n    case s"$x,$y,$z" => (x.toInt, y.toInt, z.toInt)\n  }\n  cubesIt.toSet\n')),(0,o.kt)("p",null,"Which gives use our desired results."),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}p.isMDXComponent=!0}}]);