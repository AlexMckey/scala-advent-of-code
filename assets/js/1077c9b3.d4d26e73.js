"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2],{6261:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return h},default:function(){return u}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),l=n(5623),s=["components"],r={},c="Day 9: Smoke Basin",p={unversionedId:"puzzles/day9",id:"puzzles/day9",isDocsHomePage:!1,title:"Day 9: Smoke Basin",description:"by @VincenzoBaz",source:"@site/target/mdoc/puzzles/day9.md",sourceDirName:"puzzles",slug:"/puzzles/day9",permalink:"/scala-advent-of-code/puzzles/day9",editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day9.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 8: Seven Segment Search",permalink:"/scala-advent-of-code/puzzles/day8"},next:{title:"Day 10: Syntax Scoring",permalink:"/scala-advent-of-code/puzzles/day10"}},h=[{value:"Puzzle description",id:"puzzle-description",children:[],level:2},{value:"Solution of Part 2",id:"solution-of-part-2",children:[],level:2},{value:"Run it locally",id:"run-it-locally",children:[],level:2},{value:"Solutions from the community",id:"solutions-from-the-community",children:[],level:2}],d={toc:h};function u(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-9-smoke-basin"},"Day 9: Smoke Basin"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/VincenzoBaz"},"@VincenzoBaz")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/9"},"https://adventofcode.com/2021/day/9")),(0,i.kt)("h1",{id:"solution-of-part-1"},"Solution of Part 1"),(0,i.kt)("p",null,"Part 1 requires us to find all low points of the grid, where a low point is a\ncell in the grid which contains a value smaller than the four adjacent values\n(up, down, left, right)."),(0,i.kt)("p",null,"I model the two dimensional grid containing height values using a case class\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"Heightmap"),". I provide it with a utility method which returns the list of\ncoordinates and height values of the cells adjacent to a given cell. The list\ncan have size 2, 3 or 4 depending whether the cell is on the edge of the grid or\nnot:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Height = Int\ncase class Position(x: Int, y: Int)\n\ncase class Heightmap(width: Int, height: Int, data: Vector[Vector[Height]]):\n\n  def apply(pos: Position): Height = data(pos.y)(pos.x)\n\n  def neighborsOf(pos: Position): List[(Position, Height)] =\n    val Position(x, y) = pos\n    List(\n      Option.when(x > 0)(Position(x - 1, y)),\n      Option.when(x < width - 1)(Position(x + 1, y)),\n      Option.when(y > 0)(Position(x, y - 1)),\n      Option.when(y < height - 1)(Position(x, y + 1))\n    ).flatMap(List.from)\n     .map(pos => pos -> apply(pos))\n")),(0,i.kt)("p",null,"Using this method I implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"lowPointsPositions")," method which iterates over\nall the cells in the grid and for each of them, it checks if the value in it is\nsmaller than the values of adjacent cells:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def lowPointsPositions: LazyList[Position] =\n    LazyList.range(0, height).flatMap { y =>\n      LazyList.range(0, width).map { x =>\n        val pos = Position(x, y)\n        (\n          apply(pos),\n          pos,\n          this.neighborsOf(pos).map(_._2)\n        )\n      }\n    }\n    .collect {\n      case (value, pos, neighbors) if neighbors.forall(value < _) =>\n        pos\n    }\n")),(0,i.kt)("p",null,"The method ",(0,i.kt)("inlineCode",{parentName:"p"},"forall")," on collections returns true only if the predicate it is\nprovided with holds true for all elements of the collection. It is similar to\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"exists")," methods which returns true if at least one element in the\ncollection satisfies the provided predicate.\nFinally, ",(0,i.kt)("inlineCode",{parentName:"p"},"collect")," allows us to simplify chains of ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"filter"),"."),(0,i.kt)("p",null,"You can find more information about these methods ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/Iterable.html"},"in the\ndocumentation")),(0,i.kt)("p",null,"We now have all the tools to solve part 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val heightMap = Heightmap.fromString(input)\n\n  heightMap.lowPointsPositions.map(heightMap(_) + 1).sum\nend part1\n")),(0,i.kt)(l.Z,{puzzle:"day9-part1",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solution-of-part-2"},"Solution of Part 2"),(0,i.kt)("p",null,"In part 2 we have to create, for each low point, a basin: a group of grid cells\nthat the smoke traverses while flowing downward towards the low point."),(0,i.kt)("p",null,"This is how we can solve part 2 after implementing the basin creation for a single low point:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  val lowPoints = heightMap.lowPointsPositions\n  val basins = lowPoints.map(basin(_, heightMap))\n\n  basins\n    .to(LazyList)\n    .map(_.size)\n    .sorted(Ordering[Int].reverse)\n    .take(3)\n    .product\n")),(0,i.kt)("p",null,"To build a basin from a low point I use a data structure provided in\nthe standard library:\n",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/Queue.html"},(0,i.kt)("inlineCode",{parentName:"a"},"Queue")),"\nwhich implements a first-in-first-out\n(",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Queue_(abstract_data_type)"},"FIFO"),") data\nstructure."),(0,i.kt)("p",null,"Starting from the low point, I retrieve the neighbors of a cell and check if\nthey should be part of the basin, in other words whether they contain the\ndigit ",(0,i.kt)("inlineCode",{parentName:"p"},"9"),". I also remember the coordinates of the cells I visited using a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),"\nwhich provides constant time ",(0,i.kt)("inlineCode",{parentName:"p"},"contains")," checks.  As the basin grows, the cells\nthat form it are stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"basinAcc")," accumulator.  As I continue to\nretrieve neighbors of neighbors, I add the cells that still need to be processed\nin the queue.\nThe algorithm stops when there are no more cells to visit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def basin(lowPoint: Position, heightMap: Heightmap): Set[Position] =\n  @scala.annotation.tailrec\n  def iter(visited: Set[Position], toVisit: Queue[Position], basinAcc: Set[Position]): Set[Position] =\n    // No cells to visit, we are done\n    if toVisit.isEmpty then basinAcc\n    else\n      // Select next cell to visit\n      val (currentPos, remaining) = toVisit.dequeue\n      // Collect the neighboring cells that should be part of the basin\n      val newNodes = heightMap.neighborsOf(currentPos).toList.collect {\n        case (pos, height) if !visited(currentPos) && height != 9 => pos\n      }\n      // Continue to next neighbor\n      iter(visited + currentPos, remaining ++ newNodes, basinAcc ++ newNodes)\n\n  iter(Set.empty, Queue(lowPoint), Set(lowPoint))\n")),(0,i.kt)(l.Z,{puzzle:"day9-part2",mdxType:"Solver"}),(0,i.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,i.kt)("p",null,"You can get this solution locally by cloning the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,i.kt)("p",null,"You can run it with ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ scala-cli src -M day9.part1\nThe solution is 448\n$ scala-cli src -M day9.part2\nThe solution is 1417248\n")),(0,i.kt)("p",null,"You can replace the content of the ",(0,i.kt)("inlineCode",{parentName:"p"},"input/day9")," file with your own input from ",(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/9"},"adventofcode.com")," to get your own solution."),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day09.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/tOverney/AdventOfCode2021/blob/main/src/main/scala/ch/overney/aoc/day9/"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/tOverney"},"@tOverney"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day09/Day09.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),".")),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page."))}u.isMDXComponent=!0}}]);