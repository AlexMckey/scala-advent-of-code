"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9185],{5123:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=t(7462),i=(t(7294),t(3905));t(6340);const s={},o="Day 15: Beacon Exclusion Zone",r={unversionedId:"2022/puzzles/day15",id:"2022/puzzles/day15",title:"Day 15: Beacon Exclusion Zone",description:"Puzzle description",source:"@site/target/mdoc/2022/puzzles/day15.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day15",permalink:"/scala-advent-of-code/2022/puzzles/day15",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day15.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 14: Regolith Reservoir",permalink:"/scala-advent-of-code/2022/puzzles/day14"},next:{title:"Day 16: Proboscidea Volcanium",permalink:"/scala-advent-of-code/2022/puzzles/day16"}},l={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Explanation",id:"explanation",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:c};function d(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-15-beacon-exclusion-zone"},"Day 15: Beacon Exclusion Zone"),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/15"},"https://adventofcode.com/2022/day/15")),(0,i.kt)("h2",{id:"explanation"},"Explanation"),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"We first model and parse the input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Position(x: Int, y: Int)\n\ndef parse(input: String): List[(Position, Position)] =\n  input.split("\\n").toList.map{\n    case s"Sensor at x=$sx, y=$sy: closest beacon is at x=$bx, y=$by" =>\n      (Position(sx.toInt, sy.toInt), Position(bx.toInt, by.toInt))\n  }\n')),(0,i.kt)("p",null,"We then model the problem-specific knowledge:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def distance(p1: Position, p2: Position): Int =\n  Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y)\n\ndef distanceToLine(p: Position, y: Int): Int =\n  Math.abs(p.y - y)\n")),(0,i.kt)("p",null,"We use it to compute how much of a line is covered by one (by ",(0,i.kt)("inlineCode",{parentName:"p"},"lineCoverage"),") and all (by ",(0,i.kt)("inlineCode",{parentName:"p"},"coverOfLine"),") sensors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def lineCoverage(sensor: Position, radius: Int, lineY: Int): Range =\n  val radiusInLine = radius - distanceToLine(sensor, lineY)\n\n  // if radiusInLine is smaller than 0, the range will be empty\n  (sensor.x - radiusInLine) to (sensor.x + radiusInLine)\n\ndef coverOfLine(sensorsWithDistances: List[(Position, Int)], line: Int) =\n  sensorsWithDistances.map( (sensor, radius) => lineCoverage(sensor, radius, line) ).filter(_.nonEmpty)\n")),(0,i.kt)("p",null,"This is enought to solve part one:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val parsed: List[(Position, Position)] = parse(input)\n  val beacons: Set[Position] = parsed.map(_._2).toSet\n  val sensorsWithDistances: List[(Position, Int)] =\n    parsed.map( (sensor, beacon) => (sensor, distance(sensor, beacon)) )\n\n  val line = 2000000\n  val cover: List[Range] = coverOfLine(sensorsWithDistances, line)\n  val beaconsOnLine: Set[Position] = beacons.filter(_.y == line)\n  val count: Int = cover.map(_.size).sum - beaconsOnLine.size\n  count\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"We wish to remove ranges from other ranges, sadly there is no built-in method to do so, instead rellying on a cast to a collection, which makes computation much much slower.\nTherefore we define our own difference method which returns zero, one or two ranges:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def smartDiff(r1: Range, r2: Range): List[Range] =\n  val innit = r1.start to Math.min(r2.start - 1, r1.last)\n  val tail = Math.max(r1.start, r2.last + 1) to r1.last\n  val res = if innit == tail then\n    List(innit)\n  else\n    List(innit, tail)\n  res.filter(_.nonEmpty).toList\n")),(0,i.kt)("p",null,"This allows us to subtract the cover from our target interval like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def remainingSpots(target: Range, cover: List[Range]): Set[Int] =\n\n  def rec(partialTarget: List[Range], remainingCover: List[Range]): List[Range] =\n    if remainingCover.isEmpty then\n      partialTarget\n    else\n      val (curr: Range) :: rest = remainingCover: @unchecked\n      rec(\n        partialTarget = partialTarget.flatMap( r => smartDiff(r, curr) ),\n        remainingCover = rest\n      )\n\n  rec(List(target), cover).flatten.toSet\n")),(0,i.kt)("p",null,"We can then iterate through all lines, and computing for each which positions are free. As per the problem statement, we know there will only be one inside the square of side ",(0,i.kt)("inlineCode",{parentName:"p"},"0 to 4_000_000"),". We then compute the solution's tuning frequency."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): Any =\n\n  val parsed: List[(Position, Position)] = parse(input)\n  val beacons: Set[Position] = parsed.map(_._2).toSet\n  val sensorsWithDistances: List[(Position, Int)] =\n    parsed.map( (sensor, beacon) => (sensor, distance(sensor, beacon)) )\n\n  val target: Range = 0 to 4_000_000\n  val spots: Seq[Position] = target.flatMap{\n    line =>\n      val cover: List[Range] = coverOfLine(sensorsWithDistances, line)\n      val beaconsOnLine: Set[Position] = beacons.filter(_.y == line)\n\n      val remainingRanges: List[Range] = cover.foldLeft(List(target)){\n        case (acc: List[Range], range: Range) =>\n          acc.flatMap( r => smartDiff(r, range) )\n      }\n      val potential = remainingRanges.flatten.toSet\n\n      val spotsOnLine = potential diff beaconsOnLine.map( b => b.x )\n      spotsOnLine.map( x => Position(x, line) )\n  }\n  def tuningFrequency(p: Position): BigInt = BigInt(p.x) * 4_000_000 + p.y\n\n  println(spots.mkString(", "))\n  assert(spots.size == 1)\n  tuningFrequency(spots.head)\n')),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Position(x: Int, y: Int)\n\ndef parse(input: String): List[(Position, Position)] =\n  input.split("\\n").toList.map{\n    case s"Sensor at x=$sx, y=$sy: closest beacon is at x=$bx, y=$by" =>\n      (Position(sx.toInt, sy.toInt), Position(bx.toInt, by.toInt))\n  }\n\ndef distance(p1: Position, p2: Position): Int =\n  Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y)\n\ndef distanceToLine(p: Position, y: Int): Int =\n  Math.abs(p.y - y)\n\ndef lineCoverage(sensor: Position, radius: Int, lineY: Int): Range =\n  val radiusInLine = radius - distanceToLine(sensor, lineY)\n\n  // if radiusInLine is smaller than 0, the range will be empty\n  (sensor.x - radiusInLine) to (sensor.x + radiusInLine)\n\ndef coverOfLine(sensorsWithDistances: List[(Position, Int)], line: Int) =\n  sensorsWithDistances.map( (sensor, radius) => lineCoverage(sensor, radius, line) ).filter(_.nonEmpty)\n\ndef smartDiff(r1: Range, r2: Range): List[Range] =\n  val innit = r1.start to Math.min(r2.start - 1, r1.last)\n  val tail = Math.max(r1.start, r2.last + 1) to r1.last\n  val res = if innit == tail then\n    List(innit)\n  else\n    List(innit, tail)\n  res.filter(_.nonEmpty).toList\n\ndef remainingSpots(target: Range, cover: List[Range]): Set[Int] =\n\n  def rec(partialTarget: List[Range], remainingCover: List[Range]): List[Range] =\n    if remainingCover.isEmpty then\n      partialTarget\n    else\n      val (curr: Range) :: rest = remainingCover: @unchecked\n      rec(\n        partialTarget = partialTarget.flatMap( r => smartDiff(r, curr) ),\n        remainingCover = rest\n      )\n\n  rec(List(target), cover).flatten.toSet\n\ndef part1(input: String): Int =\n  val parsed: List[(Position, Position)] = parse(input)\n  val beacons: Set[Position] = parsed.map(_._2).toSet\n  val sensorsWithDistances: List[(Position, Int)] =\n    parsed.map( (sensor, beacon) => (sensor, distance(sensor, beacon)) )\n\n  val line = 2000000\n  val cover: List[Range] = coverOfLine(sensorsWithDistances, line)\n  val beaconsOnLine: Set[Position] = beacons.filter(_.y == line)\n  val count: Int = cover.map(_.size).sum - beaconsOnLine.size\n  count\n\ndef part2(input: String): Any =\n\n  val parsed: List[(Position, Position)] = parse(input)\n  val beacons: Set[Position] = parsed.map(_._2).toSet\n  val sensorsWithDistances: List[(Position, Int)] =\n    parsed.map( (sensor, beacon) => (sensor, distance(sensor, beacon)) )\n\n  val target: Range = 0 to 4_000_000\n  val spots: Seq[Position] = target.flatMap{\n    line =>\n      val cover: List[Range] = coverOfLine(sensorsWithDistances, line)\n      val beaconsOnLine: Set[Position] = beacons.filter(_.y == line)\n\n      val remainingRanges: List[Range] = cover.foldLeft(List(target)){\n        case (acc: List[Range], range: Range) =>\n          acc.flatMap( r => smartDiff(r, range) )\n      }\n      val potential = remainingRanges.flatten.toSet\n\n      val spotsOnLine = potential diff beaconsOnLine.map( b => b.x )\n      spotsOnLine.map( x => Position(x, line) )\n  }\n  def tuningFrequency(p: Position): BigInt = BigInt(p.x) * 4_000_000 + p.y\n\n  println(spots.mkString(", "))\n  assert(spots.size == 1)\n  tuningFrequency(spots.head)\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day15.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day15.scala"},"Solution")," by Cosmin Ciobanu"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day15"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/w-r-z-k/aoc2022/blob/main/src/main/scala/Day15.scala"},"Solution")," by Richard W."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2022/tree/main/src/main/scala/rui/aoc/year2022/day15"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}d.isMDXComponent=!0}}]);