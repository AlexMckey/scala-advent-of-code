"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1866],{3197:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var r=a(7462),i=(a(7294),a(3905)),n=a(6340);const o={},l="Day 7: No Space Left On Device",c={unversionedId:"2022/puzzles/day07",id:"2022/puzzles/day07",title:"Day 7: No Space Left On Device",description:"code by Jan Boerman",source:"@site/target/mdoc/2022/puzzles/day07.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day07",permalink:"/scala-advent-of-code/2022/puzzles/day07",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day07.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 6: Tuning Trouble",permalink:"/scala-advent-of-code/2022/puzzles/day06"},next:{title:"Day 8: Treetop Tree House",permalink:"/scala-advent-of-code/2022/puzzles/day08"}},s={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],m={toc:u};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-7-no-space-left-on-device"},"Day 7: No Space Left On Device"),(0,i.kt)("p",null,"code by ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/JanBoerman95"},"Jan Boerman")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/7"},"https://adventofcode.com/2022/day/7")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"First of all, we need to create types for commands, to differentiate the input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum Command:\n  case ChangeDirectory(directory: String)\n  case ListFiles\n\nenum TerminalOutput:\n  case Cmd(cmd: Command)\n  case Directory(name: String)\n  case File(size: Int, name: String)\n")),(0,i.kt)("p",null,"Let's make a directory structure, in which we will define files as ",(0,i.kt)("a",{parentName:"p",href:"https://dotty.epfl.ch/api/scala/collection/mutable/Map.html"},(0,i.kt)("inlineCode",{parentName:"a"},"mutable.Map")),", that can contain name (String) and size (Integer), will have reference to parent directory, and will be able to contain subdirectories:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class DirectoryStructure(val name: String,\n                         val subDirectories: mutable.Map[String, DirectoryStructure],\n                         val files: mutable.Map[String, Int],\n                         val parent: DirectoryStructure | Null)\n")),(0,i.kt)("p",null,"And now we need to come up with a way to parse out input code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def input (str: String) = str.linesIterator.map {\n  case s"$$ cd $directory" => Cmd(ChangeDirectory(directory))\n  case s"$$ ls" => Cmd(ListFiles)\n  case s"dir $directory" => Directory(directory)\n  case s"$size $file" => File(size.toInt, file)\n}.toList\n')),(0,i.kt)("p",null,"We have to come up with a way to calculate directory size -- we can use ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/files/archive/api/current/scala/collection/immutable/List.html#sum%5BB%3E:A%5D(implicitnum:scala.math.Numeric%5BB%5D):B"},(0,i.kt)("inlineCode",{parentName:"a"},"sum"))," for the size of all files in directory and define size of all of the following subdirectories recursively, which will take care of problem:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def directorySize(dir: DirectoryStructure): Int =\n  dir.files.values.sum + dir.subDirectories.values.map(directorySize).sum\n")),(0,i.kt)("p",null,"Now we need to create a function to build the directory structure from the input. For that we can use ",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/tour/pattern-matching.html"},(0,i.kt)("inlineCode",{parentName:"a"},"match"))," and separate input, -- for that we can use cases and recursion will do the rest for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def buildState(input: List[TerminalOutput], currentDir: DirectoryStructure | Null, rootDir: DirectoryStructure): Unit = input match\n  case Cmd(ChangeDirectory("/")) :: t => buildState(t, rootDir, rootDir)\n  case Cmd(ChangeDirectory("..")) :: t => buildState(t, currentDir.parent, rootDir)\n  case Cmd(ChangeDirectory(name)) :: t => buildState(t, currentDir.subDirectories(name), rootDir)\n  case Cmd(ListFiles) :: t => buildState(t, currentDir, rootDir)\n  case File(size, name) :: t =>\n    currentDir.files.put(name, size)\n    buildState(t, currentDir, rootDir)\n  case Directory(name) :: t =>\n    currentDir.subDirectories.put(name, DirectoryStructure(name, mutable.Map.empty, mutable.Map.empty, currentDir))\n    buildState(t, currentDir, rootDir)\n  case Nil => ()\n')),(0,i.kt)("p",null,"And now, we need to assemble the program, in part one, we will search for all directories with size smaller ",(0,i.kt)("inlineCode",{parentName:"p"},"100000"),", and calculate the sum of their sizes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(output: String): Int =\n  val rootDir = buildData(output)\n  collectSizes(rootDir, _ < 100000).sum\n")),(0,i.kt)("p",null,"In part two, we are looking for the smallest directory, which size is big enough to free up enough space on the filesystem to install update (30,000,00). We have to find out how much space is required for update, considering our available unused space:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(output: String): Int =\n  val rootDir = buildData(output)\n  val totalUsed = directorySize(rootDir)\n  val totalUnused = 70_000_000 - totalUsed\n  val required = 30_000_000 - totalUnused\n  collectSizes(rootDir, _ >= required).min\n")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.annotation.tailrec\nimport scala.collection.mutable\n\nimport TerminalOutput.*\nimport Command.*\n\ndef input (str: String) = str.linesIterator.map {\n  case s"$$ cd $directory" => Cmd(ChangeDirectory(directory))\n  case s"$$ ls" => Cmd(ListFiles)\n  case s"dir $directory" => Directory(directory)\n  case s"$size $file" => File(size.toInt, file)\n}.toList\n\nenum Command:\n  case ChangeDirectory(directory: String)\n  case ListFiles\n\nenum TerminalOutput:\n  case Cmd(cmd: Command)\n  case Directory(name: String)\n  case File(size: Int, name: String)\n\nclass DirectoryStructure(val name: String,\n                         val subDirectories: mutable.Map[String, DirectoryStructure],\n                         val files: mutable.Map[String, Int],\n                         val parent: DirectoryStructure | Null)\n\ndef buildState(input: List[TerminalOutput], currentDir: DirectoryStructure | Null, rootDir: DirectoryStructure): Unit = input match\n  case Cmd(ChangeDirectory("/")) :: t => buildState(t, rootDir, rootDir)\n  case Cmd(ChangeDirectory("..")) :: t => buildState(t, currentDir.parent, rootDir)\n  case Cmd(ChangeDirectory(name)) :: t => buildState(t, currentDir.subDirectories(name), rootDir)\n  case Cmd(ListFiles) :: t => buildState(t, currentDir, rootDir)\n  case File(size, name) :: t =>\n    currentDir.files.put(name, size)\n    buildState(t, currentDir, rootDir)\n  case Directory(name) :: t =>\n    currentDir.subDirectories.put(name, DirectoryStructure(name, mutable.Map.empty, mutable.Map.empty, currentDir))\n    buildState(t, currentDir, rootDir)\n  case Nil => ()\n\ndef directorySize(dir: DirectoryStructure): Int =\n  dir.files.values.sum + dir.subDirectories.values.map(directorySize).sum\n\ndef collectSizes(dir: DirectoryStructure, criterion: Int => Boolean): Iterable[Int] =\n  val mySize = directorySize(dir)\n  val children = dir.subDirectories.values.flatMap(collectSizes(_, criterion))\n  if criterion(mySize) then mySize :: children.toList else children\n\ndef buildData(output: String) =\n  val rootDir = new DirectoryStructure("/", mutable.Map.empty, mutable.Map.empty, null)\n  buildState(input(output), null, rootDir)\n  rootDir\n\n\ndef part1(output: String): Int =\n  val rootDir = buildData(output)\n  collectSizes(rootDir, _ < 100000).sum\n\ndef part2(output: String): Int =\n  val rootDir = buildData(output)\n  val totalUsed = directorySize(rootDir)\n  val totalUnused = 70_000_000 - totalUsed\n  val required = 30_000_000 - totalUnused\n  collectSizes(rootDir, _ >= required).min\n')),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1"},"Part 1"),(0,i.kt)(n.Z,{puzzle:"day07-part1",year:"2022",mdxType:"Solver"}),(0,i.kt)("h4",{id:"part-2"},"Part 2"),(0,i.kt)(n.Z,{puzzle:"day07-part2",year:"2022",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SimY4/advent-of-code-scala/blob/master/src/main/scala/aoc/y2022/Day7.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/actinglikecrazy"},"SimY4"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2022/blob/master/src/main/scala/day07/Day07.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/stewSquared/advent-of-code/blob/master/src/main/scala/2022/Day07.worksheet.sc"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/stewSqrd"},"Stewart Stewart"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day7.scala"},"Solution")," by Cosmin Ciobanu"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/w-r-z-k/aoc2022/blob/main/src/main/scala/Day7.scala"},"Solution")," by Richard W"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau/code-advent-2022/blob/master/src/main/scala/com/adventofcode/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau"},"Daniel Naumau")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day7"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rpiotrow/advent-of-code-2022/tree/main/src/main/scala/io/github/rpiotrow/advent2022/day07"},"Solution using ZIO")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rpiotrow"},"Rafa\u0142 Piotrowski"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}d.isMDXComponent=!0}}]);