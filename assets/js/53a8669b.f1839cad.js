"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4404],{2959:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var a=t(7462),i=(t(7294),t(3905)),r=t(6340);const l={},o="Day 3: Gear Ratios",s={unversionedId:"2023/puzzles/day03",id:"2023/puzzles/day03",title:"Day 3: Gear Ratios",description:"by @bishabosha",source:"@site/target/mdoc/2023/puzzles/day03.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day03",permalink:"/scala-advent-of-code/2023/puzzles/day03",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day03.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 2: Cube Conundrum",permalink:"/scala-advent-of-code/2023/puzzles/day02"},next:{title:"Day 1: Calorie Counting",permalink:"/scala-advent-of-code/2022/puzzles/day01"}},m={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Framework",id:"framework",level:4},{value:"Surrounding Elements",id:"surrounding-elements",level:4},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:u};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-3-gear-ratios"},"Day 3: Gear Ratios"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/3"},"https://adventofcode.com/2023/day/3")),(0,i.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,i.kt)("p",null,"The solution models the input as a grid of numbers and symbols."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse the input into two separate sparse grids:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"numbers")," a 2d sparse grid, where each row consists of a sequence of (",(0,i.kt)("inlineCode",{parentName:"li"},"column"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"length"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"number"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"symbols")," a 2d sparse grid, where each row consists of a sequence of (",(0,i.kt)("inlineCode",{parentName:"li"},"column"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"length"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"char"),").")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"then summarise the whole grid as follows:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"part1"),", find all ",(0,i.kt)("inlineCode",{parentName:"li"},"numbers")," where there exists a ",(0,i.kt)("inlineCode",{parentName:"li"},"surrounding"),"\xb1 ",(0,i.kt)("inlineCode",{parentName:"li"},"symbol"),", and sum the total of the resulting ",(0,i.kt)("inlineCode",{parentName:"li"},"number")," values,"),(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"part2"),", find all ",(0,i.kt)("inlineCode",{parentName:"li"},"symbols")," where the ",(0,i.kt)("inlineCode",{parentName:"li"},"char")," value is (",(0,i.kt)("inlineCode",{parentName:"li"},"*"),"), and where there exists exactly 2 ",(0,i.kt)("inlineCode",{parentName:"li"},"surrounding"),"\xb1 ",(0,i.kt)("inlineCode",{parentName:"li"},"numbers"),", take the product of the two number values, and sum the resulting products."),(0,i.kt)("li",{parentName:"ul"},"\xb1",(0,i.kt)("inlineCode",{parentName:"li"},"surrounding")," above refers to drawing a bounding box on the grid that surrounds either a number or symbol ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," at 1 unit away (see manhattan distance), then collecting all numbers or symbols in that box (except ",(0,i.kt)("inlineCode",{parentName:"li"},"e"),").")),(0,i.kt)("h4",{id:"framework"},"Framework"),(0,i.kt)("p",null,"both ",(0,i.kt)("inlineCode",{parentName:"p"},"part1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"part2")," will use the following framework for the solution."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Grid(\n  numbers: IArray[IArray[Number]],\n  symbols: IArray[IArray[Symbol]]\n)\n\ntrait Element:\n  def x: Int\n  def length: Int\n\ncase class Symbol(x: Int, length: Int, charValue: Char) extends Element\ncase class Number(x: Int, length: Int, intValue: Int) extends Element\n\ndef solution(input: String, summarise: Grid => IterableOnce[Int]): Int =\n  summarise(parse(input)).sum\n\ndef parse(input: String): Grid = ??? // filled in by the final code\n")),(0,i.kt)("h4",{id:"surrounding-elements"},"Surrounding Elements"),(0,i.kt)("p",null,"To compute the surrounding elements of some ",(0,i.kt)("inlineCode",{parentName:"p"},"Symbol")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Number"),", define ",(0,i.kt)("inlineCode",{parentName:"p"},"surrounds")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def surrounds[E <: Element](y: Int, from: Element, rows: IArray[IArray[E]]): List[E] =\n  val (x0, y0, x1, y1) = (from.x - 1, y - 1, from.x + from.length, y + 1)\n  def overlaps(e: Element) = x0 <= (e.x + e.length - 1) && x1 >= e.x\n  def findUp =\n    if y0 < 0 then Nil\n    else rows(y0).filter(overlaps).toList\n  def findMiddle =\n    rows(y).filter(overlaps).toList\n  def findDown =\n    if y1 >= rows.size then Nil\n    else rows(y1).filter(overlaps).toList\n  findUp ++ findMiddle ++ findDown\n")),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"Compute ",(0,i.kt)("inlineCode",{parentName:"p"},"part1")," as described above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  solution(input, findPartNumbers)\n\ndef findPartNumbers(grid: Grid) =\n  for\n    (numbers, y) <- grid.numbers.iterator.zipWithIndex\n    number <- numbers\n    if surrounds(y, number, grid.symbols).sizeIs > 0\n  yield\n    number.intValue\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Compute ",(0,i.kt)("inlineCode",{parentName:"p"},"part2")," as described above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int =\n  solution(input, findGearRatios)\n\ndef findGearRatios(grid: Grid) =\n  for\n    (symbols, y) <- grid.symbols.iterator.zipWithIndex\n    symbol <- symbols\n    if symbol.charValue == '*'\n    combined = surrounds(y, symbol, grid.numbers)\n    if combined.sizeIs == 2\n  yield\n    combined.map(_.intValue).product\n")),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Grid(\n  numbers: IArray[IArray[Number]],\n  symbols: IArray[IArray[Symbol]]\n)\n\ntrait Element:\n  def x: Int\n  def length: Int\n\ncase class Symbol(x: Int, length: Int, charValue: Char) extends Element\ncase class Number(x: Int, length: Int, intValue: Int) extends Element\n\ndef parse(input: String): Grid =\n  val (numbers, symbols) =\n    IArray.from(input.linesIterator.map(parseRow(_))).unzip\n  Grid(numbers = numbers, symbols = symbols)\n\ndef surrounds[E <: Element](y: Int, from: Element, rows: IArray[IArray[E]]): List[E] =\n  val (x0, y0, x1, y1) = (from.x - 1, y - 1, from.x + from.length, y + 1)\n  def overlaps(e: Element) = x0 <= (e.x + e.length - 1) && x1 >= e.x\n  def findUp =\n    if y0 < 0 then Nil\n    else rows(y0).filter(overlaps).toList\n  def findMiddle =\n    rows(y).filter(overlaps).toList\n  def findDown =\n    if y1 >= rows.size then Nil\n    else rows(y1).filter(overlaps).toList\n  findUp ++ findMiddle ++ findDown\n\ndef solution(input: String, summarise: Grid => IterableOnce[Int]): Int =\n  summarise(parse(input)).sum\n\ndef part1(input: String): Int =\n  solution(input, findPartNumbers)\n\ndef part2(input: String): Int =\n  solution(input, findGearRatios)\n\ndef findPartNumbers(grid: Grid) =\n  for\n    (numbers, y) <- grid.numbers.iterator.zipWithIndex\n    number <- numbers\n    if surrounds(y, number, grid.symbols).sizeIs > 0\n  yield\n    number.intValue\n\ndef findGearRatios(grid: Grid) =\n  for\n    (symbols, y) <- grid.symbols.iterator.zipWithIndex\n    symbol <- symbols\n    if symbol.charValue == '*'\n    combined = surrounds(y, symbol, grid.numbers)\n    if combined.sizeIs == 2\n  yield\n    combined.map(_.intValue).product\n\ndef parseRow(row: String): (IArray[Number], IArray[Symbol]) =\n  val buf = StringBuilder()\n  val numbers = IArray.newBuilder[Number]\n  val symbols = IArray.newBuilder[Symbol]\n  var begin = -1 // -1 = not building an element, >= 0 = start of an element\n  var knownSymbol = -1 // trinary: -1 = unknown, 0 = number, 1 = symbol\n  def addElement(isSymbol: Boolean, x: Int, value: String) =\n    if isSymbol then symbols += Symbol(x = x, length = value.size, charValue = value.head)\n    else numbers += Number(x = x, length = value.size, intValue = value.toInt)\n  for (curr, colIdx) <- row.zipWithIndex do\n    val isSeparator = curr == '.'\n    val inElement = begin >= 0\n    val kindChanged =\n      !inElement && !isSeparator\n      || isSeparator && inElement\n      || knownSymbol == 1 && curr.isDigit\n      || knownSymbol == 0 && !curr.isDigit\n    if kindChanged then\n      if inElement then // end of element\n        addElement(isSymbol = knownSymbol == 1, x = begin, value = buf.toString)\n        buf.clear()\n      if isSeparator then // reset all state\n        begin = -1\n        knownSymbol = -1\n      else // begin new element\n        begin = colIdx\n        knownSymbol = if curr.isDigit then 0 else 1\n        buf += curr\n    else\n      if !isSeparator then buf += curr\n    end if\n  end for\n  if begin >= 0 then // end of line\n    addElement(isSymbol = knownSymbol == 1, x = begin, value = buf.toString)\n  (numbers.result(), symbols.result())\n")),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1-1"},"Part 1"),(0,i.kt)(r.Z,{puzzle:"day03-part1",year:"2023",mdxType:"Solver"}),(0,i.kt)("h4",{id:"part-2-1"},"Part 2"),(0,i.kt)(r.Z,{puzzle:"day03-part2",year:"2023",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://scastie.scala-lang.org/zSILlpFtTmCmQ3tmOcNPQg"},"Solution")," by johnduffell"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2023/src/main/scala/Day3.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/pkarthick/AdventOfCode/blob/master/2023/scala/src/main/scala/day03.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/pkarthick"},"Karthick Pachiappan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2023/blob/master/src/main/scala/day03/Day03.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/03.worksheet.sc#L89"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2023/blob/main/src/main/scala/solutions/day03.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2023/day3/Day3.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2023/blob/main/2023-day03.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/kbielefe/advent-of-code/blob/master/2023/src/main/scala/3.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/kbielefe"},"Karl Bielefeldt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/mpilquist/aoc/blob/main/2023/day3.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/mpilquist"},"Michael Pilquist")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/iusildra/advent-of-code-2023-scala/blob/main/03.worksheet.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/iusildra"},"Lucas Nouguier"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}p.isMDXComponent=!0}}]);