"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6535],{2077:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));n(6340);const l={},i="Day 14: Parabolic Reflector Dish",r={unversionedId:"2023/puzzles/day14",id:"2023/puzzles/day14",title:"Day 14: Parabolic Reflector Dish",description:"by @anatoliykmetyuk",source:"@site/target/mdoc/2023/puzzles/day14.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day14",permalink:"/scala-advent-of-code/2023/puzzles/day14",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day14.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 13: Point of Incidence",permalink:"/scala-advent-of-code/2023/puzzles/day13"},next:{title:"Day 15: Lens Library",permalink:"/scala-advent-of-code/2023/puzzles/day15"}},s={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Part 1 Solution",id:"part-1-solution",level:2},{value:"Part 2 Solution",id:"part-2-solution",level:2},{value:"The Model",id:"the-model",level:3},{value:"Rotations",id:"rotations",level:3},{value:"Tilting and calculating the loading metric",id:"tilting-and-calculating-the-loading-metric",level:3},{value:"Naive cycling",id:"naive-cycling",level:3},{value:"Performant cycling",id:"performant-cycling",level:3},{value:"Complete Code",id:"complete-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:c};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-14-parabolic-reflector-dish"},"Day 14: Parabolic Reflector Dish"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/anatoliykmetyuk"},"@anatoliykmetyuk")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/14"},"https://adventofcode.com/2023/day/14")),(0,o.kt)("h2",{id:"part-1-solution"},"Part 1 Solution"),(0,o.kt)("p",null,"Part 1 of the puzzle features a square field where two types of objects can reside: round rocks 'O' and square rocks '#'. The objective is to \"tilt\" the field north, so that the round rocks roll as far as they can in that direction, while square rocks stay in place. Then, we need to compute the \"loading\" metric on the northern side of the field which is calculated as a function of how many round rocks there are on the field and how close they are to the northern edge."),(0,o.kt)("p",null,"To solve Part 1, we do not even need to simulate the movement of the rocks - that is, we do not need to compute the state of the model of the platform after the tilting was performed. We can iterate from the top (north) of the field to the bottom, one line at a time, and use caching to remember where the rocks can fall. The algorithm is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def totalLoading(lines: List[String]): Int =\n  var loading = 0\n  val whereCanIFall = collection.mutable.Map.empty[Int, Int]\n  val totalRows = lines.size\n  for\n    (line, row) <- lines.zipWithIndex\n    (char, col) <- line.zipWithIndex\n  do char match\n    case 'O' =>\n      val fallRow = whereCanIFall.getOrElseUpdate(col, 0)\n      loading += totalRows - fallRow\n      whereCanIFall(col) = fallRow + 1\n    case '#' =>\n      whereCanIFall(col) = row + 1\n    case '.' =>\n  loading\n")),(0,o.kt)("h2",{id:"part-2-solution"},"Part 2 Solution"),(0,o.kt)("p",null,"Part 2 is much more involved. Here, we are required to tilt the field in all four directions - North, West, South and East - in turn, in many cycles. The objective is to calculate the same loading metric after 1 billion cycles."),(0,o.kt)("p",null,"The approach from Part 1 doesn't work here: we now need to modify our model state. The reason we didn't have to do it in Part 1 is that our model evolves in only a single step, and we only need one metric from the end state, so we don't have to calculate the entire final state. In Part 2, however, the model evolves in many steps, and each successive step depends on the previous step. So, we need to calculate the entire final state."),(0,o.kt)("h3",{id:"the-model"},"The Model"),(0,o.kt)("p",null,"Actually, we already know how to do the Northern tilt - similarly to Part 1. We do not want to re-implement the tilts for the other directions - instead, we want to use the Northern tilt as a building block for the other tilts. So, we need to be able to rotate our model in all four directions, and then tilt it North."),(0,o.kt)("p",null,"We can represent the model as a 2D array of chars:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"class Model(state: String):\n  private var dataN: Array[Array[Char]] = Array.empty  // The array is indexed as dataN(x)(y), where x is the column and y - the row.\n  setState(state)\n\n  def setState(newState: String): Unit =\n    dataN = newState.split('\\n').map(_.toArray).transpose\n")),(0,o.kt)("p",null,"We'll need to change the model a lot in a succession of many steps, so we build it with mutability in mind. We parse the input ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," into the ",(0,o.kt)("inlineCode",{parentName:"p"},"dataN")," array (",(0,o.kt)("inlineCode",{parentName:"p"},"N"),' for "North" - the default orientation of the model, against which all the views will be calculated).'),(0,o.kt)("h3",{id:"rotations"},"Rotations"),(0,o.kt)("p",null,"We do not want to actually rotate the model, as in changing the coordinates of the stones in the model array. It is computationally expensive (and this challenge is all about optimization). Instead, we need the ability to calculate a lightweight view of our model, so that the rotation operation is cheap."),(0,o.kt)("p",null,"We are going to take a page from computer graphics here. In computer graphics, all transformations of images are defined as matrices, which, when applied to the coordinates of the pixels, produce a new image with changed coordinates. In a computer game, when a player turns, the game doesn't actually rotate the world: instead, it changes the camera transformation matrix, and applies it to the world, thereby calculating what the player sees."),(0,o.kt)("p",null,"We are not going to define actual matrices here, but we are going to define a transformation function for each rotation we will be working against. These functions will take a pair of coordinates and will return a new pair of coordinates in a rotated coordinate system:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"type CoordTransform = (Int, Int) => (Int, Int)\n\nenum Direction:\n  case N, W, S, E\n  def isVertical: Boolean = this match\n    case N | S => true\n    case W | E => false\n\ndef mkTransform(direction: Direction, offsetX: Int, offsetY: Int): CoordTransform = direction match\n  case Direction.N => (x, y) => (x, y)\n  case Direction.W => (x, y) => (offsetY-y, x)\n  case Direction.S => (x, y) => (offsetX-x, offsetY-y)\n  case Direction.E => (x, y) => (y, offsetX-x)\n\ndef mkInverse(direction: Direction, offsetX: Int, offsetY: Int): CoordTransform = direction match\n  case Direction.N => mkTransform(Direction.N, offsetX, offsetY)\n  case Direction.W => mkTransform(Direction.E, offsetX, offsetY)\n  case Direction.S => mkTransform(Direction.S, offsetX, offsetY)\n  case Direction.E => mkTransform(Direction.W, offsetX, offsetY)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction")," enum represents the directions in which we are going to rotate the platform. But, if we naively rotate the coordinate system against the origin, we'll end up with some of the coordinates ending up to be negative. It's a design decision really, but in this case, we decide to keep our coordinates positive for better interop with array indexing, the array being the underlying implementation of our model."),(0,o.kt)("p",null,"So, not only do we rotate the coordinate system, but we also offset it so that the coordinates are always positive. This is what ",(0,o.kt)("inlineCode",{parentName:"p"},"mkTransform")," does. ",(0,o.kt)("inlineCode",{parentName:"p"},"mkInverse")," is a helper function that allows us to rotate the coordinate system back to the original, northern, orientation."),(0,o.kt)("p",null,"Then, we are going to teach our model to work with the rotated coordinate system:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// class Model:\n  var rotation = Direction.N\n  def extentX = if rotation.isVertical then dataN(0).length else dataN.length\n  def extentY = if rotation.isVertical then dataN.length else dataN(0).length\n  private def toNorth: CoordTransform = mkInverse(rotation, extentX-1, extentY-1)\n\n  def apply(x: Int, y: Int): Char =\n    val (xN, yN) = toNorth(x, y)\n    dataN(xN)(yN)\n\n  def update(x: Int, y: Int, char: Char): Unit =\n    val (xN, yN) = toNorth(x, y)\n    dataN(xN)(yN) = char\n\n  override def toString =\n    val sb = new StringBuilder\n    for y <- (0 until extentY).toIterator do\n      for x <- (0 until extentX).toIterator do\n        sb.append(this(x, y))\n      sb.append('\\n')\n    sb.toString\n")),(0,o.kt)("p",null,"The rotation of the coordinate system in which the model works is done by assigning the public variable ",(0,o.kt)("inlineCode",{parentName:"p"},"rotation"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"extentX")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"extentY")," functions return the width and height of the model in the rotated coordinate system. The ",(0,o.kt)("inlineCode",{parentName:"p"},"toNorth")," function returns a transformation function that converts coordinates from the rotated coordinate system back to the original, northern, coordinate system. This is needed because the ",(0,o.kt)("inlineCode",{parentName:"p"},"dataN")," array is always in the northern coordinate system."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," functions are the getters and setters of the model. They receive coordinates in the rotated coordinate system, and convert them to the northern coordinate system before accessing the ",(0,o.kt)("inlineCode",{parentName:"p"},"dataN")," array."),(0,o.kt)("p",null,"Think of ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," as optical lenses: the configuration of the lenses (in our case, the ",(0,o.kt)("inlineCode",{parentName:"p"},"rotation")," variable) can change what you see without changing the object you're looking at."),(0,o.kt)("h3",{id:"tilting-and-calculating-the-loading-metric"},"Tilting and calculating the loading metric"),(0,o.kt)("p",null,"Now that we have the ability to rotate the model, we can implement the tilting operation. We only implement it once and it will be usable for all 4 directions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def cellsIterator(model: Model): Iterator[(Int, Int, Char)] =\n  for\n    x <- (0 until model.extentX).toIterator\n    y <- (0 until model.extentY).toIterator\n  yield (x, y, model(x, y))\n\ndef rollUp(model: Model): Unit =\n  val whereCanIFall = collection.mutable.Map.empty[Int, Int]\n  for (x, y, c) <- cellsIterator(model) do c match\n    case 'O' =>\n      val fallY = whereCanIFall.getOrElseUpdate(x, 0)\n      model(x, y) = '.'\n      model(x, fallY) = 'O'\n      whereCanIFall(x) = fallY + 1\n    case '#' =>\n      whereCanIFall(x) = y + 1\n    case '.' =>\nend rollUp\n")),(0,o.kt)("p",null,"So, ",(0,o.kt)("inlineCode",{parentName:"p"},"rollUp"),' will always roll the stones up the platform - but the "up" is relative to the rotation we\'ve set! So, if we set the rotation to ',(0,o.kt)("inlineCode",{parentName:"p"},"Direction.W"),", the stones will roll to the left when we invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"rollUp")," - although in the current view of the model, it will look like they roll up. If we set the rotation to ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction.S"),", the stones will roll down. And so on. E.g., to roll left:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"model.rotation = Direction.W\nrollUp(model)\n")),(0,o.kt)("p",null,"This is achieved by the ",(0,o.kt)("inlineCode",{parentName:"p"},"cellsIterator")," method which, under the hood, uses ",(0,o.kt)("inlineCode",{parentName:"p"},"model.extentX"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"model.extentY")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"model(x, y)")," - the dimensions and the model accessor that are relative to the model rotation."),(0,o.kt)("p",null,"We can also calculate the model loading as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def totalLoading(model: Model): Int =\n  model.rotation = Direction.N\n  var loading = 0\n  for (_, y, c) <- cellsIterator(model) do c match\n    case 'O' => loading += model.extentY - y\n    case _ =>\n  loading\n")),(0,o.kt)("p",null,"Since the model loading needs to always be calculated against the northern side of the model, we always set the rotation to ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction.N")," before calculating the loading."),(0,o.kt)("h3",{id:"naive-cycling"},"Naive cycling"),(0,o.kt)("p",null,"The challenge requires us to cycle through the North-West-South-East tilts for a billion cycles. Let's implement the simplest possible cycling function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def cycle(model: Model, times: Int): Unit =\n  for i <- 1 to times do\n    for cse <- Direction.values do\n      model.rotation = cse\n      rollUp(model)\n  model.rotation = Direction.N\n")),(0,o.kt)("p",null,"This simple loop repeats a required number of times, and for each loop, we have a nested loop that iterates over all the directions (in order) and performs the rollup for each of those directions. At the end, the rotation is reset to North."),(0,o.kt)("h3",{id:"performant-cycling"},"Performant cycling"),(0,o.kt)("p",null,"This solution looks good but won't get to the billion cycles in a reasonable time. The rollups take way too long."),(0,o.kt)("p",null,'To optimize, we will use the intent of the operation: we cycle for so many times to eventually converge to a certain state. As the challenge puts it, "This process ',"[cycling repeatedly]"," should work if you leave it running long enough, but you're still worried about the north support beams...\"."),(0,o.kt)("p",null,"So, there's a possibility that the desired state will be achieved earlier than the billion cycles. Looks like a good case for a dynamic programming approach: we need to remember the states of the model we've seen before and what they look like after one cycle. And if the current state is in our cache, no need to compute the next state again."),(0,o.kt)("p",null,"Furthermore, since the transitions between states are deterministic (a state A always leads to state B), the moment one state in our cache is followed by another, previously encountered, state from that cache, we can stop cycling and just calculate the final state from the cache."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.util.boundary, boundary.break\n\ndef cycle(model: Model, times: Int): Unit =\n  val chain = collection.mutable.ListBuffer.empty[String]\n  var currentState = model.toString\n  boundary:\n    for cyclesDone <- 0 until times do\n      if chain.contains(currentState) then\n        val cycleStart = chain.indexOf(currentState)\n        val cycleLength = chain.length - cycleStart\n        val cycleIndex = (times - cyclesDone) % cycleLength\n        currentState = chain(cycleIndex + cycleStart)\n        model.setState(currentState)\n        break()\n\n      chain += currentState\n      for cse <- Direction.values do\n        model.rotation = cse\n        rollUp(model)\n      currentState = model.toString\n")),(0,o.kt)("h2",{id:"complete-code"},"Complete Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"//> using scala \"3.3.1\"\n\nimport scala.util.boundary, boundary.break\n\ntype CoordTransform = (Int, Int) => (Int, Int)\n\nenum Direction:\n  case N, W, S, E\n  def isVertical: Boolean = this match\n    case N | S => true\n    case W | E => false\n\ndef mkTransform(direction: Direction, offsetX: Int, offsetY: Int): CoordTransform = direction match\n  case Direction.N => (x, y) => (x, y)\n  case Direction.W => (x, y) => (offsetY-y, x)\n  case Direction.S => (x, y) => (offsetX-x, offsetY-y)\n  case Direction.E => (x, y) => (y, offsetX-x)\n\ndef mkInverse(direction: Direction, offsetX: Int, offsetY: Int): CoordTransform = direction match\n  case Direction.N => mkTransform(Direction.N, offsetX, offsetY)\n  case Direction.W => mkTransform(Direction.E, offsetX, offsetY)\n  case Direction.S => mkTransform(Direction.S, offsetX, offsetY)\n  case Direction.E => mkTransform(Direction.W, offsetX, offsetY)\n\nclass Model(state: String):\n  private var dataN: Array[Array[Char]] = Array.empty  // The array is indexed as dataN(x)(y), where x is the column and y - the row.\n  setState(state)\n\n  var rotation = Direction.N\n  def extentX = if rotation.isVertical then dataN(0).length else dataN.length\n  def extentY = if rotation.isVertical then dataN.length else dataN(0).length\n  private def toNorth: CoordTransform = mkInverse(rotation, extentX-1, extentY-1)\n\n  def apply(x: Int, y: Int): Char =\n    val (xN, yN) = toNorth(x, y)\n    dataN(xN)(yN)\n\n  def update(x: Int, y: Int, char: Char): Unit =\n    val (xN, yN) = toNorth(x, y)\n    dataN(xN)(yN) = char\n\n  def setState(newState: String): Unit =\n    dataN = newState.split('\\n').map(_.toArray).transpose\n\n  override def toString =\n    val sb = new StringBuilder\n    for y <- (0 until extentY).toIterator do\n      for x <- (0 until extentX).toIterator do\n        sb.append(dataN(x)(y))\n      sb.append('\\n')\n    sb.toString\nend Model\n\ndef cellsIterator(model: Model): Iterator[(Int, Int, Char)] =\n  for\n    x <- (0 until model.extentX).toIterator\n    y <- (0 until model.extentY).toIterator\n  yield (x, y, model(x, y))\n\ndef rollUp(model: Model): Unit =\n  val whereCanIFall = collection.mutable.Map.empty[Int, Int]\n  for (x, y, c) <- cellsIterator(model) do c match\n    case 'O' =>\n      val fallY = whereCanIFall.getOrElseUpdate(x, 0)\n      model(x, y) = '.'\n      model(x, fallY) = 'O'\n      whereCanIFall(x) = fallY + 1\n    case '#' =>\n      whereCanIFall(x) = y + 1\n    case '.' =>\nend rollUp\n\ndef cycle(model: Model, times: Int): Unit =\n  val chain = collection.mutable.ListBuffer.empty[String]\n  var currentState = model.toString\n  boundary:\n    for cyclesDone <- 0 until times do\n      if chain.contains(currentState) then\n        val cycleStart = chain.indexOf(currentState)\n        val cycleLength = chain.length - cycleStart\n        val cycleIndex = (times - cyclesDone) % cycleLength\n        currentState = chain(cycleIndex + cycleStart)\n        model.setState(currentState)\n        break()\n\n      chain += currentState\n      for cse <- Direction.values do\n        model.rotation = cse\n        rollUp(model)\n      currentState = model.toString\n\ndef debug(model: Model): Unit =\n  println(s\"=== ${model.rotation}; W: ${ model.extentX }, H: ${ model.extentY } ===\")\n  println(model)\n\ndef totalLoading(model: Model): Int =\n  model.rotation = Direction.N\n  var loading = 0\n  for (_, y, c) <- cellsIterator(model) do c match\n    case 'O' => loading += model.extentY - y\n    case _ =>\n  loading\n\ndef part1(input: String): Int =\n  val model = Model(input)\n  rollUp(model)\n  totalLoading(model)\n\ndef part2(input: String): Int =\n  val model = Model(input)\n  cycle(model, 1_000_000_000)\n  totalLoading(model)\n")),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/14.worksheet.sc#L134"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day14.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/beneyal/aoc-2023/blob/main/src/main/scala/day14.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/beneyal/"},"Ben Eyal")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2023/blob/main/src/main/scala/Day14.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/"},"merlin")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2023/blob/main/day14/parabolic-reflector-dish.sc"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin/advent_code_2023/tree/master/task14/src/main/scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/GrigoriiBerezin"},"g.berezin"))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}h.isMDXComponent=!0}}]);