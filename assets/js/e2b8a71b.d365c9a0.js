"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[738],{5726:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var i=a(7462),n=(a(7294),a(3905)),l=a(6340);const s={},r="Day 8: Treetop Tree House",o={unversionedId:"2022/puzzles/day08",id:"2022/puzzles/day08",title:"Day 8: Treetop Tree House",description:"code and article by Quentin Bernet",source:"@site/target/mdoc/2022/puzzles/day08.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day08",permalink:"/scala-advent-of-code/2022/puzzles/day08",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day08.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 7: No Space Left On Device",permalink:"/scala-advent-of-code/2022/puzzles/day07"},next:{title:"Day 9: Rope Bridge",permalink:"/scala-advent-of-code/2022/puzzles/day09"}},p={},d=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:d};function m(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"day-8-treetop-tree-house"},"Day 8: Treetop Tree House"),(0,n.kt)("p",null,"code and article by ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/Sporarum"},"Quentin Bernet")),(0,n.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/8"},"https://adventofcode.com/2022/day/8")),(0,n.kt)("h2",{id:"solution"},"Solution"),(0,n.kt)("h3",{id:"part-1"},"Part 1"),(0,n.kt)("p",null,"As always, we have to start by parsing the puzzle input. We can convert the string into a list of lines by splitting at the ",(0,n.kt)("inlineCode",{parentName:"p"},"/n")," character: ",(0,n.kt)("inlineCode",{parentName:"p"},"input.split('\\n').toList"),".\nIf we now focus on a single line, ",(0,n.kt)("inlineCode",{parentName:"p"},"String")," behaves like a list of ",(0,n.kt)("inlineCode",{parentName:"p"},"Char"),"s so we can use ",(0,n.kt)("inlineCode",{parentName:"p"},"map")," on it!\nAnd then the individual ",(0,n.kt)("inlineCode",{parentName:"p"},"Char"),"s can be converted to ",(0,n.kt)("inlineCode",{parentName:"p"},"Int")," with ",(0,n.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/Char.html#asDigit:Int"},(0,n.kt)("inlineCode",{parentName:"a"},"asDigit")),": ",(0,n.kt)("inlineCode",{parentName:"p"},"line.map(char => char.asDigit).toList"),"."),(0,n.kt)("p",null,"Note: ",(0,n.kt)("inlineCode",{parentName:"p"},"char.toInt")," would return the ascii value, so for example ",(0,n.kt)("inlineCode",{parentName:"p"},"'0'.toInt == 48"),"."),(0,n.kt)("p",null,"Putting this all together, we get:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"def parse(input: String): HeightField = input.split('\\n').toList.map(line => line.map(char => char.asDigit).toList)\n")),(0,n.kt)("p",null,"Oh what's ",(0,n.kt)("inlineCode",{parentName:"p"},"HeightField")," ?\nWe'll manipulate a lot of ",(0,n.kt)("inlineCode",{parentName:"p"},"List[List["),"something",(0,n.kt)("inlineCode",{parentName:"p"},"]]"),", so it's useful to create a type alias for it:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"type Field[A] = List[List[A]]\n")),(0,n.kt)("p",null,"And a ",(0,n.kt)("inlineCode",{parentName:"p"},"HeightField")," is well; a field of heights!\nAnd we'll represent these heights as ",(0,n.kt)("inlineCode",{parentName:"p"},"Int"),"s."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"type HeightField = Field[Int] // = List[List[Int]]\n")),(0,n.kt)("p",null,"(It would have been more intuitive to call it ",(0,n.kt)("inlineCode",{parentName:"p"},"HeightMap"),", but this could create some confusion with Scala's ",(0,n.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/Map.html"},(0,n.kt)("inlineCode",{parentName:"a"},"Map")),"s which are the equivalent of dictionaries in other languages.)"),(0,n.kt)("p",null,"Where were we?\nOh right, parsing's done, but it's not clear how to tacle the problem ... We'll start with a very simplified view of the problem:\nWhat if we have only one line, and we only care about which trees are visible from the left?\nSo we have that in ",(0,n.kt)("inlineCode",{parentName:"p"},"30373")," only the first ",(0,n.kt)("inlineCode",{parentName:"p"},"3")," and the first ",(0,n.kt)("inlineCode",{parentName:"p"},"7")," are visible, that seems more doable."),(0,n.kt)("p",null,"A tree is visible if and only if it's bigger than the biggest one on its left, so let's start by computing the biggest tree on the left of each tree:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"val rollingMax = line.scanLeft(-1){ case (max, curr) => Math.max(max, curr) }.init\n")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#scanLeft%5BB%5D(z:B)(op:(B,A)=%3EB):CC%5BB%5D"},(0,n.kt)("inlineCode",{parentName:"a"},"scanLeft"))," will return a list whose first element is ",(0,n.kt)("inlineCode",{parentName:"p"},"-1")," and last element the maximum of the whole line, but no tree has all trees on its left, so we actually do not want that last element, and that's what the ",(0,n.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#init:C"},(0,n.kt)("inlineCode",{parentName:"a"},"init"))," at the end of the line does."),(0,n.kt)("p",null,"We can now compare the height of a tree to the corresponding element of ",(0,n.kt)("inlineCode",{parentName:"p"},"rollingMax"),", and if it's greater, we know the tree is visible:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"rollingMax.zip(line).map{ case (max, curr) => max < curr) }\n")),(0,n.kt)("p",null,"Wait, since we're only looking at visibility from the left, the lines do not interact at all, so we only have to repeat what we did on each line:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"def computeVisibility(ls: HeightField): VisibilityField = ls.map{ line =>\n  val rollingMax = line.scanLeft(-1){ case (max, curr) => Math.max(max, curr) }.init\n  rollingMax.zip(line).map{ case (max, curr) => max < curr) }\n}\n")),(0,n.kt)("p",null,"This returns a ",(0,n.kt)("inlineCode",{parentName:"p"},"VisibilityField"),", a field in which if a tree is visible, the ",(0,n.kt)("inlineCode",{parentName:"p"},"Boolean")," at it's place is ",(0,n.kt)("inlineCode",{parentName:"p"},"true"),", and vice-versa."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"type VisibilityField = Field[Boolean]\n")),(0,n.kt)("p",null,"So now, how do we check visibility from the right ? We could make a new function that uses ",(0,n.kt)("inlineCode",{parentName:"p"},"scanRight")," instead of ",(0,n.kt)("inlineCode",{parentName:"p"},"scanLeft"),", and a few adjustments, but there is a lazier solution: Just flip the line!"),(0,n.kt)("p",null,"We can flip a line with ",(0,n.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#reverse:List%5BA%5D"},(0,n.kt)("inlineCode",{parentName:"a"},"reverse")),", so ",(0,n.kt)("inlineCode",{parentName:"p"},"computeVisibility(parsed.map(_.reverse)).map(_.reverse)")," gives us visibility from the right.\nThe second ",(0,n.kt)("inlineCode",{parentName:"p"},"reverse"),' is there to "unflip" the result.'),(0,n.kt)("p",null,"Note: if we did ",(0,n.kt)("inlineCode",{parentName:"p"},"parsed.reverse"),", we would flip the order of the lines, and not the lines themselves."),(0,n.kt)("p",null,"Okay, we have visibility from the left and right, but from the top and bottom is going to be way harder, as we have to cross multiple lines, right?\n... If only we could swap rows and collumns, we could solve our problem lazily like before ...\nHmm, some faint memories of matrices comme to mind, there was an operation called transpose that did this kind of things, no?\nI'll look for it in the standard library just in case ... and of course there is a method ",(0,n.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#transpose%5BB%5D(implicitasIterable:A=%3EIterable%5BB%5D):CC%5BCC%5BB%5D@scala.annotation.unchecked.uncheckedVariance%5D"},(0,n.kt)("inlineCode",{parentName:"a"},"transpose"))," that does exactly what we want!"),(0,n.kt)("p",null,"The signature is a bit scary with its ",(0,n.kt)("inlineCode",{parentName:"p"},"[B](implicit asIterable: (A) => collection.Iterable[B])"),", but all that basically means is \"You can use me without any parameters if I'm a ",(0,n.kt)("inlineCode",{parentName:"p"},"List[List["),"something",(0,n.kt)("inlineCode",{parentName:"p"},"]]"),'".'),(0,n.kt)("p",null,"To recapitulate, we can check visibility from the top by doing ",(0,n.kt)("inlineCode",{parentName:"p"},"computeVisibility(parsed.transpose).transpose"),".\nAnd from the bottom by combining both tricks: ",(0,n.kt)("inlineCode",{parentName:"p"},"computeVisibility(parsed.transpose.map(_.reverse)).map(_.reverse).transpose"),"."),(0,n.kt)("p",null,"This is beginning to get hard to read, so let's move it all to a function that computes all four directions for us:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"def computeInAllDirections[A, B](xss: Field[A], f: Field[A] => Field[B]): List[Field[B]] =\n  for\n    transpose <- List(false, true)\n    reverse <- List(false, true)\n  yield\n    val t = if transpose then xss.transpose else xss\n    val in = if reverse then t.map(_.reverse) else t\n    val res = f(in)\n    val r = if reverse then res.map(_.reverse) else res\n    val out = if transpose then r.transpose else r\n    out\n\nval visibilityFields: List[VisibilityField] = computeInAllDirections(parsed, computeVisibility)\n")),(0,n.kt)("p",null,"But we get 4 fields, one for each direction, when we would like to get only one.\nA tree is visible if it is visible from the left ",(0,n.kt)("strong",{parentName:"p"},"or")," the right ",(0,n.kt)("strong",{parentName:"p"},"or")," the top ",(0,n.kt)("strong",{parentName:"p"},"or")," the bottom, so for each position we need to take the or (",(0,n.kt)("inlineCode",{parentName:"p"},"|"),") of the 4 fields at that position:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"val visibilityField: VisibilityField = visibilityFields.reduce(combine(_ | _))\n")),(0,n.kt)("p",null,"Where ",(0,n.kt)("inlineCode",{parentName:"p"},"combine")," is defined as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"extension [A](xss: Field[A])\n  def megaZip[B](yss: Field[B]): Field[(A, B)] = (xss zip yss).map( (xs, ys) => xs zip ys )\n  def megaMap[B](f: A => B): Field[B] = xss.map(_.map(f))\n  def megaReduce(f: (A,A) => A): A = xss.map(_.reduce(f)).reduce(f)\n\ndef combine[A](op: ((A,A)) => A)(f1: Field[A], f2: Field[A]): Field[A] = f1.megaZip(f2).megaMap(op)\n")),(0,n.kt)("p",null,"And ",(0,n.kt)("inlineCode",{parentName:"p"},"megaZip"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"megaMap")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"megaReduce")," are equivalents for ",(0,n.kt)("inlineCode",{parentName:"p"},"Field"),"s of the respective methods for ",(0,n.kt)("inlineCode",{parentName:"p"},"List"),"s.\nFor example where ",(0,n.kt)("inlineCode",{parentName:"p"},"reduce")," transforms a list to a single element, ",(0,n.kt)("inlineCode",{parentName:"p"},"megaReduce")," transforms a field to a single element."),(0,n.kt)("p",null,"So now we have a field that tells us which trees are visible, so the last step is to count them:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"visibilityField.megaMap(if _ then 1 else 0).megaReduce(_ + _)\n")),(0,n.kt)("p",null,"Where ",(0,n.kt)("inlineCode",{parentName:"p"},"if _ then 1 else 0")," converts ",(0,n.kt)("inlineCode",{parentName:"p"},"true")," to ",(0,n.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"false")," to ",(0,n.kt)("inlineCode",{parentName:"p"},"0"),", as sadly the standard library doesn't include a ",(0,n.kt)("inlineCode",{parentName:"p"},".toInt")," method on ",(0,n.kt)("inlineCode",{parentName:"p"},"Boolean"),"s."),(0,n.kt)("h3",{id:"part-2"},"Part 2"),(0,n.kt)("p",null,"The idea to check the visibility for one line in one go is to keep a list (",(0,n.kt)("inlineCode",{parentName:"p"},"lengths"),") of how many trees can be seen by trees of a certain height.\nFor example trees of height ",(0,n.kt)("inlineCode",{parentName:"p"},"3")," can see ",(0,n.kt)("inlineCode",{parentName:"p"},"lengths(3)")," trees.\nAnd we update this list with each new tree we see, if it's ",(0,n.kt)("inlineCode",{parentName:"p"},"x")," big, all trees at least ",(0,n.kt)("inlineCode",{parentName:"p"},"x")," small will only see that tree, and all other trees will see one more: at index ",(0,n.kt)("inlineCode",{parentName:"p"},"i")," of value ",(0,n.kt)("inlineCode",{parentName:"p"},"v"),":\n",(0,n.kt)("inlineCode",{parentName:"p"},"if i <= x then 1 else v+1"),"."),(0,n.kt)("p",null,"We can then use this in a similar way to what we did with ",(0,n.kt)("inlineCode",{parentName:"p"},"max")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"rollingMax")," before:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"val rollingLengths = line.scanRight( List.fill(10)(0) ){\n  case (curr, lengths) =>\n    lengths.zipWithIndex.map{ case (v, i) => if i <= curr then 1 else v+1 }\n}.init\n")),(0,n.kt)("p",null,"We then get the score by reading ",(0,n.kt)("inlineCode",{parentName:"p"},"lengths")," at the appropriate point, again as was done with ",(0,n.kt)("inlineCode",{parentName:"p"},"rollingMax"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"rollingLengths.zip(line).map{ case (lengths, curr) => lengths(curr) }\n")),(0,n.kt)("p",null,"By combining everything, noticing once again our calculation is the same for each line, we get:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"def computeScore(ls: HeightField): ScoreField = ls.map{ line =>\n  val rollingLengths = line.scanRight( List.fill(10)(0) ){\n    case (curr, lengths) =>\n      lengths.zipWithIndex.map{ case (v, i) => if i <= curr then 1 else v+1 }\n  }.init\n  rollingLengths.zip(line).map{ case (lengths, curr) => lengths(curr) }\n}\n")),(0,n.kt)("p",null,"Where ",(0,n.kt)("inlineCode",{parentName:"p"},"ScoreField")," is identical to ",(0,n.kt)("inlineCode",{parentName:"p"},"HeightField"),", but serves to make the code more readable:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"type ScoreField = Field[Int]\n")),(0,n.kt)("p",null,"We can use the same trick as before to get all the other directions for free:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"val scoreFields: List[ScoreField] = computeInAllDirections(parsed, computeScore)\n")),(0,n.kt)("p",null,'This time instead of or-ing, we need to multiply "A tree\'s scenic score is found by multiplying together its viewing distance in each of the four directions.":'),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"val scoreField: ScoreField = scoreFields.reduce(combine(_ * _))\n")),(0,n.kt)("p",null,"And this time the last step is to get the heighest value instead of the sum:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"scoreField.megaReduce(_ max _)\n")),(0,n.kt)("h2",{id:"final-code"},"Final Code"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val parsed = parse(input)\n  val visibilityFields: List[VisibilityField] = computeInAllDirections(parsed, computeVisibility)\n  val visibilityField: VisibilityField = visibilityFields.reduce(combine(_ | _))\n  visibilityField.megaMap(if _ then 1 else 0).megaReduce(_ + _)\n\ndef part2(input: String): Int =\n  val parsed = parse(input)\n  val scoreFields: List[ScoreField] = computeInAllDirections(parsed, computeScore)\n  val scoreField: ScoreField = scoreFields.reduce(combine(_ * _))\n  scoreField.megaReduce(_ max _)\n\ntype Field[A] = List[List[A]]\n\nextension [A](xss: Field[A])\n  def megaZip[B](yss: Field[B]): Field[(A, B)] = (xss zip yss).map( (xs, ys) => xs zip ys )\n  def megaMap[B](f: A => B): Field[B] = xss.map(_.map(f))\n  def megaReduce(f: (A,A) => A): A = xss.map(_.reduce(f)).reduce(f)\n\ndef combine[A](op: ((A,A)) => A)(f1: Field[A], f2: Field[A]): Field[A] = f1.megaZip(f2).megaMap(op)\n\ndef computeInAllDirections[A, B](xss: Field[A], f: Field[A] => Field[B]): List[Field[B]] =\n  for\n    transpose <- List(false, true)\n    reverse <- List(false, true)\n  yield\n    val t = if transpose then xss.transpose else xss\n    val in = if reverse then t.map(_.reverse) else t\n    val res = f(in)\n    val r = if reverse then res.map(_.reverse) else res\n    val out = if transpose then r.transpose else r\n    out\n\ntype HeightField = Field[Int]\ntype ScoreField = Field[Int]\n\ntype VisibilityField = Field[Boolean]\n\ndef parse(input: String): HeightField = input.split('\\n').toList.map(line => line.map(char => char.asDigit).toList)\n\ndef computeVisibility(ls: HeightField): VisibilityField = ls.map{ line =>\n  val rollingMax = line.scanLeft(-1){ case (max, curr) => Math.max(max, curr) }.init\n  rollingMax.zip(line).map{ case (max, curr) => max < curr) }\n}\n\ndef computeScore(ls: HeightField): ScoreField = ls.map{ line =>\n  val rollingLengths = line.scanRight( List.fill(10)(0) ){\n    case (curr, lengths) =>\n      lengths.zipWithIndex.map{ case (v, i) => if i <= curr then 1 else v+1 }\n  }.init\n  rollingLengths.zip(line).map{ case (lengths, curr) => lengths(curr) }\n}\n")),(0,n.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,n.kt)("h4",{id:"part-1-1"},"Part 1"),(0,n.kt)(l.Z,{puzzle:"day08-part1",year:"2022",mdxType:"Solver"}),(0,n.kt)("h4",{id:"part-2-1"},"Part 2"),(0,n.kt)(l.Z,{puzzle:"day08-part2",year:"2022",mdxType:"Solver"}),(0,n.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2022/src/test/scala/Day08.scala"},"Solution")," of ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2022/blob/master/src/main/scala/day08/Day08.scala"},"Solution")," of ",(0,n.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/SimY4/advent-of-code-scala/blob/master/src/main/scala/aoc/y2022/Day8.scala"},"Solution")," of ",(0,n.kt)("a",{parentName:"li",href:"https://twitter.com/actinglikecrazy"},"SimY4"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day8.scala"},"Solution")," by Cosmin Ciobanu"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day08.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day8.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau/code-advent-2022/blob/master/src/main/scala/com/adventofcode/Day8.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau"},"Daniel Naumau")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day8"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,n.kt)("p",null,"Share your solution to the Scala community by editing this page."))}m.isMDXComponent=!0}}]);