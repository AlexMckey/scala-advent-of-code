"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[333],{3023:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var i=n(7462),a=(n(7294),n(3905)),o=n(6340);const l={},r="Day 3: Binary Diagnostic",s={unversionedId:"puzzles/day3",id:"puzzles/day3",title:"Day 3: Binary Diagnostic",description:"by @sjrd",source:"@site/target/mdoc/puzzles/day3.md",sourceDirName:"puzzles",slug:"/puzzles/day3",permalink:"/scala-advent-of-code/puzzles/day3",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day3.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 2: Dive!",permalink:"/scala-advent-of-code/puzzles/day2"},next:{title:"Day 4: Giant Squid",permalink:"/scala-advent-of-code/puzzles/day4"}},p={},d=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution of Part 1",id:"solution-of-part-1",level:2},{value:"Reading the input file",id:"reading-the-input-file",level:3},{value:"Modeling the input",id:"modeling-the-input",level:3},{value:"The main logic of part 1",id:"the-main-logic-of-part-1",level:3},{value:"Final code for part 1",id:"final-code-for-part-1",level:3},{value:"First solution of Part 2",id:"first-solution-of-part-2",level:2},{value:"Improved solution for part 2",id:"improved-solution-for-part-2",level:3},{value:"Final code for part 2",id:"final-code-for-part-2",level:3},{value:"Run it locally",id:"run-it-locally",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:d};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"day-3-binary-diagnostic"},"Day 3: Binary Diagnostic"),(0,a.kt)("p",null,"by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sjrd"},"@sjrd")),(0,a.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/3"},"https://adventofcode.com/2021/day/3")),(0,a.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,a.kt)("h3",{id:"reading-the-input-file"},"Reading the input file"),(0,a.kt)("p",null,"To spice up our Advent of Code a bit, I chose to solve this puzzle using Scala.js rather than Scala/JVM.\nConcretely, that changes almost nothing, except how we read the input file.\nIn Scala.js, we cannot use ",(0,a.kt)("inlineCode",{parentName:"p"},"java.io.File")," to read files, and therefore neither ",(0,a.kt)("inlineCode",{parentName:"p"},"scala.io.Source.fromFile"),".\nInstead, we can use Node.js' ",(0,a.kt)("inlineCode",{parentName:"p"},"fs")," module, and in particular its ",(0,a.kt)("inlineCode",{parentName:"p"},"readFileSync")," function."),(0,a.kt)("p",null,"Since I do not want to add a dependency on an external library for a single method definition, I define a ",(0,a.kt)("a",{parentName:"p",href:"https://www.scala-js.org/doc/interoperability/facade-types.html"},"Scala.js facade type")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"fs.readFileSync")," myself:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.scalajs.js\nimport scala.scalajs.js.annotation._\n\n@js.native @JSImport("fs", "readFileSync")\ndef readFileSync(path: String, charset: String): String = js.native\n')),(0,a.kt)("p",null,"It declares that ",(0,a.kt)("inlineCode",{parentName:"p"},"readFileSync")," is a native JavaScript function, found in the module ",(0,a.kt)("inlineCode",{parentName:"p"},'"fs"')," under the name ",(0,a.kt)("inlineCode",{parentName:"p"},'"readFileSync"'),".\nIt is somewhat equivalent to writing the following JavaScript line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const readFileSync = require("fs").readFileSync;\n')),(0,a.kt)("p",null,"With that function, we can adapt the code that reads the input file as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val input = readFileSync("input/day3", "utf-8")\n// instead of\nval input = util.Using.resource(Source.fromFile("input/day3"))(_.mkString)\n')),(0,a.kt)("h3",{id:"modeling-the-input"},"Modeling the input"),(0,a.kt)("p",null,"Each input line of today's puzzle is a sequence of bits.\nWe might be tempted to represent them as an integer, but that would be counter-productive for how we are going to manipulate them.\nAdditionally, nothing in the puzzle description says that the bit sequences have any length limit; they might be too long to fit in an ",(0,a.kt)("inlineCode",{parentName:"p"},"Int")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"Long"),"."),(0,a.kt)("p",null,"Therefore, we stick to a more naive model, using an ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexedSeq[Int]")," for each line, where the ",(0,a.kt)("inlineCode",{parentName:"p"},"Int"),"s are 1 or 0.\nTo make our intent more explicit in the rest of the code, we declare a ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," alias for that type, and a function to parse a line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"type BitLine = IndexedSeq[Int]\n\ndef parseBitLine(line: String): BitLine =\n  line.map(c => c - '0') // 1 or 0\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"c - '0'")," might be confusing to some readers.\nSince ",(0,a.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"'0'")," are both ",(0,a.kt)("inlineCode",{parentName:"p"},"Char"),"s, it is equivalent to ",(0,a.kt)("inlineCode",{parentName:"p"},"c.toInt - '0'.toInt"),".\nUnlike on Strings, ",(0,a.kt)("inlineCode",{parentName:"p"},"toInt")," on a ",(0,a.kt)("inlineCode",{parentName:"p"},"Char")," returns the integer code unit associated with the character.\nFor example, ",(0,a.kt)("inlineCode",{parentName:"p"},"'0'.toInt == 48")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"'A'.toInt == 65"),".\nWe kind of abuse the knowledge that the input only contains ",(0,a.kt)("inlineCode",{parentName:"p"},"'1'"),"s and ",(0,a.kt)("inlineCode",{parentName:"p"},"'0'"),"s to quickly turn ",(0,a.kt)("inlineCode",{parentName:"p"},"'1'")," into ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"'0'")," into ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,a.kt)("h3",{id:"the-main-logic-of-part-1"},"The main logic of part 1"),(0,a.kt)("p",null,"Finally, we can proceed with the main logic of part 1.\nFor each bit position, we need to decide whether ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," is more common than ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", or conversely.\nWe first count, for each bit position, how many ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"s there are:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val bitLines: List[BitLine] = input.linesIterator.map(parseBitLine).toList\n\nval sumsOfOneBits: IndexedSeq[Int] = bitLines.reduceLeft((prevSum, line) =>\n  for ((prevBitSum, lineBit) <- prevSum.zip(line))\n    yield prevBitSum + lineBit\n)\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"reduceLeft")," is like ",(0,a.kt)("inlineCode",{parentName:"p"},"foldLeft")," which we discussed yesterday, except the initial value is the first element of the collection.\n",(0,a.kt)("inlineCode",{parentName:"p"},"prevSum")," is, for each bit position, the number of ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," bits seen so far; while ",(0,a.kt)("inlineCode",{parentName:"p"},"line")," is the following line.\nSince we use 1's and 0's, ",(0,a.kt)("inlineCode",{parentName:"p"},"prevBitSum + lineBit")," is enough to add 1 if the bit is ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", and add 0 if is ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),".\nWe are therefore computing the number of ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"'s."),(0,a.kt)("p",null,"For each bit position, we then compare the total count of ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"'s to the total number of lines to compute ",(0,a.kt)("inlineCode",{parentName:"p"},"gammaRateBits"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val total = bitLines.size\n\nval gammaRateBits: BitLine =\n  for (sumOfOneBits <- sumsOfOneBits)\n    yield (if (sumOfOneBits * 2 > total) 1 else 0)\nval gammaRate = bitLineToInt(gammaRateBits)\n\ndef bitLineToInt(bitLine: BitLine): Int =\n  Integer.parseInt(bitLine.mkString, 2)\n")),(0,a.kt)("p",null,"We use ",(0,a.kt)("inlineCode",{parentName:"p"},"sumOfOneBits * 2 > total")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"sumOfOneBits > total / 2")," (which may be more intuitive) in order not to worry about the case where ",(0,a.kt)("inlineCode",{parentName:"p"},"total")," is odd.\n",(0,a.kt)("inlineCode",{parentName:"p"},"bitLineToInt")," is nothing else than putting the bits back together as a string, and parsing it as an integer in base 2."),(0,a.kt)("p",null,"We use a similar solution for ",(0,a.kt)("inlineCode",{parentName:"p"},"epsilonRate"),"."),(0,a.kt)("h3",{id:"final-code-for-part-1"},"Final code for part 1"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val bitLines: List[BitLine] = input.linesIterator.map(parseBitLine).toList\n\n  val sumsOfOneBits: IndexedSeq[Int] = bitLines.reduceLeft((prevSum, line) =>\n    for ((prevBitSum, lineBit) <- prevSum.zip(line))\n      yield prevBitSum + lineBit\n  )\n  val total = bitLines.size // this will walk the list a second time, but that's OK\n\n  val gammaRateBits: BitLine =\n    for (sumOfOneBits <- sumsOfOneBits)\n      yield (if (sumOfOneBits * 2 > total) 1 else 0)\n  val gammaRate = bitLineToInt(gammaRateBits)\n\n  val epsilonRateBits: BitLine =\n    for (sumOfOneBits <- sumsOfOneBits)\n      yield (if (sumOfOneBits * 2 < total) 1 else 0)\n  val epsilonRate = bitLineToInt(epsilonRateBits)\n\n  gammaRate * epsilonRate\n\ntype BitLine = IndexedSeq[Int]\n\ndef parseBitLine(line: String): BitLine =\n  line.map(c => c - '0') // 1 or 0\n\ndef bitLineToInt(bitLine: BitLine): Int =\n  Integer.parseInt(bitLine.mkString, 2)\n")),(0,a.kt)(o.Z,{puzzle:"day3-part1",year:"2021",mdxType:"Solver"}),(0,a.kt)("h2",{id:"first-solution-of-part-2"},"First solution of Part 2"),(0,a.kt)("p",null,"Part 2 of this puzzle starts to get somewhat trickier.\nFirst, we solve it as naively as possible, by directly following the rules."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int =\n  val bitLines = input.linesIterator.map(parseBitLine).toList\n\n  // bit criteria: keep the '1's if there is more '1's than '0's or if there is a tie\n  val oxygenGeneratorRatingLine: BitLine = recursiveFilter(bitLines, 0,\n      (totalOnes, total) => if (totalOnes * 2 >= total) 1 else 0)\n  val oxygenGeneratorRating = bitLineToInt(oxygenGeneratorRatingLine)\n\n  // bit criteria: keep the '0's if there is more '0's than '1's or if there is a tie\n  // equivalent to: keep the '1's if there is strictly less '1's than '0's\n  val co2ScrubberRatingLine: BitLine = recursiveFilter(bitLines, 0,\n      (totalOnes, total) => if (totalOnes * 2 < total) 1 else 0)\n  val co2ScrubberRating = bitLineToInt(co2ScrubberRatingLine)\n\n  oxygenGeneratorRating * co2ScrubberRating\n\n@scala.annotation.tailrec\ndef recursiveFilter(bitLines: List[BitLine], bitPosition: Int,\n    bitCriteria: (Int, Int) => Int): BitLine =\n  bitLines match\n    // If we don't have any remaining line, we have a problem\n    case Nil =>\n      throw new AssertionError(\"this shouldn't have happened\")\n\n    // If there is only one line left, we return it\n    case lastRemainingLine :: Nil =>\n      lastRemainingLine\n\n    // Otherwise, filter using the bit criteria at the given `bitPosition`, and start over at the next bit position\n    case _ =>\n      // Count the number of '1's at the given `bitPosition`\n      val totalOnes = bitLines.count(line => line(bitPosition) == 1)\n      // Count the total number of remaining lines\n      val total = bitLines.size\n      // Decide which bit to keep based on the bit criteria\n      val bitToKeep = bitCriteria(totalOnes, total)\n      // Keep the lines that have the correct bit at the given position\n      val filtered = bitLines.filter(line => line(bitPosition) == bitToKeep)\n      // Start over with the filtered list, at the next bit position\n      recursiveFilter(filtered, bitPosition + 1, bitCriteria)\n")),(0,a.kt)("p",null,"Note the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"@scala.annotation.tailrec")," to ask the compiler to verify that ",(0,a.kt)("inlineCode",{parentName:"p"},"recursiveFilter")," is tail-recursive.\nTail-recursive methods are compiled as loops, and therefore do not increase stack space."),(0,a.kt)("h3",{id:"improved-solution-for-part-2"},"Improved solution for part 2"),(0,a.kt)("p",null,"The code above works, but it feels a bit wasteful: we first compute how many lines have a ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," at the given bit position, and then later we filter again to find those lines, or the other ones.\nWe can improve this using ",(0,a.kt)("inlineCode",{parentName:"p"},"partition"),", to separate the lines with ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"s from those in ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),"s in one traversal.\nHere is an example of ",(0,a.kt)("inlineCode",{parentName:"p"},"partition")," that separates odd numbers from even numbers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val numbers = List(4, 6, 5, 12, 75, 3, 10)\nval (oddNumbers, evenNumbers) = numbers.partition(x => x % 2 != 0)\n// oddNumbers = List(5, 75, 3)\n// evenNumbers = List(4, 6, 12, 10)\n")),(0,a.kt)("p",null,"We use it as follows to separate our lines in two lists:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val (bitLinesWithOne, bitLinesWithZero) =\n  bitLines.partition(line => line(bitPosition) == 1)\n")),(0,a.kt)("p",null,"We can determine whether there are more ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"s than ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),"s (or a tie) by comparing the size of the two lists.\nComparing the sizes of two collections is best done with ",(0,a.kt)("inlineCode",{parentName:"p"},"sizeCompare"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val onesAreMostCommon = bitLinesWithOne.sizeCompare(bitLinesWithZero) >= 0\n")),(0,a.kt)("p",null,"Finally, we decide which list we keep to go further:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val bitLinesToKeep =\n  if onesAreMostCommon then\n    if keepMostCommon then bitLinesWithOne else bitLinesWithZero\n  else\n    if keepMostCommon then bitLinesWithZero else bitLinesWithOne\nrecursiveFilter(bitLinesToKeep, bitPosition + 1, keepMostCommon)\n")),(0,a.kt)("p",null,"(The two tests could be combined as ",(0,a.kt)("inlineCode",{parentName:"p"},"if onesAreMostCommon == keepMostCommon"),", but I found that less readable.)"),(0,a.kt)("h3",{id:"final-code-for-part-2"},"Final code for part 2"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): Int =\n  val bitLines: List[BitLine] = input.linesIterator.map(parseBitLine).toList\n\n  val oxygenGeneratorRatingLine: BitLine =\n    recursiveFilter(bitLines, 0, keepMostCommon = true)\n  val oxygenGeneratorRating = bitLineToInt(oxygenGeneratorRatingLine)\n\n  val co2ScrubberRatingLine: BitLine =\n    recursiveFilter(bitLines, 0, keepMostCommon = false)\n  val co2ScrubberRating = bitLineToInt(co2ScrubberRatingLine)\n\n  oxygenGeneratorRating * co2ScrubberRating\n\n@scala.annotation.tailrec\ndef recursiveFilter(bitLines: List[BitLine], bitPosition: Int,\n    keepMostCommon: Boolean): BitLine =\n  bitLines match\n    case Nil =>\n      throw new AssertionError("this shouldn\'t have happened")\n    case lastRemainingLine :: Nil =>\n      lastRemainingLine\n    case _ =>\n      val (bitLinesWithOne, bitLinesWithZero) =\n        bitLines.partition(line => line(bitPosition) == 1)\n      val onesAreMostCommon = bitLinesWithOne.sizeCompare(bitLinesWithZero) >= 0\n      val bitLinesToKeep =\n        if onesAreMostCommon then\n          if keepMostCommon then bitLinesWithOne else bitLinesWithZero\n        else\n          if keepMostCommon then bitLinesWithZero else bitLinesWithOne\n      recursiveFilter(bitLinesToKeep, bitPosition + 1, keepMostCommon)\n')),(0,a.kt)(o.Z,{puzzle:"day3-part2",year:"2021",mdxType:"Solver"}),(0,a.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,a.kt)("p",null,"You can get this solution locally by cloning the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,a.kt)("p",null,"You can run it with scala-cli.\nSince today's solution is written in Scala.js, you will need a local setup of ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/en/"},"Node.js")," to run it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ scala-cli 2021 -M day3.part1 --js-module-kind commonjs\nThe answer is 1025636\n\n$ scala-cli 2021 -M day3.part2 --js-module-kind commonjs\nThe answer is 793873\n")),(0,a.kt)("p",null,"You can replace the content of the ",(0,a.kt)("inlineCode",{parentName:"p"},"input/day3")," file with your own input from ",(0,a.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/3"},"adventofcode.com")," to get your own solution."),(0,a.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/s5bug/aoc/blob/main/src/main/scala/tf/bug/aoc/y2021/Day03.scala"},"Solution")," of @s5bug using ",(0,a.kt)("a",{parentName:"li",href:"https://index.scala-lang.org/typelevel/cats-effect/cats-effect/3.3.0?target=_3.x"},"cats-effect")," and ",(0,a.kt)("a",{parentName:"li",href:"https://index.scala-lang.org/typelevel/fs2/fs2-core/3.2.1?target=_3.x"},"fs2")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/tOverney/AdventOfCode2021/blob/main/src/main/scala/ch/overney/aoc/day3/"},"Solution")," of ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/tOverney"},"@tOverney"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/philipschwarz/advent-of-code-2021-scala/tree/master/src/main/scala/day3"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://twitter.com/philip_schwarz"},"@philip_schwarz")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day03/Day03.scala"},"Solution")," of ",(0,a.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),".")),(0,a.kt)("p",null,"Share your solution to the Scala community by editing this page."))}m.isMDXComponent=!0}}]);