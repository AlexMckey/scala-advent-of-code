"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3866],{2438:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905)),o=n(6340);const l={},r="Day 6: Tuning Trouble",s={unversionedId:"2022/puzzles/day06",id:"2022/puzzles/day06",title:"Day 6: Tuning Trouble",description:"Code by Jan Boerman, and Jamie Thompson.",source:"@site/target/mdoc/2022/puzzles/day06.md",sourceDirName:"2022/puzzles",slug:"/2022/puzzles/day06",permalink:"/scala-advent-of-code/2022/puzzles/day06",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2022/puzzles/day06.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 5: Supply Stacks",permalink:"/scala-advent-of-code/2022/puzzles/day05"},next:{title:"Day 7: No Space Left On Device",permalink:"/scala-advent-of-code/2022/puzzles/day07"}},d={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1",level:4},{value:"Part 2",id:"part-2",level:4},{value:"Optimising the Code",id:"optimising-the-code",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],u={toc:p};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-6-tuning-trouble"},"Day 6: Tuning Trouble"),(0,i.kt)("p",null,"Code by ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),", and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"Jamie Thompson"),".\nArticle by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Sporarum"},"Quentin Bernet")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2022/day/6"},"https://adventofcode.com/2022/day/6")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"The goal today is to find the first spot of the input with 4 consecutive characters that are all different."),(0,i.kt)("p",null,"There are thus three steps: look at chunks of 4 consecutive characters, check if they are all different, and find the first index among those."),(0,i.kt)("p",null,"To look at windows of 4 characters, we can use the ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/StringOps.html#sliding(size:Int,step:Int):Iterator%5BString%5D"},(0,i.kt)("inlineCode",{parentName:"a"},"sliding")," method")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s with 4 as the ",(0,i.kt)("inlineCode",{parentName:"p"},"size"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Scala"},"  val windows = input.sliding(4)\n")),(0,i.kt)("p",null,"To check if characters in a string are all different, a nice trick is to first convert it to a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),", and then testing if the size is the same as the original:\n",(0,i.kt)("inlineCode",{parentName:"p"},"myString.toSet.size == myString.size"),".\nIn this case we know the size will always be 4, because ",(0,i.kt)("inlineCode",{parentName:"p"},"sliding(4)")," always returns strings of length 4, so we can write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Scala"},"  def allDifferent(s: String): Boolean = s.toSet.size == 4\n")),(0,i.kt)("p",null,"The last piece of the puzzle is to find the first index where a condition is true, again the standard library has something for us: ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/StringOps.html#indexWhere(p:Char=%3EBoolean,from:Int):Int"},(0,i.kt)("inlineCode",{parentName:"a"},"indexWhere")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Scala"},"  val firstIndex = windows.indexWhere(allDifferent)\n")),(0,i.kt)("p",null,"We can now assemble everything:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Scala"},"def part1(input: String): Int =\n  val windows = input.sliding(4)\n  def allDifferent(s: String): Boolean = s.toSet.size == 4\n  val firstIndex = windows.indexWhere(allDifferent)\n  firstIndex + 4\n")),(0,i.kt)("p",null,"You'll notice we have to add 4 to the final answer, that's because ",(0,i.kt)("inlineCode",{parentName:"p"},"firstIndex")," tells us the index of the first character of the window, and we want the last one."),(0,i.kt)("p",null,"That was only the solution for the first part, but the only difference for part 2 is that the sequences need to be of 14 characters instead of 4!"),(0,i.kt)("p",null,"So we can just extract our logic into a nice function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Scala"},"def findIndex(input: String, n: Int): Int =\n  val windows = input.sliding(n)\n  def allDifferent(s: String): Boolean = s.toSet.size == n\n  val firstIndex = windows.indexWhere(allDifferent)\n  firstIndex + n\n")),(0,i.kt)("p",null,"And inline the intermediate results:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def findIndex(input: String, n: Int): Int =\n  input.sliding(n).indexWhere(_.toSet.size == n) + n\n")),(0,i.kt)("p",null,"There we have it, a one-line solution!"),(0,i.kt)("p",null,"P.S: ",(0,i.kt)("inlineCode",{parentName:"p"},"sliding"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"toSet"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"indexWhere")," are not only available for ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s but for almost all collections!"),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  findIndex(input, n = 4)\n\ndef part2(input: String): Int =\n  findIndex(input, n = 14)\n\ndef findIndex(input: String, n: Int): Int =\n  input.sliding(n).indexWhere(_.toSet.size == n) + n\n")),(0,i.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("h4",{id:"part-1"},"Part 1"),(0,i.kt)(o.Z,{puzzle:"day06-part1",year:"2022",mdxType:"Solver"}),(0,i.kt)("h4",{id:"part-2"},"Part 2"),(0,i.kt)(o.Z,{puzzle:"day06-part2",year:"2022",mdxType:"Solver"}),(0,i.kt)("h3",{id:"optimising-the-code"},"Optimising the Code"),(0,i.kt)("p",null,"The code shown so far is very concise, however it is not optimal for very large input strings. There will be many intermediate objects created, such as the strings in the sliding window, and the sets on each string in the window."),(0,i.kt)("p",null,"This can make pressure on the garbage collector, slowing down the program."),(0,i.kt)("p",null,"We can optimise this in two ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"avoid allocating intermediate strings for each window,"),(0,i.kt)("li",{parentName:"ul"},"reusing a mutable set to record which characters are in the window.")),(0,i.kt)("p",null,"For the optimised solution, you can reuse a single, mutable set. As you advance the window by 1 index, you should remove the first element of the previous window, and add the last element of the current window."),(0,i.kt)("p",null,"There is a problem however, an ordinary set is not enough, you need a multiset to record how many times each character\nappears in the window."),(0,i.kt)("p",null,"To illustrate, imagine the small input ",(0,i.kt)("inlineCode",{parentName:"p"},"aabc")," and the window size of ",(0,i.kt)("inlineCode",{parentName:"p"},"3"),".\nfollowing the steps above with an ordinary set, after 1 step the set will contain ",(0,i.kt)("inlineCode",{parentName:"p"},"[ab]"),", then in the next step we\nwould remove ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", leaving ",(0,i.kt)("inlineCode",{parentName:"p"},"[b]"),", and then add ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),", leaving ",(0,i.kt)("inlineCode",{parentName:"p"},"[bc]"),". This is incorrect because the set should contain\n",(0,i.kt)("inlineCode",{parentName:"p"},"[abc]"),", as the sliding window of size ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," contains 3 unique elements."),(0,i.kt)("p",null,"To fix this problem you should use a multi-set. At the end of the first step you would have ",(0,i.kt)("inlineCode",{parentName:"p"},"[a:2,b:1]"),", then at the next step you would have ",(0,i.kt)("inlineCode",{parentName:"p"},"[a:1,b:1,c:1]"),", which has the same number of elements as the window."),(0,i.kt)("p",null,"The second optimisation is to avoid creating intermediate strings in the sliding window. Considering the solution with\nthe multiset described above, you only care about the first and last element of each window, which can be represented\nby two indexes into the string."),(0,i.kt)("p",null,"The final optimisation is to only update the set when the last element of the window is different to the first element\nof the previous window."),(0,i.kt)("p",null,"The final optimised code is presented below, including an implementation of the multiset:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  findIndexOptimal(input, n = 4)\n\ndef part2(input: String): Int =\n  findIndexOptimal(input, n = 14)\n\nclass MultiSet:\n  private val counts = new Array[Int](26)\n  private var uniqueElems = 0\n\n  def size = uniqueElems\n\n  def add(c: Char) =\n    val count = counts(c - 'a')\n    if count == 0 then\n      uniqueElems += 1\n    counts(c - 'a') += 1\n\n  def remove(c: Char) =\n    val count = counts(c - 'a')\n    if count > 0 then\n      if count == 1 then\n        uniqueElems -= 1\n      counts(c - 'a') -= 1\nend MultiSet\n\ndef findIndexOptimal(input: String, n: Int): Int =\n  val counts = MultiSet()\n  def loop(i: Int, j: Int): Int =\n    if counts.size == n then\n      i + n // found the index\n    else if j >= input.length then\n      -1 // window went beyond the end\n    else\n      val previous = input(i)\n      val last = input(j)\n      if previous != last then\n        counts.remove(previous)\n        counts.add(last)\n      loop(i = i + 1, j = j + 1)\n  end loop\n  input.iterator.take(n).foreach(counts.add) // add up-to the first `n` elements\n  loop(i = 0, j = n)\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2022/blob/master/src/main/scala/day06/Day06.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SimY4/advent-of-code-scala/blob/master/src/main/scala/aoc/y2022/Day6.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/actinglikecrazy"},"SimY4"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue/adventofcode/blob/main/2022/src/test/scala/Day06.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/SethTisue"},"Seth Tisue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gist.github.com/JavadocMD/100e49509c15283390ee124b2638c1c1"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/JavadocMD"},"Tyler Coles")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosminci/advent-of-code/blob/master/src/main/scala/com/github/cosminci/aoc/_2022/Day6.scala"},"Solution")," by Cosmin Ciobanu"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels/AdventOfCode2022/blob/master/src/main/scala/day06.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/prinsniels"},"Niels Prins")),(0,i.kt)("li",{parentName:"ul"},"Solution ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day6Part1.scala"},"part1")," and ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten/advent-of-code/blob/main/src/main/scala/nl/grons/advent/y2022/Day6Part2.scala"},"part2")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/erikvanoosten"},"Erik van Oosten")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/w-r-z-k/aoc2022/blob/main/src/main/scala/Day6.scala"},"Solution")," by Richard W"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau/code-advent-2022/blob/master/src/main/scala/com/adventofcode/Day6.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/danielnaumau"},"Daniel Naumau")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2022/tree/main/src/main/scala/day6"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rpiotrow/advent-of-code-2022/tree/main/src/main/scala/io/github/rpiotrow/advent2022/day06"},"Solution using ZIO")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rpiotrow"},"Rafa\u0142 Piotrowski")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2022/tree/main/src/main/scala/rui/aoc/year2022/day6"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page."))}h.isMDXComponent=!0}}]);