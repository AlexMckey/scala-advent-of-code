"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8119],{3941:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var a=t(7462),i=(t(7294),t(3905)),o=t(6340);const l={},s="Day 10: Syntax Scoring",r={unversionedId:"puzzles/day10",id:"puzzles/day10",title:"Day 10: Syntax Scoring",description:"by @VincenzoBaz",source:"@site/target/mdoc/puzzles/day10.md",sourceDirName:"puzzles",slug:"/puzzles/day10",permalink:"/scala-advent-of-code/puzzles/day10",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day10.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 9: Smoke Basin",permalink:"/scala-advent-of-code/puzzles/day9"},next:{title:"Day 11: Dumbo Octopus",permalink:"/scala-advent-of-code/puzzles/day11"}},p={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution overview",id:"solution-overview",level:2},{value:"Line checking algorithm",id:"line-checking-algorithm",level:2},{value:"Solution of Part 1",id:"solution-of-part-1",level:2},{value:"Solution of Part 2",id:"solution-of-part-2",level:2},{value:"Run it locally",id:"run-it-locally",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:c};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-10-syntax-scoring"},"Day 10: Syntax Scoring"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/VincenzoBaz"},"@VincenzoBaz")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/10"},"https://adventofcode.com/2021/day/10")),(0,i.kt)("h2",{id:"solution-overview"},"Solution overview"),(0,i.kt)("p",null,"Day 10 focuses on detecting unbalanced markers in the navigation system of the\nsubmarine. The possible markers are ",(0,i.kt)("inlineCode",{parentName:"p"},"()[]{}<>"),".  The input contains several\nlines, our task is to check whether each line is balanced, incomplete or\ninvalid."),(0,i.kt)("p",null,"I propose a solution centered around the algorithm that verifies each line and\nthat will be used in both part 1 and part 2."),(0,i.kt)("p",null,"An input is represented by a ",(0,i.kt)("inlineCode",{parentName:"p"},"LazyList[List[Symbol]]")," where each ",(0,i.kt)("inlineCode",{parentName:"p"},"List[Symbol]"),"\nis a line of the input.\nSymbols are defined by the kind (parenthesis, bracket, brace or diamond) and\nthe direction (open or close):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum Direction:\n  case Open, Close\n\nenum Kind:\n  case Parenthesis, Bracket, Brace, Diamond\n\ncase class Symbol(kind: Kind, direction: Direction):\n  def isOpen: Boolean = direction == Direction.Open\n")),(0,i.kt)("p",null,"In this encoding, ",(0,i.kt)("inlineCode",{parentName:"p"},"{")," is represented by ",(0,i.kt)("inlineCode",{parentName:"p"},"Symbol(Brace, Open)"),"."),(0,i.kt)("p",null,"The function that verifies a line produces a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"CheckResult")," which\nencapsulates the possible results of the check:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Ok")," if the input is valid"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Incomplete(pending)")," if the line finishes leaving some markers open. For\nexample then line ",(0,i.kt)("inlineCode",{parentName:"li"},"[")," is incomplete and will result in ",(0,i.kt)("inlineCode",{parentName:"li"},"Incomplete(List(Symbol(Bracket, Open)))")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"IllegalClosing(expected, found)")," if a line contains a symbol closed by a\nsymbol whose kind is not correct. For example ",(0,i.kt)("inlineCode",{parentName:"li"},"[}")," is corrupted and will result in\n",(0,i.kt)("inlineCode",{parentName:"li"},"IllegalClosing(Some(Symbol(Bracket, Close)), Symbol(Brace, Close))"))),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," is used to encode this hierarchy:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"enum CheckResult:\n  case Ok\n  case IllegalClosing(expected: Option[Symbol], found: Symbol)\n  case Incomplete(pending: List[Symbol])\n")),(0,i.kt)("h2",{id:"line-checking-algorithm"},"Line checking algorithm"),(0,i.kt)("p",null,"The algorithm is implemented in the tail-recursive function ",(0,i.kt)("inlineCode",{parentName:"p"},"iter")," nested in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"checkChunks")," function.  It consumes one character at a time, retrieving it from\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," list.  It also maintains a stack (LIFO) of pending markers. I use\n",(0,i.kt)("inlineCode",{parentName:"p"},"List")," as a stack relying on pattern matching against ",(0,i.kt)("inlineCode",{parentName:"p"},"head :: tail")," to pop or\npush elements on the stack."),(0,i.kt)("p",null,"Consider the base case: when ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," is empty (",(0,i.kt)("inlineCode",{parentName:"p"},"Nil"),") then the algorithm reached the end\nof the line. In this situation, the result is ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok")," if there are no unmatched markers (when the ",(0,i.kt)("inlineCode",{parentName:"p"},"pending")," stack is empty). Otherwise the line is incomplete:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"      case Nil =>\n        if pending.isEmpty then CheckResult.Ok\n        else CheckResult.Incomplete(pending)\n")),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," contains at least one symbol, we pop it from the list.\nIf the symbol is an open marker (",(0,i.kt)("inlineCode",{parentName:"p"},"direction")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Open"),") then we push it\non the ",(0,i.kt)("inlineCode",{parentName:"p"},"pending")," stack and we continue iterating over the rest of the row."),(0,i.kt)("p",null,"Otherwise, when the new symbol is a closing marker, we need to check if it\nmatches the top of the ",(0,i.kt)("inlineCode",{parentName:"p"},"pending")," stack. Therefore if this stack is empty or if\nthe top of the stack has a different ",(0,i.kt)("inlineCode",{parentName:"p"},"kind")," (for example it is brace and the new\nsymbol is a bracket) then we can stop and declare the line as corrupted\n(returning a ",(0,i.kt)("inlineCode",{parentName:"p"},"IllegalClosing"),").  If the line is not corrupted, then the symbol\ncloses the marker opened by the top of the stack: we can remove the top of the\nstack and continue with the rest of the input."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"      case nextChar :: remainingChars =>\n        // a new opening marker: push it on pending and continue analysing the row\n        if nextChar.isOpen then iter(nextChar :: pending, remainingChars)\n        else pending match\n          // pending is empty: nextChar closes a marker that was not opened\n          case Nil => CheckResult.IllegalClosing(None, nextChar)\n          case lastOpened :: previouslyOpened =>\n            // nextChar closes the marker opened by lastOpened, we can continue after popping\n            // the top of the stack.\n            if lastOpened.kind == nextChar.kind then iter(previouslyOpened, remainingChars)\n            // nextChar closes a marker that was not opened by the top of the stack: error\n            else CheckResult.IllegalClosing(Some(lastOpened), nextChar)\n")),(0,i.kt)("h2",{id:"solution-of-part-1"},"Solution of Part 1"),(0,i.kt)("p",null,"To solve the first part, I analyze all the lines in the input and retain the\ncorrupted ones.  As the symbol causing corruption is maintained inside the\n",(0,i.kt)("inlineCode",{parentName:"p"},"IllegalClosing")," object, I can compute the score of each mistake and add them\nup."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (illegalClosing: CheckResult.IllegalClosing)\n  def score: Int =\n    import Kind.*\n    illegalClosing.found.kind match\n      case Parenthesis => 3\n      case Bracket => 57\n      case Brace => 1197\n      case Diamond => 25137\n\ndef part1(input: String): Int =\n  val rows: LazyList[List[Symbol]] =\n    input.linesIterator\n      .to(LazyList)\n      .map(parseRow)\n\n  rows.map(checkChunks)\n    .collect { case illegal: CheckResult.IllegalClosing => illegal.score }\n    .sum\n")),(0,i.kt)(o.Z,{puzzle:"day10-part1",year:"2021",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solution-of-part-2"},"Solution of Part 2"),(0,i.kt)("p",null,"In the second part, we focus on incomplete lines.  For each line, I use an\niteration accumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"currentScore")," initialized to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," and I iterate over each\nmissing symbol, at each step I multiply the accumulator by ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," and add the score\ncorresponding to the missing symbol."),(0,i.kt)("p",null,"I know what symbol is missing from the input because ",(0,i.kt)("inlineCode",{parentName:"p"},"CheckResult.Incomplete"),"\ncontains all the symbols opening a marker which is not closed. Therefore missing\nsymbols can be obtained by iterating over the ",(0,i.kt)("inlineCode",{parentName:"p"},"pending")," stack from top to\nbottom:"),(0,i.kt)("p",null,"This iteration is performed by ",(0,i.kt)("inlineCode",{parentName:"p"},"foldLeft"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (incomplete: CheckResult.Incomplete)\n  def score: BigInt =\n    incomplete.pending.foldLeft(BigInt(0)) { (currentScore, symbol) =>\n      val points = symbol.kind match\n        case Parenthesis => 1\n        case Bracket => 2\n        case Brace => 3\n        case Diamond => 4\n\n      currentScore * 5 + points\n    }\n")),(0,i.kt)("p",null,"Once I have the scores of all incomplete lines, I sort the scores and retrieve\nthe element in the middle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): BigInt =\n  val rows: LazyList[List[Symbol]] =\n    input.linesIterator\n      .to(LazyList)\n      .map(parseRow)\n\n  val scores =\n    rows.map(checkChunks)\n      .collect { case incomplete: CheckResult.Incomplete => incomplete.score }\n      .toVector\n      .sorted\n\n  scores(scores.length / 2)\n")),(0,i.kt)(o.Z,{puzzle:"day10-part2",year:"2021",mdxType:"Solver"}),(0,i.kt)("h2",{id:"run-it-locally"},"Run it locally"),(0,i.kt)("p",null,"You can get this solution locally by cloning the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code"},"scalacenter/scala-advent-of-code")," repository."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git clone https://github.com/scalacenter/scala-advent-of-code\n$ cd scala-advent-of-code\n")),(0,i.kt)("p",null,"You can run it with ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ scala-cli 2021 -M day10.part1\nThe solution is 367059\n$ scala-cli 2021 -M day10.part2\nThe solution is 1952146692\n")),(0,i.kt)("p",null,"You can replace the content of the ",(0,i.kt)("inlineCode",{parentName:"p"},"input/day10")," file with your own input from\n",(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/10"},"adventofcode.com")," to get your own\nsolution."),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/tOverney/AdventOfCode2021/blob/main/src/main/scala/ch/overney/aoc/day10/"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/tOverney"},"@tOverney"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2021/blob/main/src/main/scala/day10/Day10.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/JanBoerman95"},"Jan Boerman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre/AdventOfCode-2021/blob/master/src/main/scala/adventofcode/solutions/Day10.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/FlorianCassayre"},"@FlorianCassayre"),".")),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page. (You can even write the whole article!)"))}m.isMDXComponent=!0}}]);