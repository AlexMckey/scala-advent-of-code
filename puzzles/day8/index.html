<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.7">
<script src="https://plausible.scala-lang.org/js/plausible.js" defer="defer" async data-domain="scalacenter.github.io"></script><title data-react-helmet="true">Day 8: Seven Segment Search | Scala Center Advent of Code</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://scalacenter.github.io//scala-advent-of-code/puzzles/day8"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Day 8: Seven Segment Search | Scala Center Advent of Code"><meta data-react-helmet="true" name="description" content="by @bishabosha"><meta data-react-helmet="true" property="og:description" content="by @bishabosha"><link data-react-helmet="true" rel="shortcut icon" href="/scala-advent-of-code/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://scalacenter.github.io//scala-advent-of-code/puzzles/day8"><link data-react-helmet="true" rel="alternate" href="https://scalacenter.github.io//scala-advent-of-code/puzzles/day8" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://scalacenter.github.io//scala-advent-of-code/puzzles/day8" hreflang="x-default"><link rel="stylesheet" href="/scala-advent-of-code/assets/css/styles.16a73e1b.css">
<link rel="preload" href="/scala-advent-of-code/assets/js/runtime~main.eb543e89.js" as="script">
<link rel="preload" href="/scala-advent-of-code/assets/js/main.de35b7e5.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/scala-advent-of-code/"><div class="navbar__logo"><img src="/scala-advent-of-code/img/scala-tree.png" alt="Scala Center" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/scala-advent-of-code/img/scala-tree.png" alt="Scala Center" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">Scala Advent of Code</b></a><a class="navbar__item navbar__link navbar__link--active" href="/scala-advent-of-code/introduction">Introduction</a><a class="navbar__item navbar__link navbar__link--active" href="/scala-advent-of-code/setup">Setup</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link">Puzzles</a><ul class="dropdown__menu"><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day1">Day 1</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day2">Day 2</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day3">Day 3</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day4">Day 4</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day5">Day 5</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day6">Day 6</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day7">Day 7</a></li><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day8">Day 8</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day9">Day 9</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day10">Day 10</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day11">Day 11</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day12">Day 12</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/scalacenter/scala-advent-of-code" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">ðŸŒœ</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">ðŸŒž</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/scala-advent-of-code/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/scala-advent-of-code/setup">Setup</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Puzzles</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day1">Day 1: Sonar Sweep</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day2">Day 2: Dive!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day3">Day 3: Binary Diagnostic</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day4">Day 4: Giant Squid</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day5">Day 5: Hydrothermal Venture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day6">Day 6: Lanternfish</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day7">Day 7: The Treachery of Whales</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/scala-advent-of-code/puzzles/day8">Day 8: Seven Segment Search</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day9">Day 9: Smoke Basin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day10">Day 10: Syntax Scoring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day11">Day 11</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day12">Day 12</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Day 8: Seven Segment Search</h1></header><p>by <a href="https://twitter.com/bishabosha" target="_blank" rel="noopener noreferrer">@bishabosha</a></p><h2 class="anchor anchorWithStickyNavbar_31ik" id="puzzle-description">Puzzle description<a aria-hidden="true" class="hash-link" href="#puzzle-description" title="Direct link to heading">â€‹</a></h2><p><a href="https://adventofcode.com/2021/day/8" target="_blank" rel="noopener noreferrer">https://adventofcode.com/2021/day/8</a></p><h2 class="anchor anchorWithStickyNavbar_31ik" id="solution-of-part-1">Solution of Part 1<a aria-hidden="true" class="hash-link" href="#solution-of-part-1" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_31ik" id="modelling-the-domain">Modelling the Domain<a aria-hidden="true" class="hash-link" href="#modelling-the-domain" title="Direct link to heading">â€‹</a></h3><p>First we will model our problem so that we can parse the input into our model.</p><p>Let&#x27;s look at the representation of display digits from the problem: we see that
there are a fixed number of possible digits for a display, and that each digit is made by activating
some segments, where there are a fixed number of possible segments:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  0:      1:      2:      3:      4:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> aaaa    ....    aaaa    aaaa    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    c  .    c  .    c  .    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    c  .    c  .    c  .    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ....    ....    dddd    dddd    dddd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e    f  .    f  e    .  .    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e    f  .    f  e    .  .    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> gggg    ....    gggg    gggg    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5:      6:      7:      8:      9:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> aaaa    aaaa    aaaa    aaaa    aaaa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    .  b    .  .    c  b    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    .  b    .  .    c  b    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> dddd    dddd    ....    dddd    dddd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.    f  e    f  .    f  e    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.    f  e    f  .    f  e    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> gggg    gggg    ....    gggg    gggg</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="segment"><code>Segment</code><a aria-hidden="true" class="hash-link" href="#segment" title="Direct link to heading">â€‹</a></h4><p>As there are a fixed range of possible display <em>segments</em>:
<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>g</code>, we will model them with an enumeration.</p><blockquote><p>An enumeration is used to define a type consisting of a set of named values.
Read <a href="https://docs.scala-lang.org/scala3/reference/enums/enums.html" target="_blank" rel="noopener noreferrer">the official documentation</a>
for more details.</p></blockquote><p>Our enumeration <code>Segment</code> looks like the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">enum Segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case A, B, C, D, E, F, G</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="digit"><code>Digit</code><a aria-hidden="true" class="hash-link" href="#digit" title="Direct link to heading">â€‹</a></h4><p>Next, we will model the possible <em>digits</em> of a display. Again, there are a fixed number of them
so we will use an enumeration.</p><p>A <em>digit</em> is made by lighting a number of <em>segments</em>, so we will associate each digit with
the segments required to light it, we can do this by adding a parameter to <code>Digit</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">enum Digit(val segments: Segment*):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Zero extends Digit(A, B, C, E, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case One extends Digit(C, F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Two extends Digit(A, C, D, E, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Three extends Digit(A, C, D, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Four extends Digit(B, C, D, F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Five extends Digit(A, B, D, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Six extends Digit(A, B, D, E, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Seven extends Digit(A, C, F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Eight extends Digit(A, B, C, D, E, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Nine extends Digit(A, B, C, D, F, G)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>In the above <code>case One extends Digit(C, F)</code> defines a <code>Digit</code>: <code>One</code> which has segments <code>C</code> and <code>F</code>.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_31ik" id="segment-strings-aka-segments">Segment Strings, aka <code>Segments</code><a aria-hidden="true" class="hash-link" href="#segment-strings-aka-segments" title="Direct link to heading">â€‹</a></h4><p>In the input we see many sequences of strings, such as <code>&quot;fdcagb&quot;</code>, which we will call
<em>segment strings</em>. We can think of a segment string as a set of characters
that represent the segments lit in a single digit of a display.
These segments are not necessarily the correct configuration for viewing by humans.</p><p>We will model a segment string in Scala by values of type <code>Set[Segment]</code>, which we will
simplify with a type alias <code>Segments</code>, defined in the companion object of
<code>Segment</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">object Segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  type Segments = Set[Segment]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="finding-a-unique-digit-from-segments">Finding A Unique <code>Digit</code> from <code>Segments</code><a aria-hidden="true" class="hash-link" href="#finding-a-unique-digit-from-segments" title="Direct link to heading">â€‹</a></h3><p>The problem asks us to find segment strings that correspond to the digits with a unique number of segments.</p><p>If we group the digits by the number of segments they have, we can see the following picture:</p><table><thead><tr><th>No. Segments</th><th>Digits</th></tr></thead><tbody><tr><td>2</td><td>{ <code>One</code> }</td></tr><tr><td>3</td><td>{ <code>Seven</code> }</td></tr><tr><td>4</td><td>{ <code>Four</code> }</td></tr><tr><td>5</td><td>{ <code>Two</code> , <code>Three</code> , <code>Five</code> }</td></tr><tr><td>6</td><td>{ <code>Zero</code> , <code>Six</code> , <code>Nine</code> }</td></tr><tr><td>7</td><td>{ <code>Eight</code> }</td></tr></tbody></table><p>We can build the table above with the following code:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val bySizeLookup: Map[Int, Seq[Digit]] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Digit.values.toIndexedSeq.groupBy(_.segments.size)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>In the above, we can access all <code>Digit</code> values with the built in <code>values</code> method of the companion,
here we have converted it to a <code>Seq</code> for convenience.</p></blockquote><p>However we are only interested in the entries where the segment count is linked
to a single digit. We can remove the entries with more than one digit, and map each key to a single digit
with a <code>collect</code> call:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val uniqueLookup: Map[Int, Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bySizeLookup.collect { case k -&gt; Seq(d) =&gt; k -&gt; d }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>You can think of the above as &quot;<em>keep all entries where <code>k</code> is mapped to a singleton sequence, and map <code>k</code> instead</em>
<em>to that single element <code>d</code>.&quot;</em></p></blockquote><p>The content of <code>uniqueLookup</code> looks like the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Map(2 -&gt; One, 3 -&gt; Seven, 4 -&gt; Four, 7 -&gt; Eight)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>For our problem, we need to lookup a <code>Digit</code> from a segment string, which we will implement
in the companion of <code>Digit</code>, with a method <code>lookupUnique</code>. The method takes a segment string
(of type <code>Segments</code>), and returns an <code>Option[Digit]</code>.</p><p>To implement this, we call <code>get</code> on
<code>uniqueLookup</code> with the size of the segment string, which returns an <code>Option[Digit]</code>, depending
on whether the key was present.</p><p>Here is the final companion of <code>Digit</code> (where <code>uniqueLookup</code> inlines the definition of <code>bySizeLookup</code>):</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">object Digit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val index: IndexedSeq[Digit] = values.toIndexedSeq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private val uniqueLookup: Map[Int, Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    index.groupBy(_.segments.size).collect { case k -&gt; Seq(d) =&gt; k -&gt; d }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def lookupUnique(segments: Segments): Option[Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uniqueLookup.get(segments.size)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="parsing-the-input">Parsing the input<a aria-hidden="true" class="hash-link" href="#parsing-the-input" title="Direct link to heading">â€‹</a></h3><h4 class="anchor anchorWithStickyNavbar_31ik" id="parsing-segments">Parsing <code>Segments</code><a aria-hidden="true" class="hash-link" href="#parsing-segments" title="Direct link to heading">â€‹</a></h4><p>We will parse each segment string into <code>Segments</code> aka a <code>Set[Segment]</code>.</p><p>First, we add a <code>char</code> field to our <code>Segment</code> enum: its computed by making the first character of <code>toString</code> lower-case:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">enum Segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case A, B, C, D, E, F, G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val char = toString.head.toLower</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Next within <code>Segment</code>&#x27;s companion object we define:</p><ul><li>a reverse map <code>fromChar</code>, which can lookup any <code>Segment</code>
with a matching <code>char</code> field.</li><li>a method <code>parseSegments</code> which takes a segment string (typed as <code>String</code>)
and converts it to a <code>Set[Segment]</code>, by looking up the corresponding
<code>Segment</code> of each character of the string, using <code>fromChar</code>.</li></ul><p>The final companion object to <code>Segment</code> can be seen below:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">object Segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  type Segments = Set[Segment]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val fromChar: Map[Char, Segment] = values.map(s =&gt; s.char -&gt; s).toMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def parseSegments(s: String): Segments =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.map(fromChar).toSet</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>Please note that in <code>parseSegments</code> I am assuming that <code>fromChar</code> will contain each character of the input
string <code>s</code>, which is only safe with correct input. With invalid input it will throw <code>NoSuchElementException</code>.</p><p>To be more explicit with error handling, we could wrap <code>parseSegments</code> with a <a href="https://www.scala-lang.org/api/current/scala/util/Try.html" target="_blank" rel="noopener noreferrer">Try</a>.</p></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="parsing-the-input-file">Parsing the input file<a aria-hidden="true" class="hash-link" href="#parsing-the-input-file" title="Direct link to heading">â€‹</a></h4><p>For part 1 we only need to read the four digit display section of each line, we can parse this from
a line with the following function <code>getDisplay</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def getDisplay(line: String): String = line.split(&#x27;|&#x27;)(1).trim</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>Above, we call <code>line.split(&#x27;|&#x27;)</code>, which will make an <code>Array</code> of the two halves of the line: before and after <code>|</code>.
We are only interested in the second half, so we access the element at index <code>1</code>, and then call <code>trim</code> to remove
leading/terminating spaces.</p></blockquote><p>After using <code>getDisplay</code> we will have a string <code>display</code>, e.g. <code>&quot;fdgacbe cefdb cefbgd gcbe&quot;</code>.
Next we call <code>display.split(&#x27; &#x27;)</code>, to get a sequence of segment strings, e.g.
<code>Array(&quot;fdgacbe&quot;, &quot;cefdb&quot;, &quot;cefbgd&quot;, &quot;gcbe&quot;)</code>.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="computing-the-solution">Computing the Solution<a aria-hidden="true" class="hash-link" href="#computing-the-solution" title="Direct link to heading">â€‹</a></h3><p>Finally we want to lookup a possible unique digit for each segment string.</p><p>We will create a helper function <code>parseUniqueDigit</code> which first parses a segment string as
<code>Segments</code> and then looks up a unique <code>Digit</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def parseUniqueDigit(s: String): Option[Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Digit.lookupUnique(Segment.parseSegments(s))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Then, to compute the final result we will proceed as follows, for each line get the display output <code>display</code>,
then for each display find each encoded digit <code>segments</code>, for each encoded digit lookup a possible digit that uniquely
matches. Then get the size of the resulting unique digits:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// `input` is the input file as a String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val uniqueDigits: Iterator[Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    display &lt;- input.linesIterator.map(getDisplay)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    segments &lt;- display.split(&quot; &quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uniqueDigit &lt;- parseUniqueDigit(segments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uniqueDigit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uniqueDigits.size</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="final-code">Final Code<a aria-hidden="true" class="hash-link" href="#final-code" title="Direct link to heading">â€‹</a></h3><p>The final code for part one is as follows:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">import Segment.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case A, B, C, D, E, F, G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val char = toString.head.toLower</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object Segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  type Segments = Set[Segment]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val fromChar: Map[Char, Segment] = values.map(s =&gt; s.char -&gt; s).toMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def parseSegments(s: String): Segments =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.map(fromChar).toSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end Segment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Digit(val segments: Segment*):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Zero extends Digit(A, B, C, E, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case One extends Digit(C, F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Two extends Digit(A, C, D, E, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Three extends Digit(A, C, D, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Four extends Digit(B, C, D, F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Five extends Digit(A, B, D, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Six extends Digit(A, B, D, E, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Seven extends Digit(A, C, F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Eight extends Digit(A, B, C, D, E, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Nine extends Digit(A, B, C, D, F, G)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object Digit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val index: IndexedSeq[Digit] = values.toIndexedSeq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private val uniqueLookup: Map[Int, Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    index.groupBy(_.segments.size).collect { case k -&gt; Seq(d) =&gt; k -&gt; d }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def lookupUnique(segments: Segments): Option[Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uniqueLookup.get(segments.size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end Digit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def part1(input: String): Int =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def getDisplay(line: String): String = line.split(&#x27;|&#x27;)(1).trim</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def parseUniqueDigit(s: String): Option[Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Digit.lookupUnique(Segment.parseSegments(s))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val uniqueDigits: Iterator[Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      display &lt;- input.linesIterator.map(getDisplay)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      segments &lt;- display.split(&quot; &quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      uniqueDigit &lt;- parseUniqueDigit(segments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      uniqueDigit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uniqueDigits.size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end part1</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div id="day8-part1"></div><h2 class="anchor anchorWithStickyNavbar_31ik" id="solution-of-part-2">Solution of Part 2<a aria-hidden="true" class="hash-link" href="#solution-of-part-2" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_31ik" id="modelling-the-domain-1">Modelling the Domain<a aria-hidden="true" class="hash-link" href="#modelling-the-domain-1" title="Direct link to heading">â€‹</a></h3><p>For part 2 we can reuse all data structures from part 1.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="cryptography-and-decoding">Cryptography and Decoding<a aria-hidden="true" class="hash-link" href="#cryptography-and-decoding" title="Direct link to heading">â€‹</a></h3><p>In part 2 we are asked to decode each four digit display to an integer number. The problem is that each display
is wired incorrectly, so while the signals to the display are for a correct digit, the observable output is different.</p><p>We know that the configuration of wires is stable, so for each display we are given a list of the 10 possible visible
output signals of the display (one for each digit).</p><p>This problem is identical to a substitution cipher, where the encoded alphabet is the mismatch of wires to segments,
and words are output signals (aka encoded digits). We can rediscover the original alphabet by recognising words
(aka finding how each digit has been encoded).</p><p>To solve the problem, we will take the list of 10 unique output signals (the 10 possible digits) and produce
a dictionary of these associated to their decoded forms (aka a map of type <code>Map[Segments, Digits]</code>).</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="discovering-the-encoded-digits">Discovering the Encoded Digits<a aria-hidden="true" class="hash-link" href="#discovering-the-encoded-digits" title="Direct link to heading">â€‹</a></h3><p>In part 1 we discovered how to identify <code>One</code>, <code>Four</code>, <code>Seven</code> and <code>Eight</code> from encoded digits
because their encoded forms <code>one</code>, <code>four</code>, <code>seven</code> and <code>eight</code> are composed of a unique number of
segments. After finding those digits, we are left with six more digits to discover:</p><ul><li>those with 5 segments: { <code>two</code> , <code>three</code> , <code>five</code> }</li><li>those with 6 segments: { <code>zero</code> , <code>six</code> , <code>nine</code> }</li></ul><p>To help us, lets look again at the valid configurations of segments for digits:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  0:      1:      2:      3:      4:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> aaaa    ....    aaaa    aaaa    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    c  .    c  .    c  .    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    c  .    c  .    c  .    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ....    ....    dddd    dddd    dddd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e    f  .    f  e    .  .    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e    f  .    f  e    .  .    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> gggg    ....    gggg    gggg    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5:      6:      7:      8:      9:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> aaaa    aaaa    aaaa    aaaa    aaaa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    .  b    .  .    c  b    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b    .  b    .  .    c  b    c  b    c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> dddd    dddd    ....    dddd    dddd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.    f  e    f  .    f  e    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.    f  e    f  .    f  e    f  .    f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> gggg    gggg    ....    gggg    gggg</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>You might notice that some of the digits fit within another. For example, <code>One</code> overlaps with
all of <code>Zero</code>, <code>Three</code>, <code>Four</code>, <code>Seven</code>, <code>Eight</code>, and <code>Nine</code>.</p><p>We can formalise this by saying the set of segments for <code>One</code> is a
subset of the segments for each of those other digits.</p><p>If we are trying to identify the encoded digits <code>zero</code>, <code>three</code> and <code>nine</code> however, we can&#x27;t use <code>one</code> to identify
them without some extra steps, as <code>one</code> is a subset of all of those encoded digits.</p><p>To help us, we can instead use the number of segments in each encoded digit:
<code>zero</code> and <code>nine</code> both have 6 segments, but <code>three</code> has 5 segments. We can then conclude
that out of the encoded digits with 5 segments, <code>three</code> can be discovered by finding
the unique element where <code>one</code> is a subset.</p><p>Once we have discovered <code>three</code>, that leaves only { <code>two</code> , <code>five</code> } to discover out of those with 5 segments.</p><p>We can continue in this fashion to discover all the remaining encoded digits, formalised in this table below:</p><table><thead><tr><th>Step</th><th>Encoded Digit</th><th>Rule</th></tr></thead><tbody><tr><td>0</td><td><code>one</code></td><td>the encoded digit with the same number of segments as <code>One</code></td></tr><tr><td>0</td><td><code>four</code></td><td>the encoded digit with the same number of segments as <code>Four</code></td></tr><tr><td>0</td><td><code>seven</code></td><td>the encoded digit with the same number of segments as <code>Seven</code></td></tr><tr><td>0</td><td><code>eight</code></td><td>the encoded digit with the same number of segments as <code>Eight</code></td></tr><tr><td>1</td><td><code>three</code></td><td>unique encoded digit from { <code>two</code> , <code>three</code> , <code>five</code> } where <code>one</code> is a subset</td></tr><tr><td>2</td><td><code>nine</code></td><td>unique encoded digit from { <code>zero</code> , <code>six</code> , <code>nine</code> } where <code>three</code> is a subset</td></tr><tr><td>3</td><td><code>zero</code></td><td>unique encoded digit from { <code>zero</code> , <code>six</code> } where <code>seven</code> is a subset</td></tr><tr><td>3</td><td><code>five</code></td><td>unique encoded digit from { <code>two</code> , <code>five</code> } where (<code>four</code> <code>\</code> <code>one</code>) is a subset</td></tr><tr><td>4</td><td><code>two</code></td><td>remaining encoded digit from { <code>two</code> }</td></tr><tr><td>4</td><td><code>six</code></td><td>remaining encoded digit from { <code>six</code> }</td></tr></tbody></table><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>In the above table (<code>four</code> <code>\</code> <code>one</code>) means the <em>set difference</em>, i.e. the set of segments formed from
removing segments of <code>one</code> from segments of <code>four</code>.</p></div></div><p>Once we have discovered all the encoded digits, we build a dictionary by associating each encoded digit to
the original digit.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="creating-our-subsitution-map">Creating Our Subsitution Map<a aria-hidden="true" class="hash-link" href="#creating-our-subsitution-map" title="Direct link to heading">â€‹</a></h3><p>We will implement our discovery rules with a few helpers.</p><h4 class="anchor anchorWithStickyNavbar_31ik" id="the-encoded-digits">The Encoded Digits<a aria-hidden="true" class="hash-link" href="#the-encoded-digits" title="Direct link to heading">â€‹</a></h4><p>First, we will refer to our list of 10 encoded digits by the value <code>cipher</code>, of type <code>Seq[Segments]</code>.</p><h4 class="anchor anchorWithStickyNavbar_31ik" id="unique-encoded-digits-map">Unique Encoded Digits Map<a aria-hidden="true" class="hash-link" href="#unique-encoded-digits-map" title="Direct link to heading">â€‹</a></h4><p>We will build a map <code>uniques</code> from <code>Digit</code> to the encoded digits with unique segments size,
reusing <code>lookupUnique</code> from part 1:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val uniques: Map[Digit, Segments] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Map.from(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      segments &lt;- cipher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      digit &lt;- Digit.lookupUnique(segments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      digit -&gt; segments</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>Above, we apply <code>Map.from</code> to a sequence of key value pairs (formed by <code>a</code> <code>-&gt;</code> <code>b</code>). The values are formed by
taking each encoded digit, passing it to <code>lookupUnique</code>, and if the encoded digit corresponds to a unique digit,
then pair the valid digit with the encoded digit.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_31ik" id="lookup-encoded-digit-by-a-subset-of-segments">Lookup Encoded Digit by a Subset of Segments<a aria-hidden="true" class="hash-link" href="#lookup-encoded-digit-by-a-subset-of-segments" title="Direct link to heading">â€‹</a></h4><p>Next we need to be able to use a set of segments to select a unique encoded digit from a list, and return the
remaining encoded digits.</p><p>We will do this by creating a function <code>lookup</code> which takes a list of encoded digits
(<code>section</code>) and a discriminator segment set (<code>withSegments</code>).
It produces a pair where the left element is the selected encoded digit, and the right element is the
remaining encoded digits:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def lookup(section: Seq[Segments], withSegments: Segments): (Segments, Seq[Segments]) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val (Seq(uniqueMatch), remaining) = section.partition(withSegments.subsetOf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (uniqueMatch, remaining)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>Above we call <code>section.partition(withSegments.subsetOf)</code> to create a pair of lists, the left is encoded digits
of <code>section</code> that <code>withSegments</code> is a subset of, and the right are encoded digits where it is not.
We expect to find only one unique match for <code>withSegments</code>, so we also assert that a singleton
list is returned on the left.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_31ik" id="5-and-6-segment-sections">5 and 6 Segment Sections<a aria-hidden="true" class="hash-link" href="#5-and-6-segment-sections" title="Direct link to heading">â€‹</a></h4><p>We will create sections of encoded digits of size 5 and size 6:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val ofSizeFive = cipher.filter(encoded =&gt; encoded.sizeIs == 5)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val ofSizeSix = cipher.filter(encoded =&gt; encoded.sizeIs == 6)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="decoding-the-encoded-digits">Decoding the Encoded Digits<a aria-hidden="true" class="hash-link" href="#decoding-the-encoded-digits" title="Direct link to heading">â€‹</a></h4><p>We can now proceed to implement our rules and discover each encoded digit:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">import Digit.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val one = uniques(One)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val four = uniques(Four)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val seven = uniques(Seven)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val eight = uniques(Eight)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val (three, remainingFives) = lookup(ofSizeFive, withSegments = one)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val (nine, remainingSixes) = lookup(ofSizeSix, withSegments = three)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val (zero, Seq(six)) = lookup(remainingSixes, withSegments = seven)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val (five, Seq(two)) = lookup(remainingFives, withSegments = four &amp;~ one)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>In Scala <code>&amp;~</code> is the set difference operator. We also lookup (<code>zero</code> and <code>six</code>) and (<code>five</code> and <code>two</code>)
in one step, as we know that <code>six</code> and <code>two</code> are the only possible elements of the remaining lists.</p><p>We also create new lists, (i.e. <code>remainingFives</code> and <code>remainingSixes</code>) instead of reusing the originals
(<code>ofSizeFive</code>, <code>ofSizeSix</code>) because we cannot remove elements from lists after their creation.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_31ik" id="mapping-from-encoded-digits-to-digits">Mapping from Encoded Digits to Digits<a aria-hidden="true" class="hash-link" href="#mapping-from-encoded-digits-to-digits" title="Direct link to heading">â€‹</a></h4><p>We can now map from the encoded digits to the original digits by associating each encoded digit with the original:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val decode: Map[Segments, Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Seq(zero, one, two, three, four, five, six, seven, eight, nine)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .zip(Digit.index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .toMap</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>In the above, we create a map by first putting the encoded digits in order, we then <code>zip</code> with <code>Digit.index</code>,
creating a list of key-value pairs of encoded digit to <code>Digit</code>. Finally we can call <code>.toMap</code> which creates a lookup
table from the list of pairs.</p><p>Recall that <code>Seq(1, 2, 3).zip(Seq(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;))</code> results in <code>Seq((1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;))</code>.
So we can use <code>zip</code> with <code>Digit.index</code> because it is an ordered sequence of <code>Digit</code>.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_31ik" id="putting-it-all-together">Putting it all Together<a aria-hidden="true" class="hash-link" href="#putting-it-all-together" title="Direct link to heading">â€‹</a></h4><p>We can then put all the parts for decoding the digits into one function <code>substitutions</code> (seen in the final code),
with a single argument <code>cipher</code> (the list of 10 encoded digits) and returning the <code>decode</code> map.</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="parsing-the-input-1">Parsing the Input<a aria-hidden="true" class="hash-link" href="#parsing-the-input-1" title="Direct link to heading">â€‹</a></h3><p>To parse the inputs this time, we will split each line by <code>|</code>, and then convert each half of the line
to a sequence of segment strings by splitting each half on <code>&#x27; &#x27;</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def parseSegmentsSeq(segments: String): Seq[Segments] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  segments.trim.split(&quot; &quot;).toSeq.map(Segment.parseSegments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def splitParts(line: String): (Seq[Segments], Seq[Segments]) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Array(cipher, plaintext) = line.split(&#x27;|&#x27;).map(parseSegmentsSeq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (cipher, plaintext)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="computing-the-solution-1">Computing the Solution<a aria-hidden="true" class="hash-link" href="#computing-the-solution-1" title="Direct link to heading">â€‹</a></h3><h4 class="anchor anchorWithStickyNavbar_31ik" id="decoding-each-display">Decoding Each Display<a aria-hidden="true" class="hash-link" href="#decoding-each-display" title="Direct link to heading">â€‹</a></h4><p>To decode each display, first we parse the input into our problems, i.e.
a sequence of pairs where the left element is the 10 encoded digits <code>cipher</code>, and the right element is the display of
4 encoded digits <code>plaintext</code>.</p><p>Then for each problem, we can then
create the substitution map by applying <code>substitutions</code> to <code>cipher</code>, then we can
use the substitution map on each encoded digit of <code>plaintext</code> to convert it to a <code>Digit</code>.</p><p>We are then left with <code>solutions</code>, which is a list of decoded displays, where each display is a <code>Seq[Digit]</code>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val problems = input.linesIterator.map(splitParts)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val solutions = problems.map((cipher, plaintext) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  plaintext.map(substitutions(cipher))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="converting-seqdigit-to-int">Converting <code>Seq[Digit]</code> to <code>Int</code><a aria-hidden="true" class="hash-link" href="#converting-seqdigit-to-int" title="Direct link to heading">â€‹</a></h4><p>The problem wants us to sum the total of all digit displays after decoding.
Each display has 4 digits, so after decoding the digits we will have a sequence of 4 <code>Digit</code>.</p><p>To convert a sequence of <code>Digit</code> to an integer value, we can convert each digit to its corresponding integer
representation by calling <code>.ordinal</code>, and then we can accumulate a sum by (from the left),
multiplying the current total by 10 for each new digit, and then adding the current digit:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def digitsToInt(digits: Seq[Digit]): Int =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  digits.foldLeft(0)((acc, d) =&gt; acc * 10 + d.ordinal)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="final-result">Final Result<a aria-hidden="true" class="hash-link" href="#final-result" title="Direct link to heading">â€‹</a></h4><p>Finally, we use our <code>digitsToInt</code> function to convert each solution to an integer value, and sum the result:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">solutions.map(digitsToInt).sum</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="final-code-1">Final Code<a aria-hidden="true" class="hash-link" href="#final-code-1" title="Direct link to heading">â€‹</a></h3><p>The final code for part 2 can be appended to the code of part 1:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">import Digit.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def part2(input: String): Int =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def parseSegmentsSeq(segments: String): Seq[Segments] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    segments.trim.split(&quot; &quot;).toSeq.map(Segment.parseSegments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def splitParts(line: String): (Seq[Segments], Seq[Segments]) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val Array(cipher, plaintext) = line.split(&#x27;|&#x27;).map(parseSegmentsSeq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (cipher, plaintext)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def digitsToInt(digits: Seq[Digit]): Int =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    digits.foldLeft(0)((acc, d) =&gt; acc * 10 + d.ordinal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val problems = input.linesIterator.map(splitParts)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val solutions = problems.map((cipher, plaintext) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    plaintext.map(substitutions(cipher))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  solutions.map(digitsToInt).sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end part2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def substitutions(cipher: Seq[Segments]): Map[Segments, Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def lookup(section: Seq[Segments], withSegments: Segments): (Segments, Seq[Segments]) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val (Seq(uniqueMatch), remaining) = section.partition(withSegments.subsetOf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (uniqueMatch, remaining)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val uniques: Map[Digit, Segments] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map.from(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        segments &lt;- cipher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        digit &lt;- Digit.lookupUnique(segments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        digit -&gt; segments</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val ofSizeFive = cipher.filter(_.sizeIs == 5)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val ofSizeSix = cipher.filter(_.sizeIs == 6)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val one = uniques(One)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val four = uniques(Four)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val seven = uniques(Seven)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val eight = uniques(Eight)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val (three, remainingFives) = lookup(ofSizeFive, withSegments = one)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val (nine, remainingSixes) = lookup(ofSizeSix, withSegments = three)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val (zero, Seq(six)) = lookup(remainingSixes, withSegments = seven)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val (five, Seq(two)) = lookup(remainingFives, withSegments = four &amp;~ one)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val decode: Map[Segments, Digit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Seq(zero, one, two, three, four, five, six, seven, eight, nine)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .zip(Digit.index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .toMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  decode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end substitutions</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div id="day8-part2"></div><h2 class="anchor anchorWithStickyNavbar_31ik" id="run-it-locally">Run it locally<a aria-hidden="true" class="hash-link" href="#run-it-locally" title="Direct link to heading">â€‹</a></h2><p>You can get this solution locally by cloning the <a href="https://github.com/scalacenter/scala-advent-of-code" target="_blank" rel="noopener noreferrer">scalacenter/scala-advent-of-code</a> repository.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">$ git clone https://github.com/scalacenter/scala-advent-of-code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ cd advent-of-code</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>You can run it with <a href="https://scala-cli.virtuslab.org/" target="_blank" rel="noopener noreferrer">scala-cli</a>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">$ scala-cli src -M day8.part1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The solution is 521</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ scala-cli src -M day8.part2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The solution is 1016804</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>You can replace the content of the <code>input/day8</code> file with your own input from <a href="https://adventofcode.com/2021/day/8" target="_blank" rel="noopener noreferrer">adventofcode.com</a> to get your own solution.</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="solutions-from-the-community">Solutions from the community<a aria-hidden="true" class="hash-link" href="#solutions-from-the-community" title="Direct link to heading">â€‹</a></h2><ul><li><a href="https://github.com/tOverney/AdventOfCode2021/blob/main/src/main/scala/ch/overney/aoc/day8/" target="_blank" rel="noopener noreferrer">Solution</a> of <a href="https://github.com/tOverney" target="_blank" rel="noopener noreferrer">@tOverney</a>.</li></ul><p>Share your solution to the Scala community by editing this page.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day8.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/scala-advent-of-code/puzzles/day7"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Day 7: The Treachery of Whales</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/scala-advent-of-code/puzzles/day9"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Day 9: Smoke Basin<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#puzzle-description" class="table-of-contents__link toc-highlight">Puzzle description</a></li><li><a href="#solution-of-part-1" class="table-of-contents__link toc-highlight">Solution of Part 1</a><ul><li><a href="#modelling-the-domain" class="table-of-contents__link toc-highlight">Modelling the Domain</a></li><li><a href="#finding-a-unique-digit-from-segments" class="table-of-contents__link toc-highlight">Finding A Unique <code>Digit</code> from <code>Segments</code></a></li><li><a href="#parsing-the-input" class="table-of-contents__link toc-highlight">Parsing the input</a></li><li><a href="#computing-the-solution" class="table-of-contents__link toc-highlight">Computing the Solution</a></li><li><a href="#final-code" class="table-of-contents__link toc-highlight">Final Code</a></li></ul></li><li><a href="#solution-of-part-2" class="table-of-contents__link toc-highlight">Solution of Part 2</a><ul><li><a href="#modelling-the-domain-1" class="table-of-contents__link toc-highlight">Modelling the Domain</a></li><li><a href="#cryptography-and-decoding" class="table-of-contents__link toc-highlight">Cryptography and Decoding</a></li><li><a href="#discovering-the-encoded-digits" class="table-of-contents__link toc-highlight">Discovering the Encoded Digits</a></li><li><a href="#creating-our-subsitution-map" class="table-of-contents__link toc-highlight">Creating Our Subsitution Map</a></li><li><a href="#parsing-the-input-1" class="table-of-contents__link toc-highlight">Parsing the Input</a></li><li><a href="#computing-the-solution-1" class="table-of-contents__link toc-highlight">Computing the Solution</a></li><li><a href="#final-code-1" class="table-of-contents__link toc-highlight">Final Code</a></li></ul></li><li><a href="#run-it-locally" class="table-of-contents__link toc-highlight">Run it locally</a></li><li><a href="#solutions-from-the-community" class="table-of-contents__link toc-highlight">Solutions from the community</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Content</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/scala-advent-of-code/introduction">Introduction</a></li><li class="footer__item"><a class="footer__link-item" href="/scala-advent-of-code/setup">Setup</a></li><li class="footer__item"><a class="footer__link-item" href="/scala-advent-of-code/puzzles/day1">Puzzles</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://discord.com/channels/632150470000902164/913451015246868530" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/scala_lang" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://scala.epfl.ch/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scala Center<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/scalacenter" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Scala Center, Built with Docusaurus.</div></div></div></footer></div>
<script src="/scala-advent-of-code/assets/js/runtime~main.eb543e89.js"></script>
<script src="/scala-advent-of-code/assets/js/main.de35b7e5.js"></script>
</body>
</html>