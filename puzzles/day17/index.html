<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.7">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
<script src="https://plausible.scala-lang.org/js/script.js" defer="defer" async data-domain="scalacenter.github.io"></script><title data-react-helmet="true">Day 17: Trick Shot | Scala Center Advent of Code</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://scalacenter.github.io//scala-advent-of-code/puzzles/day17"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Day 17: Trick Shot | Scala Center Advent of Code"><meta data-react-helmet="true" name="description" content="by @bishabosha"><meta data-react-helmet="true" property="og:description" content="by @bishabosha"><link data-react-helmet="true" rel="shortcut icon" href="/scala-advent-of-code/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://scalacenter.github.io//scala-advent-of-code/puzzles/day17"><link data-react-helmet="true" rel="alternate" href="https://scalacenter.github.io//scala-advent-of-code/puzzles/day17" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://scalacenter.github.io//scala-advent-of-code/puzzles/day17" hreflang="x-default"><link rel="stylesheet" href="/scala-advent-of-code/assets/css/styles.16a73e1b.css">
<link rel="preload" href="/scala-advent-of-code/assets/js/runtime~main.af9b7c7f.js" as="script">
<link rel="preload" href="/scala-advent-of-code/assets/js/main.0adb1467.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/scala-advent-of-code/"><div class="navbar__logo"><img src="/scala-advent-of-code/img/scala-tree.png" alt="Scala Center" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/scala-advent-of-code/img/scala-tree.png" alt="Scala Center" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">Scala Advent of Code</b></a><a class="navbar__item navbar__link navbar__link--active" href="/scala-advent-of-code/introduction">Introduction</a><a class="navbar__item navbar__link navbar__link--active" href="/scala-advent-of-code/setup">Setup</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link">Puzzles</a><ul class="dropdown__menu"><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day1">Day 1</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day2">Day 2</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day3">Day 3</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day4">Day 4</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day5">Day 5</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day6">Day 6</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day7">Day 7</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day8">Day 8</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day9">Day 9</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day10">Day 10</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day11">Day 11</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day12">Day 12</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day13">Day 13</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day14">Day 14</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day15">Day 15</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day16">Day 16</a></li><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day17">Day 17</a></li><li><a class="dropdown__link navbar__link--active" href="/scala-advent-of-code/puzzles/day20">Day 20</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/scalacenter/scala-advent-of-code" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">ðŸŒœ</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">ðŸŒž</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/scala-advent-of-code/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/scala-advent-of-code/setup">Setup</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Puzzles</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day1">Day 1: Sonar Sweep</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day2">Day 2: Dive!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day3">Day 3: Binary Diagnostic</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day4">Day 4: Giant Squid</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day5">Day 5: Hydrothermal Venture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day6">Day 6: Lanternfish</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day7">Day 7: The Treachery of Whales</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day8">Day 8: Seven Segment Search</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day9">Day 9: Smoke Basin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day10">Day 10: Syntax Scoring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day11">Day 11: Dumbo Octopus</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day12">Day 12: Passage Pathing</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day13">Day 13: Transparent Origami</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day14">Day 14: Extended Polymerization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day15">Day 15: Chiton</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day16">Day 16: Packet Decoder</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/scala-advent-of-code/puzzles/day17">Day 17: Trick Shot</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day18">Day 18: Snailfish</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day19">Day 19: Beacon Scanner</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/scala-advent-of-code/puzzles/day20">Day 20: Trench Map</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Day 17: Trick Shot</h1></header><p>by <a href="https://twitter.com/bishabosha" target="_blank" rel="noopener noreferrer">@bishabosha</a></p><h2 class="anchor anchorWithStickyNavbar_31ik" id="puzzle-description">Puzzle description<a aria-hidden="true" class="hash-link" href="#puzzle-description" title="Direct link to heading">â€‹</a></h2><p><a href="https://adventofcode.com/2021/day/17" target="_blank" rel="noopener noreferrer">https://adventofcode.com/2021/day/17</a></p><h2 class="anchor anchorWithStickyNavbar_31ik" id="solution-of-part-1">Solution of Part 1<a aria-hidden="true" class="hash-link" href="#solution-of-part-1" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_31ik" id="modelling-the-domain">Modelling The Domain<a aria-hidden="true" class="hash-link" href="#modelling-the-domain" title="Direct link to heading">â€‹</a></h3><h4 class="anchor anchorWithStickyNavbar_31ik" id="a-moving-probe">A Moving Probe<a aria-hidden="true" class="hash-link" href="#a-moving-probe" title="Direct link to heading">â€‹</a></h4><p>The problem asks us to consider the trajectory of a projectile <em>probe</em>
which has both a <em>position</em> and a <em>velocity</em>. Both positions and velocities
have two directions, <code>x</code> and <code>y</code>, with integer values. We model them
with case classes:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">case class Position(x: Int, y: Int)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">case class Velocity(x: Int, y: Int)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>and then the probe is as follows:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">case class Probe(position: Position, velocity: Velocity)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We also find out that a probe always has an initial position of <code>0,0</code>, so
we model that also:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val initial = Position(x = 0, y = 0)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We are also told about the projectile motion of the probe - it moves
in discrete steps, which we implement as follows:</p><ul><li>on each step we create a new probe with a new position and a new velocity,</li><li>the <code>x</code> of the new position is the sum of <code>x</code> of the old position and <code>x</code>
of the old velocity,</li><li>the <code>y</code> of the new position is the sum of <code>y</code> of the old position and <code>y</code>
of the old velocity,</li><li>the <code>x</code> of the new velocity is given by subtracting the sign (<code>-1</code>, <code>0</code>
or <code>1</code>) of the <code>x</code> of the old velocity from itself (drag slows down the
projectile),</li><li>the <code>y</code> of the new velocity is given by subtracting <code>1</code> from the <code>y</code> of
the old velocity (due to gravity).</li></ul><p>The code is written as such:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def step(probe: Probe): Probe =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Probe(pos, vel) = probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Probe(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Position(x = pos.x + vel.x, y = pos.y + vel.y),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Velocity(x = vel.x - vel.x.sign, y = vel.y - 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="a-target-area">A Target Area<a aria-hidden="true" class="hash-link" href="#a-target-area" title="Direct link to heading">â€‹</a></h4><p>Next we are told that a successful launch trajectory causes the probe
to be within a target area after at least one of its steps. The area is
defined by the points within a given range in the <code>x</code> and <code>y</code> directions.
We can model a target area by a case class with two ranges:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">case class Target(xs: Range, ys: Range)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="reasoning-about-the-problem">Reasoning about the Problem<a aria-hidden="true" class="hash-link" href="#reasoning-about-the-problem" title="Direct link to heading">â€‹</a></h3><p>We are told to first identify the initial velocity of trajectories that will
hit the target area exactly, meaning that after a given step, the probe will
be exactly within the target area; and that we must disregard trajectories
that &quot;overshoot&quot;, i.e., that pass through the entire target area in a single step.</p><p>We are also told to find the maximum height (<code>y</code> position) reached out of
all valid trajectories.</p><h4 class="anchor anchorWithStickyNavbar_31ik" id="simulating-a-trajectory">Simulating a trajectory<a aria-hidden="true" class="hash-link" href="#simulating-a-trajectory" title="Direct link to heading">â€‹</a></h4><p>For this problem we simulate a probe moving along a trajectory, i.e.,
iterate every step of the trajectory until the probe either collides with
the target or has moved beyond it. And at each step we record if the
current height of the probe is higher than before.</p><h5 class="anchor anchorWithStickyNavbar_31ik" id="checking-collisions">Checking Collisions<a aria-hidden="true" class="hash-link" href="#checking-collisions" title="Direct link to heading">â€‹</a></h5><p>To identify if the probe collides with the target, we check that its
<code>x</code> position is within the <code>xs</code> range of the target and also that its
<code>y</code> position is within the <code>ys</code> range of the target:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def collides(probe: Probe, target: Target): Boolean =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Probe(pos, _) = probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Target(xs, ys) = target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  xs.contains(pos.x) &amp;&amp; ys.contains(pos.y)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_31ik" id="has-the-probe-moved-beyond-the-target">Has the Probe Moved Beyond the Target?<a aria-hidden="true" class="hash-link" href="#has-the-probe-moved-beyond-the-target" title="Direct link to heading">â€‹</a></h5><p>We can check that the probe has moved beyond the target by considering
situations for each direction:</p><ul><li>for the <code>x</code> direction:<ul><li>the <code>x</code> velocity is <code>0</code> and the <code>x</code> position of the probe is less than
the minimum <code>x</code> position of the target,</li><li>the <code>x</code> position of the probe is greater than the maximum <code>x</code> position
of the target.</li></ul></li><li>for the <code>y</code> direction:<ul><li>the <code>y</code> velocity is less than <code>0</code> and the
<code>y</code> position of the probe is less than the minimum <code>y</code> position of the
target.</li></ul></li></ul><p>The code to compute this is given as such:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def beyond(probe: Probe, target: Target): Boolean =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Probe(pos, vel) = probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Target(xs, ys) = target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val beyondX = (vel.x == 0 &amp;&amp; pos.x &lt; xs.min) || pos.x &gt; xs.max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val beyondY = vel.y &lt; 0 &amp;&amp; pos.y &lt; ys.min</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  beyondX || beyondY</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>The above conditions make the assumptions that the <code>x</code> velocity is never
negative, and that the target is always in the positive <code>x</code> direction.
They are also informed by the fact that the probe eventually always
has negative velocity (due to gravity).</p></div></div><h5 class="anchor anchorWithStickyNavbar_31ik" id="running-the-simulation">Running the Simulation<a aria-hidden="true" class="hash-link" href="#running-the-simulation" title="Direct link to heading">â€‹</a></h5><p>We can use our two conditions to now simulate the trajectory of a probe:</p><ul><li>We begin with an initial <code>probe</code>, and an initial maximum height <code>maxY</code> of
<code>0</code>,</li><li>We then iterate these values - on each iteration, we apply
<code>step</code> to the probe, and replace <code>maxY</code> by the maximum of <code>maxY</code> and
the <code>y</code> position of the current probe,</li><li>we ignore any iteration step where the <code>probe</code> does not collide
with, or go beyond the target, i.e., the probe is still on a valid
trajectory,</li><li>we then find the first iteration that is not ignored, meaning that at
that step the probe must have either collided with the target, or gone
beyond it.</li><li>we then extract the <code>maxY</code> of that iteration, provided that the <code>probe</code>
collided with the target.</li></ul><p>The function <code>simulate</code> implements the rules above, taking parameters
<code>probe</code> and <code>target</code>, and returning an optional value -
<code>Some(maxY)</code> if the trajectory reaches the target, and <code>None</code> if it went
beyond:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def simulate(probe: Probe, target: Target): Option[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LazyList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .iterate((probe, 0))((probe, maxY) =&gt; (step(probe), maxY `max` probe.position.y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .dropWhile((probe, _) =&gt; !collides(probe, target) &amp;&amp; !beyond(probe, target))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .headOption</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { case (probe, maxY) if collides(probe, target) =&gt; maxY }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>The above code uses <code>LazyList.iterate</code>: it creates an infinite sequence
of steps, applied in sequence to an initial value, where each step is
evaluated on-demand. Next we call <code>dropWhile</code>, acting like a condition
of a while loop - it limits the size of our sequence because we know
that eventually one of the conditions will be broken.
We then call <code>headOption</code> to get an <code>Option</code> wrapping the first element
we are interested in. Finally <code>collect</code> allows us to inspect <code>probe</code>
and <code>maxY</code>, and keep <code>maxY</code> when <code>probe</code> matches the condition we want,
otherwise if the condition is not met <code>None</code> will be returned.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_31ik" id="checking-all-possible-trajectories">Checking all Possible Trajectories<a aria-hidden="true" class="hash-link" href="#checking-all-possible-trajectories" title="Direct link to heading">â€‹</a></h4><p>So far we have seen how to simulate the trajectory of a single
probe. We need to find the best possible height reached by all
trajectories - meaning that we need to generate some initial
velocities for the probe.</p><p>We can use some knowledge to help us reduce the search space for
possible velocities.</p><h5 class="anchor anchorWithStickyNavbar_31ik" id="lower-x-bound">Lower <code>x</code> Bound<a aria-hidden="true" class="hash-link" href="#lower-x-bound" title="Direct link to heading">â€‹</a></h5><p>First, we assume that the target will always be in a positive direction
from the probe&#x27;s initial direction, and that the probe&#x27;s <code>x</code> velocity will
only get closer to <code>0</code>, so we do not need to consider
negative <code>x</code> velocities.</p><h5 class="anchor anchorWithStickyNavbar_31ik" id="lower-y-bound">Lower <code>y</code> Bound<a aria-hidden="true" class="hash-link" href="#lower-y-bound" title="Direct link to heading">â€‹</a></h5><p>Second, we know that the problem requires us to find the highest positive
height reached by the probe, and that the probe&#x27;s <code>y</code> velocity can only
fall once in motion. So we do not need to consider negative <code>y</code>
velocities.</p><p>That gives us a lower bound of <code>0</code> for both of the  <code>x</code> and <code>y</code> velocities, what
about the upper bounds for these velocities?</p><h5 class="anchor anchorWithStickyNavbar_31ik" id="upper-x-bound">Upper <code>x</code> Bound<a aria-hidden="true" class="hash-link" href="#upper-x-bound" title="Direct link to heading">â€‹</a></h5><p>We know that a trajectory is invalid if it goes beyond the target in a
single step, so the largest single step that the probe can move in the <code>x</code>
direction (from its initial position) is the distance of the furthest edge
of the target, giving our upper <code>x</code> velocity bound:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val upperBoundX = target.xs.max</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_31ik" id="upper-y-bound">Upper <code>y</code> Bound<a aria-hidden="true" class="hash-link" href="#upper-y-bound" title="Direct link to heading">â€‹</a></h5><p>For the <code>y</code> direction, we know that when a probe launches with an initial
positive <code>y</code> velocity, e.g. <code>y0</code>, after some steps its <code>y</code> velocity will eventually
fall below zero and the probe will cross the x axis (i.e. the probe&#x27;s <code>y</code> position is <code>0</code>).
At this point the probe&#x27;s <code>y</code> velocity will be equal to <code>(y0 + 1) * -1</code>.
If we assume that the target will always be below the x axis, and that at the point of crossing
the x axis, the <code>y</code> velocity upper bound should reach the
furthest edge of the target in one step, then we get the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val upperBoundY = -target.ys.min - 1</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_31ik" id="generating-all-maximum-heights">Generating all Maximum Heights<a aria-hidden="true" class="hash-link" href="#generating-all-maximum-heights" title="Direct link to heading">â€‹</a></h5><p>To proceed we create a function <code>allMaxHeights</code> to return a sequence
of possible maximum heights, one for each valid initial velocity. It
runs the simulation on each possible velocity within the bounds we
defined:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def allMaxHeights(target: Target): Seq[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Target(xs, ys) = target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val upperBoundX = xs.max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val upperBoundY = -ys.min - 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vx &lt;- 0 to upperBoundX</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vy &lt;- 0 to upperBoundY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxy &lt;- simulate(Probe(initial, Velocity(vx, vy)), target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxy</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="computing-the-solution">Computing the Solution<a aria-hidden="true" class="hash-link" href="#computing-the-solution" title="Direct link to heading">â€‹</a></h3><h4 class="anchor anchorWithStickyNavbar_31ik" id="parsing-the-input">Parsing the Input<a aria-hidden="true" class="hash-link" href="#parsing-the-input" title="Direct link to heading">â€‹</a></h4><p>The input for this problem is a single line, possibly ending in
a new line char. e.g.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;target area: x=20..30, y=-10..-5\n&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>From this input we extract two <code>Range</code> values by pattern matching.</p><p>Values of type <code>PartialFunction[A, B]</code> can be used as extractors in
pattern matching, and as we are parsing strings, let&#x27;s make a type alias
<code>Parser[A]</code> to communicate our intent:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">type Parser[A] = PartialFunction[String, A]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>First, let us make a parser for <code>Int</code> values. We use a regex to check
for a numeric string, and then call <code>toInt</code> on the string if it matches:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val IntOf: Parser[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case s if s.matches(raw&quot;-?\d+&quot;) =&gt; s.toInt</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>the <code>raw</code> string interpolator allows us to use regex strings without
escaping backslash &#x27;\&#x27;</p></blockquote><p>We can then use our <code>IntOf</code> parser to parse a single range value.
We use the <code>s</code> interpolator to pattern match on strings and extract
parts from them. E.g. in the following code we extract before and
after <code>..</code> in a string and then assert that they match <code>IntOf</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val RangeOf: Parser[Range] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case s&quot;${IntOf(begin)}..${IntOf(end)}&quot; =&gt; begin to end</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We can finally use our <code>RangeOf</code> parser to parse the input:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val Input: Parser[Target] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case s&quot;target area: x=${RangeOf(xs)}, y=${RangeOf(ys)}&quot; =&gt; Target(xs, ys)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="running-the-solution">Running the Solution<a aria-hidden="true" class="hash-link" href="#running-the-solution" title="Direct link to heading">â€‹</a></h4><p>Finally we can compute the solution. First we trim our input (to remove
unnecessary whitespace from either end).
Next, we apply <code>Input</code> on our trimmed input string, (which may throw
<code>MatchError</code> if our input was invalid) and pass the resulting target to
<code>allMaxHeights</code>, returning the sequence of possible maximum heights.
We then call <code>max</code> on the sequence to get the highest:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def part1(input: String) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  allMaxHeights(Input(input.trim)).max</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_31ik" id="solution-of-part-2">Solution of Part 2<a aria-hidden="true" class="hash-link" href="#solution-of-part-2" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_31ik" id="updating-our-search-space">Updating Our Search Space<a aria-hidden="true" class="hash-link" href="#updating-our-search-space" title="Direct link to heading">â€‹</a></h3><p>The problem for part 2 instead asks us to count the number of all
possible paths that reach the target area. In this case we proceed
as before, but must also consider the possible initial negative <code>y</code>
velocities. These have an upper bound equal to the furthest <code>y</code>
edge of the target (to travel to the furthest edge in one step).</p><p>We adapt <code>allMaxHeights</code> with this new rule:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def allMaxHeights(target: Target)(positiveOnly: Boolean): Seq[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Target(xs, ys) = target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val upperBoundX = xs.max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val upperBoundY = -ys.min -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val lowerBoundY = if positiveOnly then 0 else ys.min</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vx &lt;- 0 to upperBoundX</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vy &lt;- lowerBoundY to upperBoundY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxy &lt;- simulate(Probe(initial, Velocity(vx, vy)), target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxy</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_31ik" id="computing-the-solution-1">Computing the Solution<a aria-hidden="true" class="hash-link" href="#computing-the-solution-1" title="Direct link to heading">â€‹</a></h3><p>As our input has not changed, we can update part 1 and give the code for
part 2 as follows:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">def part1(input: String) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  allMaxHeights(Input(input.trim))(positiveOnly = true).max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def part2(input: String) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  allMaxHeights(Input(input.trim))(positiveOnly = false).size</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Notice that in part 2 we only need the number of possible max heights,
rather than find the highest.</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="final-code">Final Code<a aria-hidden="true" class="hash-link" href="#final-code" title="Direct link to heading">â€‹</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">case class Target(xs: Range, ys: Range)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case class Velocity(x: Int, y: Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case class Position(x: Int, y: Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val initial = Position(x = 0, y = 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case class Probe(position: Position, velocity: Velocity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def step(probe: Probe): Probe =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Probe(Position(px, py), Velocity(vx, vy)) = probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Probe(Position(px + vx, py + vy), Velocity(vx - vx.sign, vy - 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def collides(probe: Probe, target: Target): Boolean =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Probe(Position(px, py), _) = probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Target(xs, ys) = target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  xs.contains(px) &amp;&amp; ys.contains(py)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def beyond(probe: Probe, target: Target): Boolean =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Probe(Position(px, py), Velocity(vx, vy)) = probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val Target(xs, ys) = target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val beyondX = (vx == 0 &amp;&amp; px &lt; xs.min) || px &gt; xs.max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val beyondY = vy &lt; 0 &amp;&amp; py &lt; ys.min</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  beyondX || beyondY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def simulate(probe: Probe, target: Target): Option[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LazyList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .iterate((probe, 0))((probe, maxY) =&gt; (step(probe), maxY `max` probe.position.y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .dropWhile((probe, _) =&gt; !collides(probe, target) &amp;&amp; !beyond(probe, target))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .headOption</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { case (probe, maxY) if collides(probe, target) =&gt; maxY }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def allMaxHeights(target: Target)(positiveOnly: Boolean): Seq[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val upperBoundX = target.xs.max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val upperBoundY = target.ys.min.abs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val lowerBoundY = if positiveOnly then 0 else -upperBoundY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vx &lt;- 0 to upperBoundX</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vy &lt;- lowerBoundY to upperBoundY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxy &lt;- simulate(Probe(initial, Velocity(vx, vy)), target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type Parser[A] = PartialFunction[String, A]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val IntOf: Parser[Int] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case s if s.matches(raw&quot;-?\d+&quot;) =&gt; s.toInt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val RangeOf: Parser[Range] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case s&quot;${IntOf(begin)}..${IntOf(end)}&quot; =&gt; begin to end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val Input: Parser[Target] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case s&quot;target area: x=${RangeOf(xs)}, y=${RangeOf(ys)}&quot; =&gt; Target(xs, ys)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def part1(input: String) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  allMaxHeights(Input(input.trim))(positiveOnly = true).max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def part2(input: String) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  allMaxHeights(Input(input.trim))(positiveOnly = false).size</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_31ik" id="run-it-in-the-browser">Run it in the browser<a aria-hidden="true" class="hash-link" href="#run-it-in-the-browser" title="Direct link to heading">â€‹</a></h2><h4 class="anchor anchorWithStickyNavbar_31ik" id="part-1">Part 1<a aria-hidden="true" class="hash-link" href="#part-1" title="Direct link to heading">â€‹</a></h4><div id="day17-part1"></div><h4 class="anchor anchorWithStickyNavbar_31ik" id="part-2">Part 2<a aria-hidden="true" class="hash-link" href="#part-2" title="Direct link to heading">â€‹</a></h4><div id="day17-part2"></div><h2 class="anchor anchorWithStickyNavbar_31ik" id="run-it-locally">Run it locally<a aria-hidden="true" class="hash-link" href="#run-it-locally" title="Direct link to heading">â€‹</a></h2><p>You can get this solution locally by cloning the <a href="https://github.com/scalacenter/scala-advent-of-code" target="_blank" rel="noopener noreferrer">scalacenter/scala-advent-of-code</a> repository.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">$ git clone https://github.com/scalacenter/scala-advent-of-code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ cd advent-of-code</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>You can run it with <a href="https://scala-cli.virtuslab.org/" target="_blank" rel="noopener noreferrer">scala-cli</a>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">$ scala-cli src -M day17.part1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The answer is: 4851</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ scala-cli src -M day17.part2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The answer is: 1739</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>You can replace the content of the <code>input/day14</code> file with your own input from <a href="https://adventofcode.com/2021/day/14" target="_blank" rel="noopener noreferrer">adventofcode.com</a> to get your own solution.</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="solutions-from-the-community">Solutions from the community<a aria-hidden="true" class="hash-link" href="#solutions-from-the-community" title="Direct link to heading">â€‹</a></h2><p>Share your solution to the Scala community by editing this page.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/puzzles/day17.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/scala-advent-of-code/puzzles/day16"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Day 16: Packet Decoder</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/scala-advent-of-code/puzzles/day18"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Day 18: Snailfish<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#puzzle-description" class="table-of-contents__link toc-highlight">Puzzle description</a></li><li><a href="#solution-of-part-1" class="table-of-contents__link toc-highlight">Solution of Part 1</a><ul><li><a href="#modelling-the-domain" class="table-of-contents__link toc-highlight">Modelling The Domain</a></li><li><a href="#reasoning-about-the-problem" class="table-of-contents__link toc-highlight">Reasoning about the Problem</a></li><li><a href="#computing-the-solution" class="table-of-contents__link toc-highlight">Computing the Solution</a></li></ul></li><li><a href="#solution-of-part-2" class="table-of-contents__link toc-highlight">Solution of Part 2</a><ul><li><a href="#updating-our-search-space" class="table-of-contents__link toc-highlight">Updating Our Search Space</a></li><li><a href="#computing-the-solution-1" class="table-of-contents__link toc-highlight">Computing the Solution</a></li></ul></li><li><a href="#final-code" class="table-of-contents__link toc-highlight">Final Code</a></li><li><a href="#run-it-in-the-browser" class="table-of-contents__link toc-highlight">Run it in the browser</a></li><li><a href="#run-it-locally" class="table-of-contents__link toc-highlight">Run it locally</a></li><li><a href="#solutions-from-the-community" class="table-of-contents__link toc-highlight">Solutions from the community</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Content</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/scala-advent-of-code/introduction">Introduction</a></li><li class="footer__item"><a class="footer__link-item" href="/scala-advent-of-code/setup">Setup</a></li><li class="footer__item"><a class="footer__link-item" href="/scala-advent-of-code/puzzles/day1">Puzzles</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://discord.com/channels/632150470000902164/913451015246868530" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/scala_lang" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://scala.epfl.ch/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scala Center<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/scalacenter" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Scala Center, Built with Docusaurus.</div></div></div></footer></div>
<script src="/scala-advent-of-code/assets/js/runtime~main.af9b7c7f.js"></script>
<script src="/scala-advent-of-code/assets/js/main.0adb1467.js"></script>
</body>
</html>